;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2013 Hex-Rays, <support@hex-rays.com>	    |
; |			 Licensed to: Freeware version			    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	9C3A8A319D72C3F7B1DD1F821637262A

; ---------------------------------------------------------------------------
; File Name   :	C:\Users\Erdoðan\Desktop\COMMAND.COM
; Format      :	MS-DOS COM-file
; Base Address:	0h Range: 100h-D32Ah Loaded length: D22Ah

		Ideal
		p386n
		model tiny

; ===========================================================================

; Segment type:	Pure code
segment		RESGROUP byte public 'RESGROUP' use16
		assume cs:RESGROUP
		;org 100h
		assume es:nothing, ss:nothing, ds:RESGROUP, fs:nothing,	gs:nothing

start:
		jmp	ConProc
; ---------------------------------------------------------------------------
version		db 7Ah			; ((major_version AND 0Fh) SHL 4)
					;   OR (minor_version AND 0Fh)
		dw 0
		db 0Ch dup(0), 0Dh
a@Ibm12_01_2003	db '@#IBM:12.01.2003.build_1.32#@ COMMAND.COM(USA)',0
		db 22h dup(0), 1Ah, 0
Int2f_Entry	dd MsgInt2fHandler	; ...
Int2e_Entry	dd Int_2e		; ...
Ctrlc_Entry	dd ContC		; ...
CritErr_Entry	dd DSKERR		; ...
Exec_Entry	dd 0			; ...
RemCheck_Entry	dd 0			; ...
TrnLodCom1_Entry dd 0			; ...
LodCom_Entry	dd 0			; ...
MsgRetrv_Entry	dd 0			; ...
HeadFix_Entry	dd 0			; ...
UMBOff_Entry	dd 0
XMMCallAddr	dd 0			; ...
ComInHMA	db 0			; ...
; ---------------------------------------------------------------------------

Int2f_Trap:				; ...
		sti
		call	CheckA20
		push	ds
		push	cs
		jmp	[cs:Int2f_Entry]
; ---------------------------------------------------------------------------

Int2e_Trap:				; ...
		sti
		call	CheckA20
		push	ds
		push	cs
		jmp	[cs:Int2e_Entry]
; ---------------------------------------------------------------------------

Ctrlc_Trap:				; ...
		sti
		call	CheckA20
		push	ds
		push	cs
		jmp	[cs:Ctrlc_Entry]
; ---------------------------------------------------------------------------

CritErr_Trap:				; ...
		sti
		call	CheckA20
		push	ds
		push	cs
		jmp	[cs:CritErr_Entry]
; ---------------------------------------------------------------------------

Exec_Trap:				; ...
		call	CheckA20
		push	ds
		push	cs
		jmp	[cs:Exec_Entry]
; ---------------------------------------------------------------------------

RemCheck_Trap:				; ...
		call	CheckA20
		push	ds
		push	cs
		jmp	[cs:RemCheck_Entry]
; ---------------------------------------------------------------------------

TrnLodCom1_Trap:			; ...
		call	CheckA20
		push	ds
		push	cs
		jmp	[cs:TrnLodCom1_Entry]
; ---------------------------------------------------------------------------

LodCom_Trap:				; ...
		call	CheckA20
		push	ds
		push	cs
		jmp	[cs:LodCom_Entry]
; ---------------------------------------------------------------------------

MsgRetrv_Trap:				; ...
		call	CheckA20
		push	ds
		push	cs
		jmp	[cs:MsgRetrv_Entry]
; ---------------------------------------------------------------------------

HeadFix_Trap:				; ...
		call	CheckA20
		push	ds
		push	cs
		jmp	[cs:HeadFix_Entry]

; =============== S U B	R O U T	I N E =======================================


proc		CheckA20 near		; ...
		pushf
		cmp	[cs:ComInHMA], 0
		jz	short A20_on
		push	ax		; QueryA20
		push	bx
		mov	ah, 7
		call	[cs:XMMCallAddr]
		or	ax, ax
		jnz	short QA20_ON
		mov	ah, 5		; EnableA20
		call	[cs:XMMCallAddr]
		or	ax, ax
		jz	short XMMerror

QA20_ON:				; ...
		pop	bx
		pop	ax

A20_on:					; ...
		popf
		retn
; ---------------------------------------------------------------------------

XMMerror:				; ...
		jmp	short XMMerror
endp		CheckA20

; ---------------------------------------------------------------------------
Carousel_i2f_Hook db 0EAh		; ...
					; far jump opcode
		dw offset Int2f_Trap
int2fh_segm	dw 0			; ...

; =============== S U B	R O U T	I N E =======================================


proc		UnHideUMBs near		; ...
		push	ax
		mov	al, [fInHigh]
		or	al, al
		jnz	short uhu10
		pop	ax
		stc
		retn
; ---------------------------------------------------------------------------

uhu10:					; ...
		call	linkumb
		call	FreeUMBs
		mov	[es:fInHigh], 0
		call	he_unlink
		pop	ax
		clc
		retn
endp		UnHideUMBs


; =============== S U B	R O U T	I N E =======================================


proc		he_unlink near		; ...
		xor	bh, bh
		mov	bl, [fm_umb]
		mov	ax, 5803h	; DOS_UMBLINK_SET
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) set UMB link state
		xor	bh, bh
		mov	bl, [fm_strat]
		mov	ax, 5801h	; DOS_STRATEGY_SET
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		retn
endp		he_unlink


; =============== S U B	R O U T	I N E =======================================


proc		FreeUMBs near		; ...
		push	ax
		push	es
		call	HeadUmb
		jb	short fusX

fus10:					; ...
		mov	es, ax
		call	isHideMCB
		jnz	short fus20
		call	freeMCB

fus20:					; ...
		mov	al, [es:0]	; [es:arena_signature]
		cmp	al, 5Ah	; 'Z'
		jz	short fusX
		mov	ax, es
		add	ax, [es:3]	; [es:arena_size]
		inc	ax
		jmp	short fus10
; ---------------------------------------------------------------------------

fusX:					; ...
		pop	es
		pop	ax
		retn
endp		FreeUMBs


; =============== S U B	R O U T	I N E =======================================


proc		isHideMCB near		; ...
		push	ax
		cmp	[word ptr es:1], 8 ; [es:arena_owner],SystemPSPOwner
		jnz	short ihm_x
		mov	ax, [es:8]
		cmp	ax, 4948h	; 'HI'
		jnz	short ihm_x
		mov	ax, [es:0Ah]
		cmp	ax, 4444h	; 'DD'
		jnz	short ihm_x
		mov	ax, [es:0Ch]
		cmp	ax, 4E45h	; 'EN'
		jnz	short ihm_x
		mov	ax, [es:0Eh]
		cmp	ax, 2020h	; '  '

ihm_x:					; ...
		pop	ax
		retn
endp		isHideMCB


; =============== S U B	R O U T	I N E =======================================


proc		freeMCB	near		; ...
		mov	[word ptr es:1], 0 ; [es:arena_owner]
		mov	ax, 2020h
		mov	[es:8],	ax	; [es:arena_name+0]
		mov	[es:0Ah], ax
		mov	[es:0Ch], ax
		mov	[es:0Eh], ax	; [es:arena_name+6]
		retn
endp		freeMCB


; =============== S U B	R O U T	I N E =======================================


proc		HeadUmb	near		; ...
		push	es
		mov	ah, 52h
		int	21h		; DOS -	2+ internal - GET LIST OF LISTS
					; Return: ES:BX	-> DOS list of lists
		mov	ax, [es:8Ch]	; [es:UMB_HeadIdx]
		cmp	ax, 0FFFFh
		jz	short xhu_e
		clc
		jmp	short xhu_x
; ---------------------------------------------------------------------------

xhu_e:					; ...
		stc

xhu_x:					; ...
		pop	es
		retn
endp		HeadUmb


; =============== S U B	R O U T	I N E =======================================


proc		linkumb	near		; ...
		mov	ax, 5802h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) get UMB link state
		or	al, al
		jnz	short lumbX
		mov	ax, 5803h
		mov	bx, 1
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) set UMB link state

lumbX:					; ...
		retn
endp		linkumb

; ---------------------------------------------------------------------------

Issue_Exec_Call:			; ...
		int	21h		; DOS -
		cli
		push	cs
		pop	ss
		assume ss:RESGROUP
		mov	sp, offset RStack ; RStack
		sti
		push	cs
		pop	ds
		pushf
		call	UnHideUMBs
		popf
		jmp	Exec_Trap
; ---------------------------------------------------------------------------
cox_location	db 'cox'                ; ...
cox_Y_option	dw 0			; ...
BlkDevErrSubst	db 2			; ...
BlkDevErrRw	dw 0			; ...
BadFatSubst	db 1			; ...
		dw offset DrvLet
DrvLet		db 'A'                  ; ...
CharDevErrSubst	db 2			; ...
CharDevErrRw	dw 0			; ...
		db 2
		dw offset DevName
NeedVolSubst	db 2			; ...
		dw offset VolName
		db 3
		dw offset VolSer+2
		db 3
		dw offset VolSer
VolName		db 3 dup(0)		; ...
DevName		db 8 dup(0)		; ...
		db 0
VolSer		dd 0			; ...
CDevAt		db 0			; ...
PutBackSubst	db 2			; ...
PutBackComSpec	dw 0			; ...
		db 1
		dw offset PutBackDrv
PutBackDrv	db 20h			; ...
ExecErrSubst	db 2			; ...
		dw offset MsgBuffer	; SafePathBuffer
NeedVol		dd 0			; ...
ErrType		db 0			; ...
Int_2e_Ret	dd 0			; ...
Save_Pdb	dw 0			; ...
Parent		dw 0			; ...
OldTerm		dd 0			; ...
ErrCd_24	dw 0			; ...
Handle01	dw 0			; ...
Loading		db 0			; ...
Batch		dw 0			; ...
ComSpec		db 64 dup(0)		; 0 ; ...
ComSpec_End	dw 0			; ...
Trans		dw offset COMMAND	; ...
TrnSeg		dw 0			; ...
TrnMvFlg	db 0			; ...
In_Batch	db 0			; ...
Batch_Abort	db 0			; ...
ComDrv		db 0			; ...
MemSiz		dw 0			; ...
Sum		dw 0			; ...
ExtCom		db 1			; ...
RetCode		dw 0			; ...
Crit_Err_Info	db 0			; ...
EchoFlag	db 1			; ...
Suppress	db 1			; ...
Io_Save		dw 0			; ...
RestDir		db 0			; ...
PermCom		db 0			; ...
SemiPermCom	dw 0FFFFh		; ...
SingleCom	dw 0			; ...
VerVal		dw 0FFFFh		; ...
fFail		db 0			; ...
IfFlag		db 0			; ...
ForFlag		db 0			; ...
ForPtr		dw 0			; ...
Nest		dw 0			; ...
Call_Flag	db 0			; ...
Call_Batch_Flag	db 0			; ...
Next_Batch	dw 0			; ...
NullFlag	db 0			; ...
FUCase_Addr	db 5 dup(0)		; 0 ; ...
Dbcs_Vector_Addr dd 0			; ...
Append_State	dw 0			; ...
Append_Flag	db 0			; ...
Re_Out_App	db 0			; ...
Re_OutStr	db 80 dup(0)		; 0 ; ...
InitFlag	db 1			; ...
PipeFlag	db 0			; ...
PipeFiles	db 0			; ...
; ---------------------------------------------------------------------------

EndInit:				; ...
		push	ds
		push	es
		mov	dx, [TrnSize]
		mov	ax, [OldEnv]
		mov	bx, [EnvSiz]
		mov	cx, [UsedEnv]
		push	ax
		push	bx
		push	cx
		push	ds
		pop	es
		assume es:RESGROUP
		mov	bx, [ResSize]
		mov	ah, 4Ah		; SETBLOCK
		cmp	[COMMAND_HIGH],	2
		jnz	short set_block
		xor	bx, bx		; low memory first
		mov	ax, 5801h	; set allocation strategy
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		mov	cx, ds:7Eh	; ...
					; environment segment
		jcxz	short skip_dealloc_env_seg
		push	es
		mov	es, cx
		assume es:nothing
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		pop	es

skip_dealloc_env_seg:			; ...
		mov	ah, 49h		; DEALLOC

set_block:				; ...
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		cmp	[PermCom], 1
		jnz	short adjust_env
		cmp	[Batch], 0
		jz	short adjust_env
		mov	bx, 4		; ((BATCHSEGMENT.SIZE)+16+0Fh)/16 ; (33+16+15)/16
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short adjust_env
		mov	es, ax
		assume es:nothing
		xor	di, di
		xor	si, si
		push	ds
		mov	ds, [Batch]
		mov	cx, 33		; BATCHSEGMENT.SIZE
		add	cx, 16		; BATCHSEGMENT.SIZE+16
		cld
		rep movsb		; ...
		pop	ds
		mov	cx, es
		mov	es, [Batch]
		assume es:nothing
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	[cs:Batch], cx	; (CS: prefix is not needed!?)

adjust_env:				; ...
		mov	bx, 80h		; first	fit, try high then low memory
		mov	ax, 5801h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		pop	cx
		pop	bx
		pop	bp
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short nomem_err
		mov	[cs:EnvirSeg], ax ; (CS: prefix	is not needed!?)
		mov	[cs:2Ch], ax	; [cs:PDB.ENVIRON]
		mov	es, ax
		assume es:nothing
		push	ds
		mov	ds, bp
		xor	si, si
		mov	di, si
		cld
		rep movsb
		pop	ds
		cmp	[AllocedEnv], 0
		jz	short no_free
		mov	es, bp
		assume es:nothing
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed

no_free:				; ...
		xor	bx, bx
		mov	ax, 5801h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		xor	bx, bx
		mov	ax, 5803h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) set UMB link state
		mov	[cs:TrnMvFlg], 1 ; (CS:	prefix is not needed!?)
					; Indicate that	transient has been moved
		push	es
		mov	si, 2890h	; TRANSTART
		xor	di, di
		mov	cx, 0AA9Ah	; TRANSPACEEND ; TRANSIENT portion size
		mov	bx, 0FFFFh
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		cmp	bx, dx
		jb	short nomem_err
		mov	ah, 48h		; ALLOC
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short nomem_err
		push	ax
		add	ax, bx
		sub	ax, dx
		mov	[cs:TrnSeg], ax	; (CS: prefix is not needed!?)
		mov	es, ax
		pop	ax
		add	si, cx
		dec	si
		add	di, cx
		dec	di
		std
		rep movsb
		cld
		mov	es, ax
		mov	ah, 49h		; DEALLOC
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	[cs:InitFlag], 0 ; (CS:	prefix is not needed!?)
		pop	es
		pop	ds
		jmp	LodCom_Trap
; ---------------------------------------------------------------------------

nomem_err:				; ...
		jmp	Alloc_error
; ---------------------------------------------------------------------------
COMMAND_HIGH	db 0			; ...
EndCodeInit	db 30 dup(0)		; 0
InPipePtr	dw offset EndInit	; ...
					; dw Pipe1 ; Pipe1 equ offset EndInit
OutPipePtr	dw 46Dh			; ...
					; dw Pipe2 ; Pipe1 + 79
EnvirSeg	dw 0			; ...
Com_Ptr		dw 80h,	0		; 0 ; ...
Com_Fcb1	dw 5Ch,	0		; 0 ; ...
Com_Fcb2	dw 6Ch,	0		; 0 ; ...
TranVars	dw offset HeadFix_Trap	; ...
MySeg		dw 0			; ...
Ltpa		dw 0			; ...
RSwitChar	db '/'                  ; ...
RDirChar	db '\'                  ; ...
		dw offset Issue_Exec_Call
MySeg1		dw 0			; ...
		dw offset RemCheck_Trap
MySeg2		dw 0			; ...
Res_Tpa		dw 0			; ...
Y_Flag		dw 0			; ...
OldErrNo	dw 0			; ...
					; TranVarEnd
MsgBuffer	db 16 dup(0)		; ...
					; db 64+3+13 dup (0)
					; path + 'd:\' 'file.ext' + null
UmbSize		dw 32 dup(0)		; ...
Int2fHandler	dw 2 dup(0)		; ...
ResMsgEnd	dw 0			; ...
ResSize		dw 0			; ...
		db 120 dup(0)		; 0
RStack		dw 0			; ...
fInHigh		db 0			; ...
fUmbTiny	db 0			; ...
SegLoad		dw 0			; ...
UmbLoad		db 0			; ...
fm_umb		db 0			; ...
fm_strat	db 0			; ...
fm_argc		db 0			; ...
ABORT_CHAR	db 'A'                  ; ...
RETRY_CHAR	db 'R'                  ; ...
IGNORE_CHAR	db 'I'                  ; ...
FAIL_CHAR	db 'F'                  ; ...
YES_CHAR	db 'Y'                  ; ...
NO_CHAR		db 'N'                  ; ...
REQ_ABORT	db 5			; ...
		db 'Abort'
REQ_RETRY	db 7			; ...
		db ', Retry'
REQ_IGNORE	db 8			; ...
		db ', Ignore'
REQ_FAIL	db 6			; ...
		db ', Fail'
REQ_END		db 1			; ...
		db '?'
MREAD		db 8			; ...
		db 'reading',0
MWRITE		db 8			; ...
		db 'writing',0
MDRIVE		db 14			; ...
		db ' %1 drive %2',0Dh,0Ah
MDEVICE		db 15			; ...
		db ' %1 device %2',0Dh,0Ah
MVOLSERIAL	db 38			; ...
		db 'Please insert volume %1 serial %2-%3',0Dh,0Ah
BADFATMSG	db 37			; ...
		db 'File allocation table bad, drive %1',0Dh,0Ah
COMBAD		db 21			; ...
		db 'Invalid COMMAND.COM',0Dh,0Ah
PUTBACKMSG	db 33			; ...
		db 'Insert disk with %1 in drive %2',0Dh,0Ah
PROMPT		db 33			; ...
		db 'Press any key to continue . . .',0Dh,0Ah
ENDBATMES	db 28			; ...
		db 0Dh,0Ah
		db 'Terminate batch job (Y/N)?'
EXECEMES	db 19			; ...
		db 'Cannot execute %1',0Dh,0Ah
EXEBAD		db 19			; ...
		db 'Error in EXE file',0Dh,0Ah
TOOBIG		db 34			; ...
		db 'Program too big to fit in memory',0Dh,0Ah
NOHANDMES	db 22			; ...
		db 0Dh,0Ah
		db 'No free file handles'
ACCDEN		db 0Dh			; ...
		db 'Access denied'
BMEMMES		db 19h			; ...
		db 0Dh,0Ah
		db 'Memory allocation error'
HALTMES		db 26h			; ...
		db 0Dh,0Ah
		db 'Cannot load COMMAND, system halted',0Dh,0Ah
FRETMES		db 21h			; ...
		db 0Dh,0Ah
		db 'Cannot start COMMAND, exiting',0Dh,0Ah
NEWLINE		db 2			; ...
		db 0Dh,0Ah
MsgPtrLists	dd 10D24h		; ...
		dw offset PARSMSGPTRS
		dw 1
		dw offset EXTMSGPTRS
		dw 1
		dw 0
		dw 0
		dw offset MsgRetrv_Trap
MySeg3		dw 0			; ...
CRMSG0		db 19			; ...
		db 'Write protect error'
CRMSG1		db 12			; ...
		db 'Invalid unit'
CRMSG2		db 9			; ...
		db 'Not ready'
CRMSG3		db 22			; ...
		db 'Invalid device request'
CRMSG4		db 10			; ...
		db 'Data error'
CRMSG5		db 33			; ...
		db 'Invalid device request parameters'
CRMSG6		db 10			; ...
		db 'Seek error'
CRMSG7		db 18			; ...
		db 'Invalid media type'
CRMSG8		db 16			; ...
		db 'Sector not found'
CRMSG9		db 26			; ...
		db 'Printer out of paper error'
CRMSG10		db 17			; ...
		db 'Write fault error'
CRMSG11		db 16			; ...
		db 'Read fault error'
CRMSG12		db 15			; ...
		db 'General failure'
CRMSG13		db 17			; ...
		db 'Sharing violation'
CRMSG14		db 14			; ...
		db 'Lock violation'
CRMSG15		db 19			; ...
		db 'Invalid disk change'
CRMSG16		db 15			; ...
		db 'FCB unavailable'
CRMSG17		db 25			; ...
		db 'System resource exhausted'
CRMSG18		db 18			; ...
		db 'Code page mismatch'
CRMSG19		db 12			; ...
		db 'Out of input'
CRMSG20		db 23			; ...
		db 'Insufficient disk space'
CRITMSGPTRS	dw offset CRMSG0	; ...
		dw offset CRMSG1
		dw offset CRMSG2
		dw offset CRMSG3
		dw offset CRMSG4
		dw offset CRMSG5
		dw offset CRMSG6
		dw offset CRMSG7
		dw offset CRMSG8
		dw offset CRMSG9
		dw offset CRMSG10
		dw offset CRMSG11
		dw offset CRMSG12
		dw offset CRMSG13
		dw offset CRMSG14
		dw offset CRMSG15
		dw offset CRMSG16
		dw offset CRMSG17
		dw offset CRMSG18
		dw offset CRMSG19
		dw offset CRMSG20
PAERRMSG0	db 19			; ...
		db 'Too many parameters'
PAERRMSG1	db 26			; ...
		db 'Required parameter missing'
PAERRMSG2	db 14			; ...
		db 'Invalid switch'
PAERRMSG3	db 15			; ...
		db 'Invalid keyword'
PAERRMSG4	db 1			; ...
		db 20h
PAERRMSG5	db 36			; ...
		db 'Parameter value not in allowed range'
PAERRMSG6	db 27			; ...
		db 'Parameter value not allowed'
PAERRMSG8	db 28			; ...
		db 'Parameter format not correct'
PAERRMSG9	db 17			; ...
		db 'Invalid parameter'
PAERRMSG10	db 1Dh			; ...
		db 'Invalid parameter combination'
PARSMSGPTRS	dw offset PAERRMSG0	; ...
		dw offset PAERRMSG1
		dw offset PAERRMSG2
		dw offset PAERRMSG3
		dw offset PAERRMSG4
		dw offset PAERRMSG5
		dw offset PAERRMSG6
		dw offset PAERRMSG6	; PAERRMSG7
		dw offset PAERRMSG8
		dw offset PAERRMSG9
		dw offset PAERRMSG10
INVLFUNCT	db 10h			; ...
		db 'Invalid function'
FNOTFOUND	db 0Eh			; ...
		db 'File not found'
PNOTFOUND	db 0Eh			; ...
		db 'Path not found'
TOOMANYOF	db 13h			; ...
		db 'Too many open files'
ACCDENIED	db 0Dh			; ...
		db 'Access denied'
INVHANDLE	db 0Eh			; ...
		db 'Invalid handle'
MEMCBDEST	db 1Fh			; ...
		db 'Memory control blocks destroyed'
INSUFFMEM	db 13h			; ...
		db 'Insufficient memory'
INVMEMBLA	db 1Ch			; ...
		db 'Invalid memory block address'
INVENVIRO	db 13h			; ...
		db 'Invalid Environment'
INVFORMAT	db 0Eh			; ...
		db 'Invalid format'
INVFNPARM	db 1Ah			; ...
		db 'Invalid function parameter'
INVLDDATA	db 0Ch			; ...
		db 'Invalid data'
INVDRVSPC	db 1Bh			; ...
		db 'Invalid drive specification'
ATRCURDIR	db 23h			; ...
		db 'Attempt to remove current directory'
NOTSAMDEV	db 0Fh			; ...
		db 'Not same device'
NOMOREFIL	db 0Dh			; ...
		db 'No more files'
FILEXISTS	db 0Bh			; ...
		db 'File exists'
CANTMKDIR	db 1Bh			; ...
		db 'Cannot make directory entry'
FAILINT24	db 0Eh			; ...
		db 'Fail on INT 24'
TOOMANYRD	db 15h			; ...
		db 'Too many redirections'
DUPLREDIR	db 15h			; ...
		db 'Duplicate redirection'
INVPASSWD	db 10h			; ...
		db 'Invalid password'
INVLDPARM	db 11h			; ...
		db 'Invalid parameter'
NETDATFAU	db 12h			; ...
		db 'Network data fault'
FNOSUPNET	db 21h			; ...
		db 'Function not supported by network'
RSCNOTINS	db 27h			; ...
		db 'Required system component not installed'
EXTMSGPTRS	dw offset INVLFUNCT	; ...
		dw offset FNOTFOUND
		dw offset PNOTFOUND
		dw offset TOOMANYOF
		dw offset ACCDENIED
		dw offset INVHANDLE
		dw offset MEMCBDEST
		dw offset INSUFFMEM
		dw offset INVMEMBLA
		dw offset INVENVIRO
		dw offset INVFORMAT
		dw offset INVFNPARM
		dw offset INVLDDATA
		dw 0
		dw offset INVDRVSPC
		dw offset ATRCURDIR
		dw offset NOTSAMDEV
		dw offset NOMOREFIL
		dw offset CRMSG0
		dw offset CRMSG1
		dw offset CRMSG2
		dw offset CRMSG3
		dw offset CRMSG4
		dw offset CRMSG5
		dw offset CRMSG6
		dw offset CRMSG7
		dw offset CRMSG8
		dw offset CRMSG9
		dw offset CRMSG10
		dw offset CRMSG11
		dw offset CRMSG12
		dw offset CRMSG13
		dw offset CRMSG14
		dw offset CRMSG15
		dw offset CRMSG16
		dw offset CRMSG17
		dw offset CRMSG18
		dw offset CRMSG19
		dw offset CRMSG20
		dw 40 dup(0)
		dw offset FILEXISTS
		dw 0
		dw offset CANTMKDIR
		dw offset FAILINT24
		dw offset TOOMANYRD
		dw offset DUPLREDIR
		dw offset INVPASSWD
		dw offset INVLDPARM
		dw offset NETDATFAU
		dw offset FNOSUPNET
		dw offset RSCNOTINS
PATRICIDE	db 2Eh			; ...
		db 0Dh,0Ah
		db 'Top level process aborted, cannot continue',0Dh,0Ah
		db 9 dup(0)
; ---------------------------------------------------------------------------

Exec_Err:				; ...
		mov	bx, offset TOOBIG ; RCODE_START
		cmp	al, 8		; ERROR_NOT_ENOUGH_MEMORY
		jz	short GotExecEMes
		mov	bx, offset EXEBAD
		cmp	al, 0Bh
		jz	short GotExecEMes
		mov	bx, offset ACCDEN
		cmp	al, 5		; ERROR_ACCESS_DENIED
		jz	short GotExecEMes
		mov	bx, offset EXECEMES
		mov	si, offset ExecErrSubst

GotExecEMes:				; ...
		mov	dx, bx
		call	RPrint
		jmp	short NoExec
; ---------------------------------------------------------------------------

Ext_Exec:				; Exec_Ret
		jb	short Exec_Err

Exec_Wait:
		mov	ah, 4Dh
		int	21h		; DOS -	2+ - GET EXIT CODE OF SUBPROGRAM (WAIT)
		mov	[RetCode], ax

NoExec:					; ...
		jmp	LodCom
; ---------------------------------------------------------------------------

ContC:					; ...
		pop	ds
		test	[InitFlag], 1	; INITINIT ; in	initialization?
		jz	short NotAtInit	; no
		test	[InitFlag], 2	; INITSPECIAL ;	doing special stuff?
		jz	short CmdIret	; no, ignore ^C
		pop	ds
		jmp	init_contc_specialcase
; ---------------------------------------------------------------------------

CmdIret:				; ...
		pop	ds
		iret
; ---------------------------------------------------------------------------

NotAtInit:				; ...
		test	[InitFlag], 4	; INITCTRLC ; are we already in	a ^C?
		jz	short NotInit	; nope too.
		test	ah, ah
		jz	short CmdIret
		cmp	ah, 12
		ja	short CmdIret
		pop	ds
		add	sp, 6
		stc
		retf	2
; ---------------------------------------------------------------------------

NotInit:				; ...
		or	[InitFlag], 4	; INITCTRLC
		sti
		pop	ax
		mov	ax, [SingleCom]
		or	ax, ax
		jnz	short NoReset
		push	ax
		mov	ah, 0Dh
		int	21h		; DOS -	DISK RESET
		pop	ax

NoReset:				; ...
		test	[Batch], 0FFFFh
		jz	short ContCTerm
		or	ax, ax
		jnz	short ContCTerm
		call	SavHand
		call	AskEnd
		jnb	short ContBatch
		mov	cl, [EchoFlag]
		push	bx

ClearBatch:				; ...
		mov	es, [Batch]
		mov	di, 20h		; [BATCHSEGMENT.BatFile]
		mov	bx, [es:5]	; [es:BATCHSEGMENT.BatForPtr]
		test	bx, bx
		jz	short No_Bat_For
		push	es
		mov	es, bx
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		pop	es

No_Bat_For:				; ...
		mov	cl, [es:1]	; [es:BATCHSEGMENT.BatEchoFlag]
		mov	bx, [es:3]	; [es:BATCHSEGMENT.BatLast]
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	[Batch], bx
		dec	[Nest]
		jnz	short ClearBatch
		pop	bx
		mov	[EchoFlag], cl
		mov	[PipeFlag], 0

ContBatch:				; ...
		call	crlf
		call	RestHand

ContCTerm:				; ...
		xor	ax, ax
		mov	bp, ax
		mov	[IfFlag], al
		mov	[ForFlag], al
		call	ResPipeOff
		cmp	[SingleCom], ax
		jz	short NoSetSing
		mov	[SingleCom], 0FFFFh ; -1

NoSetSing:				; ...
		and	[InitFlag], 0FBh ; ~INITCTRLC
		cmp	[ExtCom], al
		jnz	short DoDAb	; internal ^c
		jmp	LodCom1
; ---------------------------------------------------------------------------

DoDAb:					; ...
		stc
		retf

; =============== S U B	R O U T	I N E =======================================


proc		ResPipeOff near		; ...
		push	ax
		xor	ax, ax
		xchg	al, [PipeFlag]
		or	al, al
		jz	short NoPipePop
		shr	[EchoFlag], 1

NoPipePop:				; ...
		pop	ax
		retn
endp		ResPipeOff

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR alloc_env

BadMemErr:				; ...
		mov	dx, offset BMEMMES
; END OF FUNCTION CHUNK	FOR alloc_env
; START	OF FUNCTION CHUNK FOR GetComDsk

FatalC:					; ...
		call	RPrint
		cmp	[PermCom], 0
		jz	short FatalRet
		cmp	[SingleCom], 0
		jnz	short FatalRet
		mov	dx, offset HALTMES
		call	RPrint
		sti

Stall:					; ...
		jmp	short Stall
; ---------------------------------------------------------------------------

FatalRet:				; ...
		mov	dx, offset FRETMES
		call	RPrint

FatalRet2:				; ...
		cmp	[PermCom], 0
		jnz	short Ret_2e
		mov	ax, [Parent]
		mov	[ds:16h], ax	; [PDB.PARENT_PID]
		mov	ax, [word ptr OldTerm]
		mov	[ds:0Ah], ax	; [PDB.EXIT]
		mov	ax, [word ptr OldTerm+2]
		mov	[ds:0Ch], ax	; [PDB.EXIT+2]
		mov	ah, 4Ch
		mov	al, [byte ptr RetCode]
		int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
					; AL = exit code
; ---------------------------------------------------------------------------

Ret_2e:					; ...
		mov	[SingleCom], 0
		mov	es, [Res_Tpa]
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	bx, [Save_Pdb]
		mov	ah, 50h
		int	21h		; DOS -	2+ internal - SET PSP SEGMENT
					; BX = segment address of new PSP
		mov	ax, [RetCode]
		cmp	[ExtCom], 0
		jnz	short GotECode
		xor	ax, ax

GotECode:				; ...
		mov	[ExtCom], 1
		jmp	[Int_2e_Ret]	; jmp far [Int_2e_Ret]
; END OF FUNCTION CHUNK	FOR GetComDsk
; ---------------------------------------------------------------------------

Int_2e:					; ...
		pop	ds
		pop	ax
		pop	[word ptr Int_2e_Ret]
		pop	[word ptr Int_2e_Ret+2]
		add	sp, 2
		push	ds
		pop	es
		assume es:RESGROUP
		mov	ds, ax
		mov	di, 80h
		mov	cx, 64
		rep movsw
		mov	ah, 51h
		int	21h		; DOS -	2+ internal - GET PSP SEGMENT
					; Return: BX = current PSP segment
		mov	[es:Save_Pdb], bx
		mov	ah, 50h
		push	es
		pop	ds
		mov	bx, ds
		int	21h		; DOS -	2+ internal - SET PSP SEGMENT
					; BX = segment address of new PSP
		mov	[SingleCom], 81h
		mov	[ExtCom], 1
		push	ds
		push	ds

LodCom:					; ...
		pop	ds
		add	sp, 2
		cmp	[ExtCom], 0
		jnz	short LodCom0
		jmp	LodCom1
; ---------------------------------------------------------------------------

LodCom0:				; ...
		mov	bx, 0FFFFh
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		call	SetSize
		add	ax, 20h
		cmp	bx, ax
		jnb	short MemOk

BadMemErrJ:				; ...
		jmp	BadMemErr

; =============== S U B	R O U T	I N E =======================================


proc		SetSize	near		; ...
		mov	ax, 0AAA9h	; TRANSPACEEND+15
		mov	cl, 4
		shr	ax, cl
		retn
endp		SetSize

; ---------------------------------------------------------------------------

MemOk:					; ...
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short BadMemErrJ
		mov	[ExtCom], 0
		mov	[Res_Tpa], ax
		and	ax, 0F000h
		add	ax, 1000h
		jb	short Bad_Tpa
		mov	dx, [Res_Tpa]
		add	dx, bx
		cmp	dx, ax
		jbe	short Bad_Tpa
		sub	dx, ax
		cmp	dx, 1000h
		jnb	short LTpaSet

Bad_Tpa:				; ...
		mov	ax, [Res_Tpa]

LTpaSet:				; ...
		mov	[Ltpa],	ax
		mov	ax, [Res_Tpa]
		add	bx, ax
		mov	[MemSiz], bx
		call	SetSize
		sub	bx, ax
		cmp	bx, [TrnSeg]
		jz	short LodCom1
		mov	cx, 0AA9Ah
		ja	short mov_down
		xor	si, si
		mov	di, si
		cld
		jmp	short copy_trans
; ---------------------------------------------------------------------------

mov_down:				; ...
		mov	si, cx
		dec	si
		mov	di, si
		std

copy_trans:				; ...
		push	ds
		push	es
		mov	es, bx
		assume es:nothing
		mov	ds, [TrnSeg]
		rep movsb
		cld
		pop	es
		pop	ds
		mov	[TrnSeg], bx

LodCom1:				; ...
		mov	ax, ds
		mov	ss, ax
		mov	sp, offset RStack ; offset DATARES:RStack
		call	HeadFix
		xor	bp, bp
		mov	ax, 0FFFFh
		xchg	ax, [VerVal]
		cmp	ax, 0FFFFh
		jz	short NoSetVer
		mov	ah, 2Eh
		int	21h		; DOS -	SET VERIFY FLAG
					; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off

NoSetVer:				; ...
		cmp	[SingleCom], 0FFFFh
		jnz	short NoSng
		jmp	FatalRet2
; ---------------------------------------------------------------------------

NoSng:					; ...
		call	ChkSum
		cmp	dx, [Sum]
		jnz	short Bogus_Com
		call	chk_transient
		jz	short HavCom

Bogus_Com:				; ...
		mov	[Loading], 1	; flag DskErr routine
		call	LoadCom

ChkSame:				; ...
		call	ChkSum
		cmp	dx, [Sum]
		jnz	short Also_Bogus
		call	chk_transient	; check	transient portion is valid or not
		jz	short HavCom

Also_Bogus:				; ...
		call	WrongCom
		jmp	short ChkSame
; ---------------------------------------------------------------------------

HavCom:					; ...
		mov	[Loading], 0
		mov	si, offset TranVars
		mov	di, offset HEADCALL
		mov	es, [TrnSeg]
		cld
		mov	cx, offset OldErrNo ; TranVarEnd
		sub	cx, si
		rep movsb
		mov	ax, [MemSiz]
		mov	[ds:2],	ax	; [PDB.BLOCK_LEN]
		jmp	[dword ptr Trans] ; jmp	far [Trans]
; ---------------------------------------------------------------------------

TRemCheck:
		pop	ds
		add	sp, 2
		call	RemCheck
		retf

; =============== S U B	R O U T	I N E =======================================


proc		RemCheck near		; ...
		push	ax
		push	bx
		mov	bx, ax
		mov	ax, 4408h	; (IOCTL<<8)+8
		int	21h		; DOS -	2+ - IOCTL -
		jnb	short rcCont
		or	ax, ax
		jmp	short ResRegs
; ---------------------------------------------------------------------------

rcCont:					; ...
		and	ax, 1
		not	ax

ResRegs:				; ...
		pop	bx
		pop	ax
		retn
endp		RemCheck

; ---------------------------------------------------------------------------

THeadFix:
		pop	ds
		add	sp, 2
		call	HeadFix
		retf

; =============== S U B	R O U T	I N E =======================================


proc		HeadFix	near		; ...
		call	SetVect
		xor	bx, bx		; BX = handle =	0
		mov	cx, [Io_Save]	; CX = original	stdin, stdout
		mov	dx, [ds:18h]	; [PDB.JFN_TABLE]
		cmp	cl, dl		; DX = current stdin, stdout
		jz	short Chk1
		mov	ah, 3Eh		; CLOSE
		call	int21h		; close	stdin
		mov	[ds:18h], cl	; [PDB.JFN_TABLE] ; restore stdin

Chk1:					; ...
		inc	bx
		cmp	ch, dh
		jz	short ChkOtherHand
		mov	ah, 3Eh
		call	int21h		; close	stdout
		mov	[ds:19h], ch	; [PDB.JFN_TABLE+1] ; restore stdout

ChkOtherHand:				; ...
		add	bx, 4		; skip handles 2,3,4
		mov	cx, 0Fh		; FILPERPROC-5 ; 15

CloseLoop:				; ...
		mov	ah, 3Eh
		cmp	[byte ptr bx+18h], 0FFh	; [BX+PDB.JFN_TABLE]
		jz	short CloseLoopNxt
		call	int21h

CloseLoopNxt:				; ...
		inc	bx
		loop	CloseLoop
		cmp	[Append_Flag], 0FFh
		jnz	short Append_Fix_End
		mov	ax, 0B707h	; AppendSetState
		mov	bx, [Append_State]
		int	2Fh		; - Multiplex -	DOS 4.0	APPEND - SET APPEND FUNCTION STATE
					; BX = APPEND state bits
		mov	[Append_Flag], 0

Append_Fix_End:				; ...
		retn
endp		HeadFix


; =============== S U B	R O U T	I N E =======================================


proc		SavHand	near		; ...
		push	bx		; save current program's stdin/out & set to our stderr
		push	ax
		push	es
		push	ds
		mov	ah, 51h		; GET_CURRENT_PDB
		call	int21h
		mov	ds, bx
		lds	bx, [ds:34h]	; [PDB.JFN_Pointer]
		mov	ax, [bx]
		pop	es
		push	es
		mov	[es:Handle01], ax
		mov	al, [es:1Ah]	; [es:PDB.JFN_TABLE+2] ; AL = COMMAND stderr
		mov	ah, al
		mov	[bx], ax	; set user's stdin/out to our stderr
		pop	ds
		pop	es
		pop	ax
		pop	bx
		retn
endp		SavHand

; ---------------------------------------------------------------------------

GetComDsk2:				; ...
		call	GetComDsk
		jmp	LodCom1

; =============== S U B	R O U T	I N E =======================================


proc		RestHand near		; ...
		push	ds		; restore stdin, stdout	to user
		push	bx
		push	ax
		mov	ah, 51h		; GET_CURRENT_PDB
		call	int21h
		mov	ax, [Handle01]
		mov	ds, bx
		lds	bx, [ds:34h]	; [PDB.JFN_Pointer]
		mov	[bx], ax
		pop	ax
		pop	bx
		pop	ds
		retn
endp		RestHand

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR GetComDsk

Hopeless:				; ...
		mov	dx, offset COMBAD
		jmp	FatalC
; END OF FUNCTION CHUNK	FOR GetComDsk

; =============== S U B	R O U T	I N E =======================================


proc		GetComDsk near		; ...

; FUNCTION CHUNK AT 0F15 SIZE 0000006B BYTES
; FUNCTION CHUNK AT 1170 SIZE 00000006 BYTES

		mov	al, [ComDrv]
		call	RemCheck
		jnz	short Hopeless	; non-removable	media
		cmp	dx, offset COMBAD
		jnz	short GetComDsk4
		mov	dx, offset COMBAD
		call	RPrint

GetComDsk4:				; ...
		cmp	[PutBackDrv], 0
		jnz	short Users_Drive
		mov	ah, 19h		; GET_DEFAULT_DRIVE
		call	int21h
		add	al, 41h	; 'A'
		mov	[PutBackDrv], al

Users_Drive:				; ...
		mov	dx, offset PUTBACKMSG
		mov	si, offset PutBackSubst
		call	RPrint
		mov	dx, offset PROMPT
		call	RPrint
		call	GetRawFlushedByte
		retn
endp		GetComDsk


; =============== S U B	R O U T	I N E =======================================


proc		GetRawFlushedByte near	; ...
		mov	ax, 0C07h	; (STD_CON_INPUT_FLUSH<<8) | RAW_CON_INPUT
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		mov	ax, 0C00h	; (STD_CON_INPUT_FLUSH<<8) + 0
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.

LoadCom_retn:				; ...
		retn
endp		GetRawFlushedByte


; =============== S U B	R O U T	I N E =======================================


proc		LoadCom	near		; ...
		inc	bp
		mov	dx, offset ComSpec
		mov	ax, 3D20h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read, 1 -	write, 2 - read	& write
		jnb	short ReadCom
		cmp	al, 4		; ERROR_TOO_MANY_OPEN_FILES
		jnz	short TryDoOpen
		mov	dx, offset NOHANDMES
		jmp	FatalC
; ---------------------------------------------------------------------------

TryDoOpen:				; ...
		call	GetComDsk
		jmp	short LoadCom
; ---------------------------------------------------------------------------

ReadCom:				; ...
		mov	bx, ax
		mov	dx, 2890h	; TRANSTART
		xor	cx, cx
		mov	ax, 4200h
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		jb	short WrongCom1
		mov	cx, 0A99Ah
		push	ds
		mov	ds, [TrnSeg]
		mov	dx, 100h
		mov	ah, 3Fh
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		pop	ds

WrongCom1:				; ...
		pushf
		push	ax
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		pop	ax
		popf
		jb	short WrongCom
		cmp	ax, cx
		jz	short LoadCom_retn
endp		LoadCom


; =============== S U B	R O U T	I N E =======================================


proc		WrongCom near		; ...
		mov	dx, offset COMBAD
		call	GetComDsk
		jmp	short LoadCom	; try again
endp		WrongCom


; =============== S U B	R O U T	I N E =======================================


proc		ChkSum near		; ...
		push	ds
		mov	ds, [TrnSeg]
		mov	si, 100h
		mov	cx, 9B47h	; TRANDATAEND-100h
		cld
		shr	cx, 1
		xor	dx, dx
		mov	[ds:msg_disp_class], 0FFh
		mov	[ds:extend_buf_ptr], dx	; 0
		mov	[ds:extend_buf_sub], dl

Chk:					; ...
		lodsw
		add	dx, ax
		adc	dx, 0
		loop	Chk
		pop	ds
		retn
endp		ChkSum


; =============== S U B	R O U T	I N E =======================================


proc		chk_transient near	; ...
		push	ds		; check	transient portion is valid or not
		mov	ds, [TrnSeg]
		cmp	[word ptr ds:TCOMMAND],	9090h
		pop	ds
		retn
endp		chk_transient


; =============== S U B	R O U T	I N E =======================================


proc		SetVect	near		; ...
		mov	dx, offset LodCom_Trap
		mov	[ds:0Ah], dx	; [PDB.EXIT]
		mov	[word ptr ds:0Ch], ds ;	[PDB.EXIT+2]
		push	es
		push	bx
		xor	bx, bx
		mov	es, bx
		assume es:RESGROUP
		mov	bl, 88h		; INT 22h vector
		cli
		mov	[es:bx], dx
		mov	[word ptr es:bx+2], ds
		mov	dx, offset Ctrlc_Trap
		mov	bl, 8Ch		; INT 23h vector
		mov	[es:bx], dx
		mov	[word ptr es:bx+2], ds
		mov	dx, offset CritErr_Trap
		mov	bl, 90h		; INT 24h vector
		mov	[es:bx], dx
		mov	[word ptr es:bx+2], ds
		sti
		pop	bx
		pop	es
		assume es:nothing
		retn
endp		SetVect


; =============== S U B	R O U T	I N E =======================================


proc		int21h near		; ...
		push	es
		push	bx
		xor	bx, bx
		mov	es, bx		; 0
		assume es:RESGROUP
		pop	bx
		pushf			; Int 21h simulation (ES=0)
		cli
		call	[dword ptr es:84h] ; call far [es:84h]
					; INT 21h handler
		pop	es
		assume es:nothing
		retn
endp		int21h

; ---------------------------------------------------------------------------
		pop	ds
		add	sp, 2
		jmp	LodCom1

; =============== S U B	R O U T	I N E =======================================


proc		AskEnd near		; ...
		mov	dx, offset ENDBATMES
		call	RPrint
		mov	ax, 0C01h	; (STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		call	CharToUpper
		cmp	al, [NO_CHAR]
		jz	short aeRet
		cmp	al, [YES_CHAR]
		jnz	short AskEnd
		stc

aeRet:					; ...
		retn
endp		AskEnd

; ---------------------------------------------------------------------------

DSKERR:					; ...
		pop	ds
		pop	[RStack]	; pop word [OldDS]
		sti
		push	es
		push	si
		push	cx
		push	di
		push	cx
		push	ax
		push	ds
		pop	es
		assume es:RESGROUP
		mov	ds, bp
		mov	ax, [si+4]	; [si+SYSDEV.ATT]
		mov	[es:CDevAt], ah
		mov	di, offset DevName
		mov	cx, 8
		add	si, 10		; SYSDEV.NAME
		cld
		rep movsb
		pop	ax
		pop	cx
		pop	di
		push	es
		pop	ds
		call	SavHand
		push	dx
		call	crlf
		pop	dx
		mov	[Crit_Err_Info], ah
		add	al, 41h	; 'A'
		mov	[DrvLet], al
		test	ah, 80h
		jz	short NoHardE
		test	[CDevAt], 80h
		jnz	short NoHardE
		jmp	FatErr
; ---------------------------------------------------------------------------

NoHardE:				; ...
		mov	si, offset MREAD
		test	ah, 1
		jz	short SavMes
		mov	si, offset MWRITE

SavMes:					; ...
		mov	[OldErrNo], di
		push	es
		push	cx
		push	bx
		mov	ah, 59h
		int	21h		; DOS -	3+ - GET EXTENDED ERROR	CODE
					; BX = version code (0000h for DOS 3.x)
		pop	bx
		pop	cx
		mov	[word ptr NeedVol], di
		mov	[word ptr NeedVol+2], es
		pop	es
		assume es:nothing
		mov	di, ax
		sub	di, 13h		; ERROR_WRITE_PROTECT
		jnb	short HavCod
		mov	di, 0Ch		; ERROR_GEN_FAILURE - ERROR_WRITE_PROTECT

HavCod:					; ...
		mov	[ErrType], 0
		cmp	di, 10h		; ERROR_FCB_UNAVAILABLE	- ERROR_WRITE_PROTECT
		jz	short SetStyle
		cmp	di, 11h		; ERROR_SHARING_BUFFER_EXCEEDED	- ERROR_WRITE_PROTECT
		jnz	short GotStyle

SetStyle:				; ...
		mov	[ErrType], 1

GotStyle:				; ...
		mov	[ErrCd_24], di
		cmp	di, 14h		; ERROR_HANDLE_DISK_FULL - ERROR_WRITE_PROTECT
		jbe	short NormalError
		mov	di, ax
		mov	ax, 500h	; is the redir there?
		int	2Fh		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
					; Return: AL = 00h not installed, OK to	install
					; 01h not installed, can't install
					; FFh installed
		cmp	al, 0FFh
		jnz	short NoHandler	; no, go to NoHandler
		push	bx
		mov	bx, di		; get ErrType and ptr to error msg
		mov	ax, 501h
		int	2Fh		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
		pop	bx
		jb	short NoHandler
		mov	[ErrType], al
		push	ds
		push	es
		pop	ds
		mov	dx, di
		mov	cx, 0FFFFh	; find end of msg
		xor	al, al
		cld
		repne scasb
		mov	[byte ptr di-1], 24h ; '$'
		mov	ah, 9		; STD_CON_STRING_OUTPUT	; print	the message
		int	21h		; DOS -	PRINT STRING
					; DS:DX	-> string terminated by	"$"
		mov	[byte ptr di-1], 0 ; restore terminal byte
		pop	ds
		jmp	short CheckErrType
; ---------------------------------------------------------------------------

NoHandler:				; ...
		mov	[ErrType], 0
		mov	di, [OldErrNo]
		mov	[ErrCd_24], di

NormalError:				; ...
		add	di, 13h		; ERROR_WRITE_PROTECT
		xchg	di, dx
		call	RPrintCrit

CheckErrType:				; ...
		cmp	[ErrType], 0
		jz	short ContOld
		call	crlf
		jmp	short Ask
; ---------------------------------------------------------------------------

ContOld:				; ...
		inc	si
		test	[CDevAt], 80h	; DEVTYP>>8
		jz	short BlkErr
		mov	dx, offset MDEVICE
		mov	[CharDevErrRw],	si
		mov	si, offset CharDevErrSubst
		call	RPrint
		jmp	short Ask
; ---------------------------------------------------------------------------

BlkErr:					; ...
		mov	dx, offset MDRIVE
		mov	[BlkDevErrRw], si
		mov	si, offset BlkDevErrSubst
		call	RPrint
		cmp	[Loading], 0
		jz	short Ask
		call	RestHand
		jmp	GetComDsk2
; ---------------------------------------------------------------------------

Ask:					; ...
		cmp	[ErrCd_24], 0Fh
		jnz	short Not15
		push	cx
		push	ds
		pop	es
		assume es:RESGROUP
		lds	si, [NeedVol]
		push	di
		mov	di, offset VolName
		mov	cx, 16
		cld
		rep movsb
		pop	di
		push	es
		pop	ds
		pop	cx
		mov	dx, offset MVOLSERIAL
		mov	si, offset NeedVolSubst
		call	RPrint

Not15:					; ...
		mov	dx, offset REQ_ABORT
		call	RPrint
		test	[Crit_Err_Info], 10h ; RETRY_ALLOWED
		jz	short Try_Ignore
		mov	dx, offset REQ_RETRY
		call	RPrint

Try_Ignore:				; ...
		test	[Crit_Err_Info], 20h ; IGNORE_ALLOWED
		jz	short Try_Fail
		mov	dx, offset REQ_IGNORE
		call	RPrint

Try_Fail:				; ...
		test	[Crit_Err_Info], 8 ; FAIL_ALLOWED
		jz	short Term_Question
		mov	dx, offset REQ_FAIL
		call	RPrint

Term_Question:				; ...
		mov	dx, offset REQ_END
		call	RPrint
		test	[fFail], 0FFh	; -1
		jz	short DoPrompt
		mov	ah, 3
		jmp	EExit
; ---------------------------------------------------------------------------

DoPrompt:				; ...
		mov	ax, 0C01h	; (STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		call	ITestKanj
		jz	short NotKanj
		mov	ax, 100h
		int	21h		; DOS -	KEYBOARD INPUT
					; Return: AL = character read
		call	crlf
		jmp	short Ask
; ---------------------------------------------------------------------------

NotKanj:				; ...
		call	crlf
		call	CharToUpper
		mov	ah, 0
		test	[Crit_Err_Info], 20h ; IGNORE_ALLOWED
		jz	short User_Retry
		cmp	al, [IGNORE_CHAR]
		jz	short EExitJ

User_Retry:				; ...
		inc	ah
		test	[Crit_Err_Info], 10h ; RETRY_ALLOWED
		jz	short User_Abort
		cmp	al, [RETRY_CHAR]
		jz	short EExitJ

User_Abort:				; ...
		inc	ah
		cmp	al, [ABORT_CHAR]
		jz	short Abort_Process
		inc	ah
		test	[Crit_Err_Info], 8 ; FAIL_ALLOWED
		jz	short AskJ
		cmp	al, [FAIL_CHAR]
		jz	short EExitJ

AskJ:					; ...
		jmp	Ask
; ---------------------------------------------------------------------------

EExitJ:					; ...
		jmp	short EExit
; ---------------------------------------------------------------------------

Abort_Process:				; ...
		test	[InitFlag], 1	; INITINIT
		jz	short AbortCont
		cmp	[PermCom], 0
		jz	short JustExit
		mov	dx, offset PATRICIDE
		call	RPrint

DeadInTheWater:				; ...
		jmp	short DeadInTheWater
; ---------------------------------------------------------------------------

JustExit:				; ...
		mov	ax, [Parent]
		mov	[ds:16h], ax	; [PDB.PARENT_PID]
		mov	ax, 4CFFh	; (EXIT<<8) | 255
		int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
					; AL = exit code
; ---------------------------------------------------------------------------

AbortCont:				; ...
		test	[In_Batch], 0FFh ; -1
		jz	short Not_Batch_Abort
		mov	[Batch_Abort], 1

Not_Batch_Abort:			; ...
		mov	dl, [PipeFlag]
		call	ResPipeOff
		or	dl, dl
		jz	short CheckForA
		cmp	[SingleCom], 0	; word
		jz	short CheckForA
		mov	[SingleCom], 0FFFFh ; -1

CheckForA:				; ...
		cmp	[ErrCd_24], 0	; word ; write protect?
		jz	short abortfor
		cmp	[ErrCd_24], 2	; drive	not ready?
		jnz	short EExit	; don't abort the FOR

abortfor:				; ...
		mov	[ForFlag], 0	; abort	a FOR in progress
		cmp	[SingleCom], 0
		jz	short EExit
		mov	[SingleCom], 0FFFFh ; -1

EExit:					; ...
		mov	al, ah
		mov	dx, di

RestHd:					; ...
		call	RestHand
		pop	cx
		pop	si
		pop	es
		assume es:nothing
		mov	ds, [RStack]	; mov ds,[OldDS]
		iret
; ---------------------------------------------------------------------------

FatErr:					; ...
		mov	dx, offset BADFATMSG
		mov	si, offset BadFatSubst
		call	RPrint
		mov	al, 2		; abort
		jmp	short RestHd

; =============== S U B	R O U T	I N E =======================================


proc		crlf near		; ...
		mov	dx, offset NEWLINE
endp		crlf


; =============== S U B	R O U T	I N E =======================================


proc		RPrint near		; ...
		push	si
		push	ax
		push	bx
		push	cx
		push	dx
		mov	bx, si
		mov	si, dx
		lodsb
		xor	cx, cx
		mov	cl, al
		jcxz	short rpRet
		call	RDispMsg

rpRet:					; ...
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		pop	si
		retn
endp		RPrint


; =============== S U B	R O U T	I N E =======================================


proc		RPrintCrit near		; ...
		push	dx
		xchg	bx, dx
		sub	bx, 19
		shl	bx, 1
		mov	bx, [CRITMSGPTRS+bx]
		xchg	bx, dx
		call	RPrint
		pop	dx
		retn
endp		RPrintCrit


; =============== S U B	R O U T	I N E =======================================


proc		RDispMsg near		; ...
		lodsb
		cmp	al, '%'         ; 25h
		jnz	short rdOutChar	; not a	substitution
		mov	dl, [si]
		sub	dl, '1'
		cmp	dl, 9
		jnb	short rdOutChar	; not a	substitution
		call	SubstMsg
		inc	si
		dec	cx
		jmp	short rdCharDone
; ---------------------------------------------------------------------------

rdOutChar:				; ...
		mov	dl, al
		mov	ah, 2
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output

rdCharDone:				; ...
		loop	RDispMsg
		retn
endp		RDispMsg


; =============== S U B	R O U T	I N E =======================================


proc		SubstMsg near		; ...
		push	bx
		push	cx
		mov	al, 3
		mul	dl
		add	bx, ax
		mov	al, [bx]	; [bx].SubstType
		mov	bx, [bx+1]	; [bx].SubstPtr
		dec	al
		jz	short smChar
		dec	al
		jz	short smStr
		mov	ax, [bx]
		mov	cx, 4

smDigit:				; ...
		rol	ax, 1
		rol	ax, 1
		rol	ax, 1
		rol	ax, 1
		push	ax
		and	al, 0Fh
		add	al, 30h	; '0'
		cmp	al, 39h	; '9'
		jbe	short smDigit09
		add	al, 7		; ('A' - '0') - 10

smDigit09:				; ...
		mov	dl, al
		mov	ah, 2
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		pop	ax
		loop	smDigit
		jmp	short smRet
; ---------------------------------------------------------------------------

smChar:					; ...
		mov	dl, [bx]
		mov	ah, 2
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		jmp	short smRet
; ---------------------------------------------------------------------------

smStr:					; ...
		mov	dl, [bx]
		or	dl, dl
		jz	short smRet
		mov	ah, 2
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		inc	bx
		jmp	short smStr
; ---------------------------------------------------------------------------

smRet:					; ...
		pop	cx
		pop	bx
		retn
endp		SubstMsg


; =============== S U B	R O U T	I N E =======================================


proc		CharToUpper near	; ...
		push	ax
		mov	ax, 1213h
		int	2Fh		; Multiplex - DOS 3+ internal -	UPPERCASE CHARACTER
					; STACK: WORD character	to convert to uppercase
					; Return: AL = uppercase character
					; STACK	unchanged
		inc	sp
		inc	sp
		retn
endp		CharToUpper


; =============== S U B	R O U T	I N E =======================================


proc		ITestKanj near		; ...
		push	ds
		push	si
		push	ax
		lds	si, [Dbcs_Vector_Addr]

ktLop:					; ...
		cmp	[word ptr si], 0
		jz	short NotLead
		pop	ax
		push	ax
		cmp	al, [si]
		jb	short NotLead
		inc	si
		cmp	al, [si]
		jbe	short IsLead
		inc	si
		jmp	short ktLop
; ---------------------------------------------------------------------------

NotLead:				; ...
		xor	ax, ax
		jmp	short ktRet
; ---------------------------------------------------------------------------

IsLead:					; ...
		xor	ax, ax
		inc	ax

ktRet:					; ...
		pop	ax
		pop	si
		pop	ds
		retn
endp		ITestKanj

; ---------------------------------------------------------------------------

MsgInt2fHandler:			; ...
		pop	ds
		cmp	ax, 122Eh	; (MULTDOS<<8)|MESSAGE_2F
		jz	short miOurs
		cmp	ax, 5500h	; GET_COMMAND_STATE
		jz	short fcOurs
		push	ax
		push	ax
		push	bp
		push	ax
		mov	bp, sp
		mov	ax, [bp+8]
		mov	[bp+4],	ax
		mov	ax, [Int2fHandler+2]
		mov	[bp+8],	ax
		mov	ax, [Int2fHandler]
		mov	[bp+6],	ax
		pop	ax
		pop	bp
		pop	ds
		retf
; ---------------------------------------------------------------------------

fcOurs:					; ...
		pop	ax
		push	ds
		mov	si, offset Int2f_Entry
		xor	ax, ax
		jmp	short miRet
; ---------------------------------------------------------------------------

miOurs:					; ...
		test	dl, 1
		jnz	short miRet
		push	bx
		mov	bx, dx
		xor	bh, bh
		shl	bx, 1
		les	di, [MsgPtrLists+bx]
		pop	bx

miRet:					; ...
		pop	ds
		iret
; ---------------------------------------------------------------------------

MsgRetriever:
		pop	ds
		push	ax
		push	bx
		push	cx
		push	dx
		push	si
		push	ds
		pop	es
		assume es:RESGROUP
		mov	bx, 11		; NUMPARSMSGS
		cmp	di, offset PARSMSGPTRS ; DATARES:ParsMsgPtrs
		jz	short chkmsgnum
		mov	bx, 90		; NUMEXTMSGS

chkmsgnum:				; ...
		cmp	bx, ax
		jb	short mrRet
		dec	ax
		shl	ax, 1
		add	di, ax
		cmp	di, [ResMsgEnd]
		jb	short mrInMem
		mov	si, offset ComSpec ; DATARES:ComSpec
		mov	dx, 1
		mov	bx, 2000h	; INT_24_ERROR
		mov	ax, 6C00h	; ExtOpen shl 8
		int	21h		; DOS -	4.0 - EXTENDED OPEN/CREATE
					; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
					; BH = flags, CX = create attribute, DL	= action if file exists/does not exists
					; DH = 00h (reserved), DS:SI ->	ASCIZ file name
		jb	short mrRet
		mov	bx, ax
		mov	dx, di
		xor	si, si

mrRead:					; ...
		sub	dx, 100h
		xor	cx, cx
		mov	ax, 4200h
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		jb	short mrCloseFile
		mov	dx, offset MsgBuffer
		mov	cx, 64
		mov	ah, 3Fh		; READ
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		jb	short mrCloseFile
		or	si, si
		jnz	short mrCloseFile
		inc	si
		mov	dx, [word ptr MsgBuffer]
		or	dx, dx
		jnz	short mrRead
		stc

mrCloseFile:				; ...
		pushf
		mov	ah, 3Eh		; CLOSE
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		popf
		mov	di, dx
		jmp	short mrRet
; ---------------------------------------------------------------------------

mrInMem:				; ...
		mov	di, [es:di]
		or	di, di
		jnz	short mrRet
		stc

mrRet:					; ...
		pop	si
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		pop	ds
		retf

; =============== S U B	R O U T	I N E =======================================


proc		Lh_OffUnlink far
		mov	ch, al
		mov	cl, al
		mov	ax, 5800h	; (ALLOCOPER<<8)
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: get allocation strategy
		mov	bx, ax
		ror	cl, 1
		and	cl, 80h
		and	bl, 7Fh
		or	bl, cl
		mov	ax, 5801h	; (ALLOCOPER<<8)|1
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		mov	bl, ch
		shr	bl, 1
		xor	bh, bh
		mov	ax, 5803h	; (ALLOCOPER<<8)|3
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) set UMB link state
		retf
endp		Lh_OffUnlink

; ---------------------------------------------------------------------------
CODERES_ends	db 12 dup(0)		; times	(((EndCode+15)>>4)<<4)-EndCode db 0
; ---------------------------------------------------------------------------

ConProc:				; ...
		mov	sp, offset RStack ; 637h
		mov	ah, 50h
		mov	bx, es
		int	21h		; DOS -	2+ internal - SET PSP SEGMENT
					; BX = segment address of new PSP
		mov	ax, 3000h
		int	21h		; DOS -	GET DOS	VERSION
					; Return: AL = major version number (00h for DOS 1.x)
		cmp	ax, 0A07h	; EXPECTED_VERSION
		jz	short okdos
		mov	dx, offset BADVERMSG
		call	RPrint
		mov	ax, es
		cmp	[es:16h], ax	; PDB_Parent_Pid

Here:					; ...
		jz	short Here
		int	20h		; DOS -	PROGRAM	TERMINATION
					; returns to DOS--identical to INT 21/AH=00h
; ---------------------------------------------------------------------------

okdos:					; ...
		mov	dx, 289Fh	; TranStart+15
		mov	cl, 4
		shr	dx, cl
		mov	ax, cs
		add	ax, dx
		mov	[InitEnd], ax
		call	CheckHelp
		call	patch_segs
		mov	ax, 0B700h	; APPENDINSTALL
		int	2Fh		; - Multiplex -	APPEND - INSTALLATION CHECK
					; Return: AL = 00h not installed
					; AL = FFh if installed
		cmp	al, 0
		jz	short set_msg_addr
		mov	ax, 0B702h	; APPENDDOS
		int	2Fh		; - Multiplex -	APPEND - VERSION CHECK
					; Return: AX = FFFFh if	not DOS	4.0 APPEND
					; AL = major version number
					; AH = minor version number, otherwise
		cmp	ax, 0FFFFh
		jnz	short set_msg_addr
		mov	ax, 0B706h	; APPENDGETSTATE
		int	2Fh		; - Multiplex -	DOS 4.0	APPEND - GET APPEND FUNCTION STATE
					; Return: BX = APPEND state
		mov	[Append_State],	bx
		xor	bx, bx
		mov	ax, 0B707h	; APPENDSETSTATE
		int	2Fh		; - Multiplex -	DOS 4.0	APPEND - SET APPEND FUNCTION STATE
					; BX = APPEND state bits

set_msg_addr:				; ...
		mov	di, offset PAERRMSG0 ; DataresEnd
		mov	[ResMsgEnd], di
		call	get_XMMAddr
		mov	ax, 5500h	; GET_COMMAND_STATE
		int	2Fh		; Return:
					; AX = 0000h if	an instance of COMMAND.COM is already running
					; DS:SI	-> entry point table
		or	ax, ax
		jnz	short first_com
		mov	[word ptr es:ResJmpTable], si
		mov	[word ptr es:ResJmpTable+2], ds
		jmp	short init_cntry
; ---------------------------------------------------------------------------

first_com:				; ...
		mov	[es:FirstCom], 1

init_cntry:				; ...
		push	es
		pop	ds
		mov	ah, 65h		; GETEXTCNTRY
		mov	al, 4
		mov	dx, 0FFFFh
		mov	bx, 0FFFFh
		mov	cx, 5
		mov	di, offset FUCase_Addr
		int	21h		; DOS -	2+ internal - CREATE PSP
					; DX = segment number at which to set up PSP
					; SI = (DOS 3+)	value to place in memory size field at DX:[0002h]
		push	ds
		mov	ax, 6300h	; (ECS_CALL shl	8) or GETLEADBTBL
		int	21h		; DOS -	3.2+ only - GET	DOUBLE BYTE CHARACTER SET LEAD TABLE
		mov	bx, ds
		pop	ds
		mov	[word ptr Dbcs_Vector_Addr], si
		mov	[word ptr Dbcs_Vector_Addr+2], bx
		mov	ax, [ds:16h]	; [PDB.PARENT_PID]
		mov	[Parent], ax
		mov	ax, [ds:0Ah]	; [PDB.EXIT]
		mov	[word ptr OldTerm], ax
		mov	ax, [ds:0Ch]	; [PDB.EXIT+2]
		mov	[word ptr OldTerm+2], ax
		mov	ax, 16B3h	; ResGroup:EndCode + 15
		mov	cl, 4
		shr	ax, cl
		mov	cx, cs
		add	ax, cx
		mov	[Res_Tpa], ax
		and	ax, 0F000h
		add	ax, 1000h
		jnb	short TpaSet
		mov	ax, [Res_Tpa]

TpaSet:					; ...
		mov	[Ltpa],	ax
		mov	ax, [ds:2]	; [PDB.BLOCK_LEN]
		mov	[MySeg1], ds
		mov	[MySeg2], ds
		mov	[MySeg], ds
		mov	[MySeg3], ds
		mov	[MemSiz], ax
		push	ax
		mov	bx, 2890h	; RESGROUP:TranStart
		add	bx, 0AA9Ah	; TRANGROUP:TranSpaceEnd
		add	bx, 0Fh
		mov	cl, 4
		shr	bx, cl		; (TRANSTART+TRANSPACEEND+15)>>4
		mov	ah, 4Ah		; SETBLOCK
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs
		pop	ax
		mov	[EnvMax], 95	; ((ENVIRONSIZ+15)/16) + ((EnvMaximum-ZERO+15)/16) - 1
					; ZERO equ ConProc
					; ((166+15+)/16)+(1BF5h-16B0h+15)/16)-1	= 95
		mov	[EnvSiz], 16
		mov	dx, 0AAA9h	; (TRANSPACEEND+15)
		mov	cl, 4
		shr	dx, cl		; (TRANSPACEEND+15)>>4
		mov	[TrnSize], dx
		sub	ax, dx
		mov	[TrnSeg], ax
		mov	ax, [ds:2Ch]	; [PDB.ENVIRON]
		mov	[EnvirSeg], ax
		mov	[ds:7Eh], ax	; environment segment
		or	ax, ax
		jz	short buildenv
		cmp	[FirstCom], 0
		jz	short environpassed

buildenv:				; ...
		call	alloc_env

environpassed:				; ...
		mov	es, ax
		assume es:nothing
		mov	ah, 19h
		int	21h		; DOS -	GET DEFAULT DISK NUMBER
		inc	al
		mov	[ComDrv], al
		mov	al, [ds:5Ch]	; [FCB]
		or	al, al
		jz	short nocomdrv
		mov	ah, 3Ah	; ':'
		mov	[ComDrv], al
		add	al, 40h	; '@'
		std
		cmp	[AllocedEnv], 0
		jz	short notwidenv
		mov	di, [ComspOffset]
		cmp	[byte ptr es:di+1], 3Ah	; ':'
		jz	short notwidenv
		push	ds
		push	es
		pop	ds
		lea	si, [di+143]	; [di+MAX_COMSPEC-3]
		lea	di, [di+145]	; [di+MAX_COMSPEC-1]
		mov	cx, 144		; MAX_COMSPEC-2
		rep movsb
		pop	ds
		mov	[es:di-1], ax

notwidenv:				; ...
		cld
		mov	[word ptr AUTOBAT], ax

nocomdrv:				; ...
		call	SetVect
		push	cs
		push	cs
		pop	ds
		pop	es
		mov	si, 80h
		lodsb
		mov	di, si
		xor	ah, ah
		add	di, ax
		mov	[byte ptr di], 0Dh
		xor	cx, cx
		mov	[num_positionals], cx

Parse_command_line:			; ...
		mov	di, offset PARSE_COMMAND
		mov	cx, [num_positionals]
		xor	dx, dx
		mov	[old_parse_ptr], si
		call	[dword ptr Init_Parse] ; call far [Init_Parse]
		mov	[num_positionals], cx
		cmp	ax, 0FFFFh
		jnz	short t1
		jmp	ArgsDone
; ---------------------------------------------------------------------------

t1:					; ...
		cmp	ax, 0
		jz	short parse_cont

parse_line_error:			; ...
		push	si
		push	ax
		cmp	ax, 3		; BadSwt_Ptr
		jnz	short parse_line_error_disp
		mov	di, si
		mov	si, [old_parse_ptr]

init_chk_delim:				; ...
		cmp	si, di
		jz	short parse_line_error_disp
		lodsb
		cmp	al, [space_chr]
		jz	short init_chk_delim
		cmp	al, 9
		jz	short init_chk_delim
		cmp	al, [RSwitChar]
		jnz	short parse_line_error_disp
		lodsb
		call	ITestKanj
		jnz	short parse_line_error_disp
		call	iupconv
		cmp	al, [scswitch]
		jnz	short check_k_too
		pop	dx
		pop	dx
		jmp	SetSSwitch
; ---------------------------------------------------------------------------

check_k_too:				; ...
		cmp	al, [skswitch]
		jnz	short parse_line_error_disp
		pop	dx
		pop	dx
		jmp	SetKSwitch
; ---------------------------------------------------------------------------

parse_line_error_disp:			; ...
		pop	ax
		pop	si
		mov	dx, ax
		call	RPrintParse
		call	crlf
		jmp	short Parse_command_line
; ---------------------------------------------------------------------------

parse_cont:				; ...
		cmp	[COMND1_SYN], offset COMMAND_F_SYN ; "/F"
		jz	short SetFSwitch
		cmp	[COMND1_SYN], offset COMMAND_P_SYN ; "/P"
		jz	short SetPSwitch
		cmp	[COMND1_SYN], offset COMMAND_D_SYN ; "/D"
		jnz	short parse_cont_1
		jmp	SetDSwitch
; ---------------------------------------------------------------------------

parse_cont_1:				; ...
		cmp	[COMND1_SYN], offset COMMAND_C_SYN ; "/C"
		jnz	short parse_cont_2
		jmp	SetSSwitch
; ---------------------------------------------------------------------------

parse_cont_2:				; ...
		cmp	[COMND1_SYN], offset COMMAND_K_SYN ; "/K"
		jnz	short parse_cont_3
		jmp	SetKSwitch
; ---------------------------------------------------------------------------

parse_cont_3:				; ...
		cmp	[COMND1_SYN], offset COMMAND_E_SYN ; "/E"
		jnz	short parse_cont_4
		jmp	SetESwitch
; ---------------------------------------------------------------------------

parse_cont_4:				; ...
		cmp	[COMND1_SYN], offset COMMAND_Y_SYN ; "/Y"
		jnz	short parse_cont_5
		jmp	SetYSwitch
; ---------------------------------------------------------------------------

parse_cont_5:				; ...
		cmp	[COMND1_SYN], offset COMMAND_M_SYN ; "/MSG"
		jz	short SetMSwitchJ
		cmp	[COMND1_SYN], offset COMMAND_H_SYN ; "/H"
		jz	short SetHSwitch
		cmp	[COMND1_SYN], offset COMMAND_O_SYN ; "/O"
		jz	short SetOSwitch
		jmp	ChkOtherArgs
; ---------------------------------------------------------------------------

SetMSwitchJ:				; ...
		jmp	SetMSwitch
; ---------------------------------------------------------------------------

SetHSwitch:				; ...
		jmp	load_to_hma_umb
; ---------------------------------------------------------------------------

SetOSwitch:				; ...
		jmp	disable_overwrite_msg
; ---------------------------------------------------------------------------

SetFSwitch:				; ...
		cmp	[fFail], 0FFh	; -1
		jnz	short failok
		mov	ax, 1		; MoreArgs_Ptr
		jmp	parse_line_error
; ---------------------------------------------------------------------------

failok:					; ...
		mov	[fFail], 0FFh
		jmp	Parse_command_line
; ---------------------------------------------------------------------------

SetPSwitch:				; ...
		cmp	[PermCom], 0
		jz	short permcomok
		mov	ax, 1		; MoreArgs_Ptr
		jmp	parse_line_error
; ---------------------------------------------------------------------------

permcomok:				; ...
		inc	[PermCom]	; byte
		mov	[word ptr OldTerm], offset LodCom_Trap
		mov	[word ptr OldTerm+2], ds
		cmp	[PRDATTM], 0FFh	; -1
		jnz	short Parse_command_line_jmp
		mov	[PRDATTM], 0

Parse_command_line_jmp:			; ...
		jmp	Parse_command_line
; ---------------------------------------------------------------------------

SetDSwitch:				; ...
		cmp	[dswitch], 0
		jz	short setdateok
		mov	ax, 1
		jmp	parse_line_error
; ---------------------------------------------------------------------------

setdateok:				; ...
		inc	[dswitch]	; byte
		mov	[PRDATTM], 1	; byte
		jmp	Parse_command_line
; ---------------------------------------------------------------------------

SetKSwitch:				; ...
		mov	[SemiPermCom], 0
		jmp	short SetSorKSwitch
; ---------------------------------------------------------------------------

SetSSwitch:				; ...
		mov	[PermCom], 0

SetSorKSwitch:				; ...
		mov	[SingleCom], si
		mov	[PRDATTM], 1	; byte
		jmp	ArgsDone
; ---------------------------------------------------------------------------

SetESwitch:				; ...
		cmp	[eswitch], 0	; byte
		jz	short eswitchok
		mov	ax, 1
		jmp	parse_line_error
; ---------------------------------------------------------------------------

eswitchok:				; ...
		inc	[eswitch]
		mov	di, offset COMND1_ADDR
		mov	bx, [di]
		add	bx, 0Fh
		mov	cl, 4
		shr	bx, cl
		mov	[EnvSiz], bx
		jmp	Parse_command_line
; ---------------------------------------------------------------------------

SetMSwitch:				; ...
		cmp	[ext_msg], 1
		jnz	short setMswitchok
		mov	ax, 1		; MoreArgs_Ptr
		jmp	parse_line_error
; ---------------------------------------------------------------------------

setMswitchok:				; ...
		mov	[ext_msg], 1
		jmp	Parse_command_line
; ---------------------------------------------------------------------------

SetYSwitch:				; ...
		or	[byte ptr Y_Flag], 10h
		jmp	Parse_command_line
; ---------------------------------------------------------------------------

load_to_hma_umb:			; ...
		cmp	[COMMAND_HIGH],	0
		jz	short set_command_high_flag
		mov	ax, 1		; too many parameters
		jmp	parse_line_error
; ---------------------------------------------------------------------------

set_command_high_flag:			; ...
		inc	[COMMAND_HIGH]	; byte
		jmp	Parse_command_line
; ---------------------------------------------------------------------------

disable_overwrite_msg:			; ...
		cmp	[byte ptr cox_location], 'c' ; "cox"
		jz	short change_cox_to_VCB
		mov	ax, 1
		jmp	parse_line_error
; ---------------------------------------------------------------------------

change_cox_to_VCB:			; ...
		mov	[byte ptr cox_location], 56h ; 'V'  ; "VCB"
		mov	[word ptr cox_location+1], 4243h ; 'CB'
		jmp	Parse_command_line
; ---------------------------------------------------------------------------

ChkOtherArgs:				; ...
		push	ds
		push	si
		lds	si, [COMND1_ADDR]
		mov	dx, si
		mov	ax, 3D02h	; (OPEN	shl 8) or 2
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 2 - read & write
		jb	short ChkSrchSpec
		mov	bx, ax
		mov	ax, 4400h	; IOCTL	shl 8
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		test	dl, 80h
		jnz	short IsaDevice

BadSetCon:				; ...
		mov	ah, 3Eh		; CLOSE
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		jmp	short ChkSrchSpec
; ---------------------------------------------------------------------------

IsaDevice:				; ...
		xor	dh, dh
		or	dl, 3
		mov	ax, 4401h	; (IOCTL shl 8)	or 1
		int	21h		; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
					; BX = device handle, DH = 0
					; DL = device information to set (bits 0-7 from	function 0)
		jb	short BadSetCon
		mov	dx, bx
		cmp	[es:DevFlag], 1
		jz	short DevErr
		push	cx
		mov	cx, 3
		xor	bx, bx

rcclloop:				; ...
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		inc	bx
		loop	rcclloop
		mov	bx, dx
		mov	ah, 45h		; XDUP
		int	21h		; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
					; BX = file handle to duplicate
		mov	ah, 45h
		int	21h		; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
					; BX = file handle to duplicate
		mov	ah, 45h
		int	21h		; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
					; BX = file handle to duplicate
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		pop	cx
		pop	si
		pop	ds
		inc	[es:DevFlag]
		jmp	Parse_command_line
; ---------------------------------------------------------------------------

DevErr:					; ...
		pop	si
		pop	ds
		mov	dx, 1
		call	RPrintParse
		call	crlf
		jmp	Parse_command_line
; ---------------------------------------------------------------------------

ChkSrchSpec:				; ...
		cmp	[es:PathFlag], 1
		jz	short DevErr
		inc	[es:PathFlag]
		call	alloc_env
		mov	es, ax
		push	si
		xor	cx, cx

countloop:				; ...
		lodsb
		inc	cx
		cmp	al, 0		; END_OF_LINE_OUT
		jnz	short countloop
		mov	al, [ss:space_chr]
		dec	si
		mov	[si], al
		push	cx
		mov	cx, 8000h	; ENVBIG
		mov	di, [ss:ComspOffset]
		mov	al, 0
		repne scasb
		mov	si, di

comp_endenv:				; ...
		scasb
		jz	short got_endenv
		repne scasb
		jmp	short comp_endenv
; ---------------------------------------------------------------------------

got_endenv:				; ...
		mov	cx, di
		sub	cx, si
		mov	di, [ss:ComspOffset]
		sub	di, 8		; ComspStrLen
		push	ds
		push	es
		pop	ds
		rep movsb
		dec	di
		push	cs
		pop	ds
		mov	si, offset ComspString ; "COMSPEC=\\COMMAND.COM"
		mov	cx, 8		; ComspStrLen
		rep movsb
		mov	[ComspOffset], di
		pop	ds
		pop	cx
		pop	si

ComtrLoop:				; ...
		lodsb
		dec	cx
		cmp	al, [ss:space_chr]
		jz	short SetComsr
		stosb
		xor	ah, ah
		jcxz	short SetComsr
		push	ds
		push	cs
		pop	ds
		call	ITestKanj
		pop	ds
		jz	short ComtrLoop
		dec	cx
		movsb
		inc	ah
		jcxz	short SetComsr
		jmp	short ComtrLoop
; ---------------------------------------------------------------------------

SetComsr:				; ...
		push	cx
		push	cs
		pop	ds
		push	ds
		mov	si, offset COMSPECT ; "\\COMMAND.COM"
		mov	cx, 14
		mov	al, [es:di-1]
		or	ah, ah
		jnz	short iNotRoot
		cmp	al, [RDirChar]
		jnz	short iNotRoot
		inc	si
		dec	cx

iNotRoot:				; ...
		rep movsb
		mov	dx, [ComspOffset]
		push	es
		pop	ds
		mov	ax, 3D00h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		pop	ds
		jb	short SetComsrBad
		mov	bx, ax
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle

SetComsrRet:				; ...
		pop	cx
		pop	si
		pop	ds
		push	cs
		pop	es
		assume es:RESGROUP
		jmp	Parse_command_line
; ---------------------------------------------------------------------------

SetComsrBad:				; ...
		mov	dx, offset BADCOMLKMES
		call	5A6Ch		; TRIAGEERROR equ TRANSTART+TriageError
					; call TRIAGEERROR ; TRANSTART+31DCh
		cmp	ax, 65
		jnz	short doprt
		mov	dx, offset BADCOMACCMSG

doprt:					; ...
		call	RPrint
		mov	si, offset COMSPECT ; "\\COMMAND.COM"
		mov	di, [ComspOffset]
		mov	cx, 14
		rep movsb
		jmp	short SetComsrRet
; ---------------------------------------------------------------------------

ArgsDone:				; ...
		mov	es, [EnvirSeg]
		assume es:nothing
		cmp	[PermCom], 0
		jz	short ComReturns
		push	es
		mov	ah, 50h		; SET_CURRENT_PDB
		mov	bx, ds
		mov	es, bx
		assume es:RESGROUP
		int	21h		; DOS -	2+ internal - SET PSP SEGMENT
					; BX = segment address of new PSP
		mov	di, 0Ah		; PDB.EXIT
		mov	ax, offset LodCom_Trap
		stosw
		mov	ax, ds
		stosw
		mov	ax, offset Ctrlc_Trap
		stosw
		mov	ax, ds
		stosw
		mov	ax, offset CritErr_Trap
		stosw
		mov	ax, ds
		stosw
		mov	[word ptr ds:16h], ds ;	[PDB.PARENT_PID]
		mov	dx, offset Int2e_Trap
		mov	ax, 252Eh	; (SET_INTERRUPT_VECTOR	SHL 8) OR 2Eh
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		pop	es
		assume es:nothing

ComReturns:				; ...
		mov	ax, [ds:16h]	; [PDB.PARENT_PID]
		mov	[Parent], ax
		mov	[word ptr ds:16h], ds ;	[PDB.PARENT_PID]
		mov	ax, [ds:18h]	; [PDB.JFN_TABLE]
		mov	[Io_Save], ax
		mov	[Com_Ptr+2], ds
		mov	[Com_Fcb1+2], ds
		mov	[Com_Fcb2+2], ds
		mov	di, offset ComSpec
		mov	si, [ComspOffset]
		cmp	[AllocedEnv], 0
		mov	ax, ds
		push	es
		pop	ds
		mov	es, ax
		assume es:RESGROUP
		jnz	short CopyComsp
		push	cs
		pop	ds
		mov	si, offset ComspString ; "COMSPEC=\\COMMAND.COM"
		push	es
		push	di
		call	IfindE
		mov	si, di
		push	es
		pop	ds
		pop	di
		pop	es
		assume es:nothing
		jnb	short CopyComsp
		mov	si, offset ComspString ; "COMSPEC=\\COMMAND.COM"
		add	si, 8		; ComspString+ComspStrLen
		push	cs
		pop	ds

CopyComsp:				; ...
		mov	[es:PutBackComSpec], di
		cmp	[byte ptr si+1], ':'
		jnz	short CopyComspLoop
		add	[es:PutBackComSpec], 2

CopyComspLoop:				; ...
		lodsb
		stosb
		or	al, al
		jnz	short CopyComspLoop
		mov	[es:ComSpec_End], di
		dec	[es:ComSpec_End]
		mov	ah, [es:ComDrv]
		add	ah, 40h	; '@'   ; 'A'-1
		mov	[es:PutBackDrv], ah
		call	setup_for_messages
		call	Setup_res_end
		push	cs
		pop	ds

EnvMaximum:				;
		mov	si, 2890h	; TRANSTART
		add	si, 100h	; TRANSTART+100h
		mov	cx, 9B47h	; TRANDATAEND-100h
		cld
		shr	cx, 1
		xor	dx, dx

Ichksum:				; ...
		lodsw
		add	dx, ax
		adc	dx, 0
		loop	Ichksum
		mov	[Sum], dx
		cmp	[PRDATTM], 0
		jnz	short NoBatchSeg
		mov	bx, 4		; ((BATCHSEGMENT.SIZE)+16+15)/16
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short NoBatchSeg
		mov	[Batch], ax

NoBatchSeg:				; ...
		mov	bx, [EnvirSeg]
		mov	[OldEnv], bx
		mov	[UsedEnv], 0
		mov	ds, bx
		xor	si, si
		mov	di, si
		mov	bx, 0FFFh	; 4096-1
		mov	[ss:EnvMax], bx
		shl	bx, 1
		shl	bx, 1
		shl	bx, 1
		shl	bx, 1
		mov	[ss:EnvMax], bx
		dec	bx
		xor	dx, dx

NxtStr:					; ...
		call	GetStrLen
		push	ds
		push	cs
		pop	ds
		add	[UsedEnv], cx
		pop	ds
		cmp	cx, 1
		jz	short EnvExit
		sub	bx, cx
		jnb	short OkCpyStr
		inc	dx
		jmp	short EnvExit
; ---------------------------------------------------------------------------

OkCpyStr:				; ...
		jmp	short NxtStr
; ---------------------------------------------------------------------------

EnvExit:				; ...
		push	cs
		pop	ds
		or	dx, dx
		jz	short EnvNoErr
		mov	dx, offset OUTENVMSG
		call	RPrint

EnvNoErr:				; ...
		mov	ax, [EnvSiz]
		mov	cl, 4
		shl	ax, cl
		cmp	ax, [UsedEnv]
		ja	short st_envsize
		mov	ax, [UsedEnv]
		add	ax, 0Fh

st_envsize:				; ...
		shr	ax, cl
		mov	[EnvSiz], ax
		cmp	[Batch], 0
		jnz	short DoDate
		jmp	NoDttm
; ---------------------------------------------------------------------------

DoDate:					; ...
		mov	ax, [Batch]
		mov	[EchoFlag], 3
		mov	[Nest],	1
		mov	es, ax
		xor	di, di
		mov	al, 0
		stosb
		mov	al, 1
		stosb
		xor	ax, ax
		stosb
		stosw
		stosw
		stosb
		stosw
		stosw
		mov	ax, 0FFFFh
		mov	cx, 10
		rep stosw
		cmp	[AUTOBAT], 0
		jnz	short NoAutSet
		mov	ah, 19h
		int	21h		; DOS -	GET DEFAULT DISK NUMBER
		add	al, [ucasea]
		mov	[AUTOBAT], al

NoAutSet:				; ...
		mov	si, offset AUTOBAT
		mov	cx, 8
		rep movsw
		movsb
		mov	dx, offset AUTOBAT
		mov	ax, 3D00h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jb	short noabat
		mov	bx, ax
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		jmp	short Drv0
; ---------------------------------------------------------------------------

noabat:					; ...
		push	ax
		call	Setup_Seg
		mov	[triage_add_seg], ax ; [triage_add+2]
		pop	ax
		call	[dword ptr triage_add] ; call far [triage_add]
					; get extended error
		cmp	ax, 65
		jz	short AccDenErr
		jmp	short OpenErr
; ---------------------------------------------------------------------------

AccDenErr:				; ...
		mov	dx, offset ACCDEN
		call	RPrint

OpenErr:				; ...
		mov	es, [Batch]
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	[Batch], 0	; byte
		mov	[EchoFlag], 1	; byte
		mov	[Nest],	0	; word
		mov	ax, offset DATINIT
		mov	[INITADD], ax
		mov	ax, 2890h	; TRANSTART
		mov	cl, 4		; TRANSTART>>4
		shr	ax, cl
		mov	cx, cs
		add	ax, cx
		mov	[INITADD+2], ax
		call	[dword ptr INITADD] ; call far [INITADD]

NoDttm:					; ...
		cmp	[SingleCom], 0	; if IBMVER
		jnz	short Drv0
		mov	dx, offset COPYRIGHTMSG
		call	RPrint		;
					; endif

Drv0:					; ...
		push	ds
		push	cs
		pop	ds
		mov	ax, 0B707h
		mov	bx, [Append_State]
		int	2Fh		; - Multiplex -	DOS 4.0	APPEND - SET APPEND FUNCTION STATE
					; BX = APPEND state bits
		pop	ds
		cmp	[FirstCom], 1
		jz	short move_code
		push	es
		push	ds
		push	ds
		pop	es
		assume es:RESGROUP
		mov	di, offset Int2f_Entry
		lds	si, [es:ResJmpTable]
		mov	cx, 11
		shl	cx, 1
		shl	cx, 1
		cld
		rep movsb
		mov	al, [byte ptr cox_location] ; "cox"
		mov	[byte ptr es:cox_location], al ; "cox"
		mov	ax, [word ptr cox_location+1]
		mov	[word ptr es:cox_location+1], ax
		cmp	[word ptr es:di-2], 0F000h
		jb	short res_low
		mov	[es:ComInHMA], 1

res_low:				; ...
		pop	ds
		pop	es
		assume es:nothing
		jmp	short finish_init
; ---------------------------------------------------------------------------

move_code:				; ...
		call	Move_res_code

finish_init:				; ...
		cmp	[PermCom], 1
		jnz	short finish_init_@
		cmp	[COMMAND_HIGH],	1 ; COMMAND.COM	will be	moved to HMA/UMB flag (=1)
		jnz	short finish_init_@
		mov	bx, 40h		; high memory first fit
		mov	ax, 5801h	; set allocation strategy
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		mov	bx, 1		; add UMBs to DOS memory chain
		mov	ax, 5803h	; set UMB link state
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) set UMB link state
		jb	short finish_init_@
		mov	bx, [ResSize]
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jnb	short patch_segments_hma

finish_init_@:				; ...
		jmp	EndInit
; ---------------------------------------------------------------------------

patch_segments_hma:			; ...
		mov	[ds:0Ch], ax	; [PDB.EXIT+2]
		mov	[ds:10h], ax	; [PDB.CTRL_C+2]
		mov	[ds:14h], ax	; [PDB.FATAL_ABORT+2]
		mov	[ds:16h], ax	; [PDB.PARENT_PID]
		mov	[ds:36h], ax	; [PDB.JFN_Pointer+2]
		mov	[Parent], ax
		mov	[word ptr OldTerm+2], ax
		mov	[Com_Ptr+2], ax
		mov	[Com_Fcb1+2], ax
		mov	[Com_Fcb2+2], ax
		mov	[MySeg], ax
		mov	[MySeg1], ax
		mov	[MySeg2], ax
		mov	[MySeg3], ax
		mov	[int2fh_segm], ax ; [Carousel_i2f_Hook+3]
		mov	di, (offset Int2f_Entry+2)
		cmp	[word ptr di], 0FFFFh
		jz	short already_hma
		mov	cl, 11		; NUM_RELOC_ENTRIES

patch_entry_seg:			; ...
		mov	[di], ax
		add	di, 4
		loop	patch_entry_seg

already_hma:				; ...
		mov	es, ax
		assume es:nothing
		xor	si, si
		xor	di, di
		mov	cl, 3		; BX = resident	part size in paragraphs
					; after	shifting: resident part	size in	words
		shl	bx, cl		; move resident	part of	COMMAND.COM to HMA (UMB)
		mov	cx, bx		; number of words
		rep movsw
		push	ds
		mov	ds, cx		; 0
		mov	[ds:0BAh], ax	; INT 2Eh segment
		inc	ax
		mov	[ds:0BEh], ax	; INT 2Fh segment
		pop	ds
		mov	bx, es
		mov	ah, 50h
		int	21h		; DOS -	2+ internal - SET PSP SEGMENT
					; BX = segment address of new PSP
		dec	bx
		mov	es, bx		; memory arena header (segment)
		assume es:nothing
		inc	bx		; PSP (program)	address/segment
		mov	[es:1],	bx	; [ARENA.owner]
		mov	[word ptr es:8], 4F43h ; 'CO' ; [es:arena_name]
		mov	[word ptr es:0Ah], 4D4Dh ; 'MM'
		mov	[word ptr es:0Ch], 4E41h ; 'AN'
		mov	[word ptr es:0Eh], 44h ; 'D' ; 'D'
		inc	[COMMAND_HIGH]	; = 2
					; Resident portion of COMMAND.COM is
					; in HMA/UMB flag (=2)
		push	bx
		mov	ax, offset EndInit
		push	ax
		retf

; =============== S U B	R O U T	I N E =======================================


proc		GetStrLen near		; ...
		xor	cx, cx

NxtChar:				; ...
		lodsb
		inc	cx
		or	al, al
		jnz	short NxtChar
		retn
endp		GetStrLen


; =============== S U B	R O U T	I N E =======================================


proc		Setup_Seg near		; ...
		mov	ax, [TrnSeg]
		cmp	[TrnMvFlg], 1
		jz	short setup_end
		push	bx
		mov	bx, cs
		mov	ax, 2890h	; TRANSTART
		shr	ax, 1
		shr	ax, 1
		shr	ax, 1
		shr	ax, 1		; TRANSTART>>4
		add	ax, bx
		pop	bx

setup_end:				; ...
		retn
endp		Setup_Seg


; =============== S U B	R O U T	I N E =======================================


proc		RPrintParse near	; ...
		push	dx
		xchg	bx, dx
		dec	bx
		shl	bx, 1
		mov	bx, [PARSMSGPTRS+bx]
		xchg	bx, dx
		call	RPrint
		pop	dx
		retn
endp		RPrintParse


; =============== S U B	R O U T	I N E =======================================


proc		IfindE near		; ...
		call	ifind
		jb	short ifind2
		jmp	short Iscasb1
endp		IfindE


; =============== S U B	R O U T	I N E =======================================


proc		ifind near		; ...
		cld
		call	Icount0
		mov	es, [EnvirSeg]
		assume es:nothing
		xor	di, di

ifind1:					; ...
		push	cx
		push	si
		push	di

ifind11:				; ...
		lodsb
		call	ITestKanj	; ifdef	DBCS
		jz	short _NotKanj4
		dec	si
		lodsw
		inc	di
		inc	di
		cmp	ax, [es:di-2]
		jnz	short ifind12
		dec	cx
		loop	ifind11
		jmp	short ifind12	; endif
; ---------------------------------------------------------------------------

_NotKanj4:				; ...
		call	iupconv
		inc	di
		cmp	al, [es:di-1]
		jnz	short ifind12
		loop	ifind11

ifind12:				; ...
		pop	di
		pop	si
		pop	cx
		jz	short ifind2
		push	cx
		call	Iscasb2
		pop	cx
		cmp	[byte ptr es:di], 0
		jnz	short ifind1
		stc

ifind2:					; ...
		retn
endp		ifind


; =============== S U B	R O U T	I N E =======================================


proc		Icount0	near		; ...
		push	ds
		pop	es
		assume es:RESGROUP
		mov	di, si
		push	di
		call	Iscasb1
		jmp	short Icountx
; ---------------------------------------------------------------------------
		push	di
		call	Iscasb2

Icountx:				; ...
		pop	cx
		sub	di, cx
		xchg	di, cx
		retn
endp		Icount0


; =============== S U B	R O U T	I N E =======================================


proc		Iscasb1	near		; ...
		mov	al, [equalsign]
		jmp	short Iscasbx
endp		Iscasb1


; =============== S U B	R O U T	I N E =======================================


proc		Iscasb2	near		; ...
		xor	al, al

Iscasbx:				; ...
		mov	cx, 256
		repne scasb
		retn
endp		Iscasb2


; =============== S U B	R O U T	I N E =======================================


proc		iupconv	near		; ...
		cmp	al, 80h
		jb	short other_fucase
		sub	al, 80h
		push	ds
		push	bx
		lds	bx, [dword ptr FUCase_Addr+1] ;	lds bx,[FUCase_Addr+1]
		add	bx, 2
		xlat
		pop	bx
		pop	ds
		jmp	short iupconv_end
; ---------------------------------------------------------------------------

other_fucase:				; ...
		cmp	al, [lcasea]
		jb	short iupconv_end
		cmp	al, [lcasez]
		ja	short iupconv_end
		sub	al, 20h

iupconv_end:				; ...
		retn
endp		iupconv

; ---------------------------------------------------------------------------

init_contc_specialcase:			; ...
		add	sp, 6
		push	si
		mov	si, dx
		mov	[word ptr si+1], 0D00h
		pop	si
		iret

; =============== S U B	R O U T	I N E =======================================


proc		setup_for_messages near	; ...
		push	bx
		push	ds
		push	es
		push	ax
		push	dx
		push	di
		mov	ax, cs
		mov	ds, ax
		mov	es, ax
		cmp	[PermCom], 0
		jz	short no_permcom
		push	es
		mov	ax, 352Fh	; (GET_INTERRUPT_VECTOR	shl 8) or 2Fh
		int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
					; AL = interrupt number
					; Return: ES:BX	= value	of interrupt vector
		mov	[Int2fHandler],	bx
		mov	[Int2fHandler+2], es
		pop	es
		assume es:nothing
		cmp	[FirstCom], 0
		jz	short no_msg_hook
		push	ds
		mov	dx, offset Carousel_i2f_Hook
		sub	dx, 10h
		mov	ax, ds
		inc	ax
		mov	ds, ax
		assume ds:nothing
		mov	ax, 252Fh	; (SET_INTERRUPT_VECTOR	shl 8) or 2Fh
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		pop	ds
		assume ds:RESGROUP
		mov	[int2fh_segm], ds ; [Carousel_i2f_Hook+3]

no_msg_hook:				; ...
		cmp	[ext_msg], 1	; SET_EXTENDED_MSG
		jnz	short permcom_end
		mov	di, offset PATRICIDE ; ExtMsgEnd (at 0DD8h)
		mov	[ResMsgEnd], di
		jmp	short permcom_end
; ---------------------------------------------------------------------------

no_permcom:				; ...
		cmp	[ext_msg], 1	; SET_EXTENDED_MSG
		jnz	short permcom_end
		mov	dx, 2		; LessArgs_Ptr
		call	RPrintParse

permcom_end:				; ...
		pop	di
		pop	dx
		pop	ax
		pop	es
		pop	ds
		pop	bx
		retn
endp		setup_for_messages


; =============== S U B	R O U T	I N E =======================================


proc		CheckHelp near		; ...
		mov	si, 81h
		mov	di, offset PARSE_COMMAND
		xor	cx, cx
		xor	dx, dx

chParse:				; ...
		call	[dword ptr Init_Parse] ; call far [Init_Parse] ; call system parser
		cmp	ax, 0FFFFh
		jz	short chRet
		cmp	ax, 0
		jz	short chWhich
		jmp	short chParse
; ---------------------------------------------------------------------------

chWhich:				; ...
		cmp	[COMND1_SYN], offset COMMAND_?_SYN ; "/?"
		jz	short chHelp
		cmp	[COMND1_SYN], offset COMMAND_C_SYN ; "/C"
		jz	short chRet
		cmp	[COMND1_SYN], offset COMMAND_K_SYN ; "/K"
		jz	short chRet
		jmp	short chParse
; ---------------------------------------------------------------------------

chHelp:					; ...
		mov	si, offset HelpMsgs

chHelpNext:				; ...
		lodsw
		or	ax, ax
		jz	short chHelpDone
		mov	dx, ax
		call	RPrint
		jmp	short chHelpNext
; ---------------------------------------------------------------------------

chHelpDone:				; ...
		int	20h		; DOS -	PROGRAM	TERMINATION
					; returns to DOS--identical to INT 21/AH=00h
; ---------------------------------------------------------------------------

chRet:					; ...
		retn
endp		CheckHelp


; =============== S U B	R O U T	I N E =======================================


proc		Setup_res_end near	; ...
		push	ds
		mov	ax, cs
		mov	ds, ax
		mov	cx, [ResMsgEnd]
		cmp	cx, offset PATRICIDE ; ExtMsgEnd
		jnz	short calc_res
		add	cx, 0Fh
		and	cx, 0FFF0h

calc_res:				; ...
		xor	ax, ax
		cmp	[FirstCom], 1
		jnz	short not_first
		push	bx
		push	cx
		mov	ax, 3306h	; (Set_CTRL_C_Trapping shl 8)
		int	21h		; DOS -	5+ Get TRUE Version Number
					; (BL major, BH	minor, DL revision, DH flags)
		pop	cx
		cmp	bl, 5
		jb	short oldver
		xor	ax, ax
		and	dh, 10h
		pop	bx
		jnz	short not_first
		mov	ax, 894h	; EndCode-RCODE_START

not_first:				; ...
		add	cx, ax
		add	cx, 0Fh
		shr	cx, 1
		shr	cx, 1
		shr	cx, 1
		shr	cx, 1
		mov	[ResSize], cx
		pop	ds
		retn
; ---------------------------------------------------------------------------

oldver:					; ...
		pop	bx
		mov	ax, 894h
		jmp	short not_first
endp		Setup_res_end


; =============== S U B	R O U T	I N E =======================================


proc		Move_res_code near	; ...
		push	ds
		push	es
		mov	ax, cs
		mov	ds, ax
		mov	ax, 3306h
		int	21h		; DOS -	5+ Get TRUE Version Number (BL major, BH minor,	DL revision, DH	flags)
		and	dh, 10h
		jnz	short move_high

load_low:				; ...
		push	ds
		pop	es
		assume es:RESGROUP
		mov	di, [ResMsgEnd]
		mov	bx, offset PATRICIDE ; ExtMsgEnd ; (this bx is not used	after here!)
					; Erdogan Tan -	18/07/2024
		jmp	short setup_move
; ---------------------------------------------------------------------------

move_high:				; ...
		mov	bx, 894h	; EndCode-RCODE_START
		mov	di, 0FFFFh
		mov	ax, 4A02h	; GET_HMA_ADDR
		int	2Fh
		cmp	di, 0FFFFh
		mov	[ComInHMA], 1	; byte
		jnz	short setup_move
		mov	[ComInHMA], 0
		mov	cx, [ResMsgEnd]
		mov	ax, 894h	; EndCode-RCODE_START
		add	cx, ax
		add	cx, 0Fh
		shr	cx, 1
		shr	cx, 1
		shr	cx, 1
		shr	cx, 1
		mov	[ResSize], cx
		jmp	short load_low
; ---------------------------------------------------------------------------

setup_move:				; ...
		mov	si, offset Exec_Err ; RCODE_START
		mov	cx, 894h	; EndCode-RCODE_START
		cld
		push	di
		rep movsb
		pop	di
		call	patch_stub
		pop	es
		assume es:nothing
		pop	ds
		retn
endp		Move_res_code


; =============== S U B	R O U T	I N E =======================================


proc		alloc_env near		; ...

; FUNCTION CHUNK AT 0F12 SIZE 00000003 BYTES

		push	ds
		push	es
		push	si
		push	di
		push	ss
		pop	ds
		mov	ax, [EnvirSeg]
		cmp	[AllocedEnv], 0
		jz	short alloc_cont
		jmp	alloc_done
; ---------------------------------------------------------------------------

alloc_cont:				; ...
		sub	di, di
		mov	bx, 166		; ENVIRONSIZ
		cmp	[FirstCom], 0
		jz	short alloc_seg
		or	ax, ax
		jz	short alloc_new
		mov	es, ax
		mov	al, 0
		sub	di, di

comp_path:				; ...
		scasb
		jz	short find_comspec
		dec	di
		mov	cx, 5		; PathStrLen
		mov	si, offset PathString ;	"PATH="
		repe cmpsb
		jz	short got_path
		mov	cx, 256
		repne scasb
		jmp	short comp_path
; ---------------------------------------------------------------------------

got_path:				; ...
		mov	[byte ptr PathString], 0 ; "PATH="

find_comspec:				; ...
		sub	di, di

comp_comspec:				; ...
		scasb
		jz	short got_envend
		dec	di
		mov	cx, 8		; ComspStrLen
		mov	si, offset ComspString ; "COMSPEC=\\COMMAND.COM"
		repe cmpsb
		jz	short got_comspec
		mov	cx, 256
		repne scasb
		jmp	short comp_comspec
; ---------------------------------------------------------------------------

got_comspec:				; ...
		mov	[ComspOffset], di
		sub	di, di
		mov	cx, 32768	; ENVBIG

comp_envend:				; ...
		dec	cx
		scasb
		jz	short got_envend
		repne scasb
		jmp	short comp_envend
; ---------------------------------------------------------------------------

got_envend:				; ...
		dec	di
		lea	bx, [di+166]	; [DI+ENVIRONSIZ]
		push	ds
		mov	ds, [word ptr ds:16h] ;	[PDB.PARENT_PID]
		cmp	[word ptr ds:16h], 0 ; [PDB.PARENT_PID]
		pop	ds
		jnz	short alloc_seg

alloc_new:				; ...
		inc	[AllocedEnv]	; byte

alloc_seg:				; ...
		mov	cx, bx
		add	bx, 0Fh
		shr	bx, 1
		shr	bx, 1
		shr	bx, 1
		shr	bx, 1
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jnb	short init_ok
		jmp	init_nomem
; ---------------------------------------------------------------------------

init_ok:				; ...
		mov	es, ax
		assume es:nothing
		or	di, di
		jz	short copy_path
		push	cx
		push	ds
		mov	ds, [EnvirSeg]
		sub	si, si
		mov	cx, di
		sub	di, di
		rep movsb
		pop	ds
		pop	cx
		sub	cx, di

copy_path:				; ...
		push	di
		sub	ax, ax
		rep stosb
		pop	di
		mov	si, offset PathString ;	"PATH="
		cmp	[si], al
		jz	short init_comspec
		mov	cx, 6		; db "PATH=",0
		rep movsb
		cmp	[AllocedEnv], al
		jz	short init_comspec
		mov	ah, 19h		; GET_DEFAULT_DRIVE
		int	21h		; DOS -	GET DEFAULT DISK NUMBER
		add	al, 41h	; 'A'
		mov	[byte ptr DefPathString], al ; "C:\\DOS"
		mov	[byte ptr DefPath2String], al ;	"C:\\MSDOS"
		mov	dl, 0
		push	ds
		push	es
		pop	ds
		assume ds:nothing
		mov	[byte ptr di], '\'
		lea	si, [di+1]
		mov	ah, 47h		; Current_Dir
		int	21h		; DOS -	2+ - GET CURRENT DIRECTORY
					; DL = drive (0=default, 1=A, etc.)
					; DS:SI	points to 64-byte buffer area
		pop	ds
		assume ds:RESGROUP
		mov	cx, 7		; DefPathStrLen+1
		mov	dx, offset DefPathString ; "C:\\DOS"
		mov	si, dx
		mov	ah, 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		jnb	short init_setpath
		mov	cx, 9		; DefPath2StrLen+1
		mov	dx, offset DefPath2String ; "C:\\MSDOS"
		mov	si, dx
		mov	ah, 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		jb	short init_comspec

init_setpath:				; ...
		mov	dx, di
		push	ds
		push	es
		pop	ds
		assume ds:nothing
		mov	ah, 3Bh		; CHDir
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		pop	ds
		assume ds:RESGROUP
		dec	di
		rep movsb

init_comspec:				; ...
		push	di
		sub	ax, ax
		mov	cx, 64
		rep stosb
		pop	di
		cmp	[ComspOffset], ax
		jnz	short init_done
		lea	ax, [di+8]	; [di+ComspStrLen]
		mov	[ComspOffset], ax
		mov	si, offset ComspString ; "COMSPEC=\\COMMAND.COM"
		mov	cx, 21		; ComspStrLen2+1 ; db "COMSPEC=\COMMAND.COM",0
		rep movsb

init_done:				; ...
		mov	ax, es
		mov	[EnvirSeg], ax
		inc	[AllocedEnv]	; byte

alloc_done:				; ...
		pop	di
		pop	si
		pop	es
		assume es:nothing
		pop	ds
		retn
; ---------------------------------------------------------------------------

init_nomem:				; ...
		call	$+3		; call Alloc_error

Alloc_error:				; ...
		jmp	BadMemErr
endp		alloc_env


; =============== S U B	R O U T	I N E =======================================


proc		patch_stub near		; ...
		push	es
		mov	bx, es
		mov	dx, di
		mov	di, offset Int2f_Entry
		mov	si, offset Reloc_Table
		push	ds
		pop	es
		assume es:RESGROUP
		mov	cx, 11

patchlp:				; ...
		lodsw
		add	ax, dx
		stosw
		mov	ax, bx
		stosw
		loop	patchlp
		pop	es
		assume es:nothing
		retn
endp		patch_stub


; =============== S U B	R O U T	I N E =======================================


proc		patch_segs near		; ...
		mov	di, offset Int2f_Entry
		mov	cx, 4		; we have to patch 4 handlers
		add	di, 2
		mov	ax, es

pseglp:					; ...
		stosw
		add	di, 2
		loop	pseglp
		retn
endp		patch_segs


; =============== S U B	R O U T	I N E =======================================


proc		get_XMMAddr near	; ...
		push	es
		mov	ax, 4300h	; XMM_MULTIPLEX	SHL 8 +	XMM_INSTALL_CHECK
		int	2Fh		; - Multiplex -	XMS - INSTALLATION CHECK
					; Return: AL = 80h XMS driver installed
					; AL <>	80h no driver
		cmp	al, 80h		; Q: installed
		jnz	short cXMMexit	; N: set error,	quit
		mov	ax, 4310h	; XMM_MULTIPLEX	SHL 8 +	XMM_FUNCTION_ADDR
		int	2Fh		; - Multiplex -	XMS - GET DRIVER ADDRESS
					; Return: ES:BX	-> driver entry	point
		mov	[word ptr XMMCallAddr],	bx
		mov	[word ptr XMMCallAddr+2], es

cXMMexit:				; ...
		pop	es
		retn
endp		get_XMMAddr

; ---------------------------------------------------------------------------
		db 14 dup(0)		; align	16
ICONDEV		db '/DEV'
		db '/CON',0,0,0,0,0,0,0
COMSPECT	db '\COMMAND.COM',0     ; ...
		db 0
AUTOBAT		db 0			; ...
		db ':'
		db '\AUTOEXEC.BAT',0
		db 0Dh
PRDATTM		db 0FFh			; ...
INITADD		dw 2 dup(0)		; 0 ; ...
print_add	dw offset Printf_Init
		dw 0
triage_add	dw offset Triage_Init	; ...
triage_add_seg	dw 0			; ...
AllocedEnv	db 0			; ...
PathString	db 'PATH=',0            ; ...
DefPathString	db 'C:\DOS',0           ; ...
DefPath2String	db 'C:\MSDOS',0         ; ...
ComspOffset	dw 0			; ...
ComspString	db 'COMSPEC=\COMMAND.COM',0 ; ...
equalsign	db '='                  ; ...
lcasea		db 'a'                  ; ...
lcasez		db 'z'                  ; ...
space_chr	db 20h			; ...
scswitch	db 'C'                  ; ...
skswitch	db 'K'                  ; ...
ucasea		db 'A'                  ; ...
EnvSiz		dw 0			; ...
EnvMax		dw 0			; ...
OldEnv		dw 0			; ...
UsedEnv		dw 0			; ...
PARS_MSG_OFF	dw 0
PARS_MSG_SEG	dw 0
Init_Parse	dw offset append_parse	; ...
					; init_p
InitEnd		dw 0			; ...
TrnSize		dw 0			; ...
resetenv	db 0
ext_msg		db 0			; ...
eswitch		db 0			; ...
dswitch		db 0			; ...
parsemes_ptr	dw 0
PARSE_COMMAND	dw offset COMMAND_PARMS	; ...
		db 0
COMMAND_PARMS	db 0			; ...
		db 2
		dw offset COMMAND_FILE
		dw offset COMMAND_FILE
		db 11
		dw offset COMMAND_SWITCH1
		dw offset COMMAND_SWITCH2
		dw offset COMMAND_SWITCH3
		dw offset COMMAND_SWITCH4
		dw offset COMMAND_SWITCH5
		dw offset COMMAND_SWITCH6
		dw offset COMMAND_SWITCH7
		dw offset COMMAND_SWITCH8
		dw offset COMMAND_SWITCH9
		dw offset COMMAND_SWITCH10
		dw offset COMMAND_SWITCH11
		db 0
COMMAND_FILE	dw 201h			; ...
		dw 1
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 0
COMMAND_SWITCH1	dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_P_SYN	db '/P',0               ; ...
COMMAND_SWITCH2	dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_F_SYN	db '/F',0               ; ...
COMMAND_SWITCH3	dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_D_SYN	db '/D',0               ; ...
COMMAND_SWITCH4	dw 8000h		; ...
		dw 0
		dw offset COMND1_OUTPUT
		dw offset COMMAND_E_VAL
		db 1
COMMAND_E_SYN	db '/E',0               ; ...
COMMAND_E_VAL	db 1			; ...
		db 1
		db 1
		dd 160
		dd 32768
		db 0
		db 0
COMMAND_SWITCH5	dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_C_SYN	db '/C',0               ; ...
COMMAND_SWITCH6	dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_M_SYN	db '/MSG',0             ; ...
COMMAND_SWITCH7	dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_?_SYN	db '/?',0               ; ...
COMMAND_SWITCH8	dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_K_SYN	db '/K',0               ; ...
COMMAND_SWITCH9	dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_Y_SYN	db '/Y',0               ; ...
COMMAND_SWITCH10 dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_H_SYN	db '/H',0               ; ...
COMMAND_SWITCH11 dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_O_SYN	db '/O',0               ; ...
COMND1_OUTPUT	db 0			; ...
					; COMND1_TYPE
COMND1_CODE	db 0
COMND1_SYN	dw 0			; ...
COMND1_ADDR	dd 0			; ...
NO_VAL		db 0			; ...
num_positionals	dw 0			; ...
old_parse_ptr	dw 0			; ...
BADVERMSG	db 23			; ...
		db 'Incorrect DOS version',0Dh,0Ah
OUTENVMSG	db 26			; ...
		db 'Out of environment space',0Dh,0Ah
COPYRIGHTMSG	db 100			; ...
		db 0Dh,0Ah
		db 0Dh,0Ah
		db 'PC DOS Version 7.10',0Dh,0Ah
		db '             (C)Copyright International Business Machines Corp 19'
		db '81-2002.',0Dh,0Ah
BADCOMLKMES	db 40			; ...
		db 'Specified COMMAND search directory bad',0Dh,0Ah
BADCOMACCMSG	db 55			; ...
		db 'Specified COMMAND search directory bad, access denied',0Dh,0Ah
HELPMSG1	db 38h			; ...
		db 'Starts a new copy of the PC DOS Command Interpreter.',0Dh,0Ah
		db 0Dh,0Ah
HELPMSG2	db 38h			; ...
		db 'COMMAND [[drive:]path] [device] [/E:nnnnn] [/P [/MSG]]',0Dh,0Ah
HELPMSG3	db 34h			; ...
		db '        [/H] [/O] [/Y [/C command | /K command]]',0Dh,0Ah
		db 0Dh,0Ah
HELPMSG4	db 48h			; ...
		db '  [drive:]path    Specifies the directory containing COMMAND.COM '
		db 'file.',0Dh,0Ah
HELPMSG5	db 4Dh			; ...
		db '  device          Specifies the device to use for command input a'
		db 'nd output.',0Dh,0Ah
HELPMSG6	db 45h			; ...
		db '  /E:nnnnn        Sets the initial environment size to nnnnn byte'
		db 's.',0Dh,0Ah
HELPMSG7	db 4Dh			; ...
		db '  /P              Makes the new Command Interpreter permanent (ca'
		db 'n',27h,'t exit).',0Dh,0Ah
HELPMSG8	db 46h			; ...
		db '  /MSG            Stores all error messages in memory (requires /'
		db 'P).',0Dh,0Ah
HELPMSG9	db 4Ah			; ...
		db '  /H              Loads the Command Interpreter into a UMB if ava'
		db 'ilable.',0Dh,0Ah
HELPMSG10	db 4Eh			; ...
		db '  /O              Disables overwrite prompt on COPY,XCOPY,and MOV'
		db 'E commands.',0Dh,0Ah
HELPMSG11	db 4Ah			; ...
		db '  /Y              Steps through the batch program specified by /C'
		db ' or /K.',0Dh,0Ah
HELPMSG12	db 3Fh			; ...
		db '  /C command      Executes the specified command and returns.',0Dh,0Ah
HELPMSG13	db 4Bh			; ...
		db '  /K command      Executes the specified command and continues ru'
		db 'nning.',0Dh,0Ah
		db 0Dh,0Ah
HELPMSG14	db 4Ch			; ...
		db 'The /P and /MSG switches may be used only when COMMAND is started'
		db ' by using',0Dh,0Ah
HELPMSG15	db 2Bh			; ...
		db 'the SHELL command in the CONFIG.SYS file.',0Dh,0Ah
HelpMsgs	dw offset HELPMSG1	; ...
		dw offset HELPMSG2
		dw offset HELPMSG3
		dw offset HELPMSG4
		dw offset HELPMSG5
		dw offset HELPMSG6
		dw offset HELPMSG7
		dw offset HELPMSG8
		dw offset HELPMSG9
		dw offset HELPMSG10
		dw offset HELPMSG11
		dw offset HELPMSG12
		dw offset HELPMSG13
		dw offset HELPMSG14
		dw offset HELPMSG15
		dw 0
Reloc_Table	dw 7B2h			; ...
					; MsgInt2fHandler - RCODE_START	(15C2h-0E10h)
		dw 170h			; Int_2e - RCODE_START
		dw 2Eh			; ContC	- RCODE_START
		dw 495h			; DSKERR - RCODE_START
		dw 22h			; Exec_Ret - RCODE_START
		dw 2A6h			; TRemCheck - RCODE_START
		dw 472h			; TrnLodCom1 - RCODE_START
		dw 1A7h			; LodCom - RCODE_START
		dw 7F5h			; MsgRetriever - RCODE_START
		dw 2C5h			; THeadFix - RCODE_START
		dw 86Eh			; Lh_OffUnlink - RCODE_START
ResJmpTable	dd 0			; ...
FirstCom	db 0			; ...
DevFlag		db 0			; ...
PathFlag	db 0			; ...
		db 5 dup(0)
ends		RESGROUP

; ===========================================================================

; Segment type:	Regular
segment		TRANGROUP byte public 'TRANGROUP' use16
		assume cs:TRANGROUP
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
TRANSIENTSTART	db 256 dup(0)		; 0
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR PROMPTBAT

SETDRV:					; ...
		mov	ah, 0Eh
		int	21h		; DOS -	SELECT DISK
					; DL = new default drive number	(0 = A,	1 = B, etc.)
					; Return: AL = number of logical drives

TCOMMAND:				; ...
		nop
		nop
		mov	ds, [cs:RESSEG]
		assume ds:RESGROUP
		mov	ax, 0FFFFh
		xchg	ax, [VerVal]
		cmp	ax, 0FFFFh
		jz	short NOSETVER2
		mov	ah, 2Eh
		int	21h		; DOS -	SET VERIFY FLAG
					; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off

NOSETVER2:				; ...
		call	[dword ptr cs:HEADCALL]	; call far [cs:HEADCALL]
		xor	bp, bp
		cmp	[SingleCom], 0FFFFh ; -1
		jnz	short COMMAND

_$EXITPREP:				; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		jmp	_$EXIT
; ---------------------------------------------------------------------------

COMMAND:				; ...
		cld
		mov	ax, cs
		cli
		mov	ss, ax
		assume ss:TRANGROUP
		mov	sp, offset STACK ; 0AA2Dh
		sti
		mov	es, ax
		assume es:TRANGROUP
		mov	ds, ax
		call	TSYSLOADMSG
		mov	[append_exec], 0
		mov	ds, [RESSEG]
		assume ds:RESGROUP
		mov	[ss:UCOMBUF], 128
		mov	[ss:COMBUF], 128
		or	bp, bp
		jz	short TESTRDIR
		mov	[word ptr ss:UCOMBUF+1], 0D01h ; Reset buffer
		jmp	short NOSETBUF
; ---------------------------------------------------------------------------

TESTRDIR:				; ...
		cmp	[RestDir], 0	; byte
		jz	short NOSETBUF
		push	ds
		mov	[RestDir], 0
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	dx, offset USERDIR1
		mov	ah, 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		pop	ds
		assume ds:nothing

NOSETBUF:				; ...
		cmp	[ds:PipeFiles],	0
		jz	short NOPCLOSE
		cmp	[ds:PipeFlag], 0
		jnz	short NOPCLOSE
		call	PIPEDEL

NOPCLOSE:				; ...
		mov	[ds:ExtCom], 0
		mov	ax, cs
		mov	ds, ax
		assume ds:TRANGROUP
		push	ax
		mov	dx, offset STACK ; INTERNATVARS
		mov	ax, 3800h
		int	21h		; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
					; get current-country info
					; DS:DX	-> buffer for returned info
		pop	ax
		sub	ax, [TPA]
		push	bx
		mov	bx, 16
		mul	bx
		pop	bx
		or	dx, dx
		jz	short SAVSIZ
		mov	ax, 0FFFFh	; -1

SAVSIZ:					; ...
		cmp	ax, 512
		jbe	short GOTSIZE
		and	ax, 0FE00h	; ~1FFh

GOTSIZE:				; ...
		mov	[BYTCNT], ax
		mov	ds, [RESSEG]
		assume ds:RESGROUP
		test	[EchoFlag], 1
		jz	short GETCOM
		call	SINGLETEST
		jb	short GETCOM
		test	[PipeFlag], 0FFh
		jnz	short GETCOM
		test	[ForFlag], 0FFh
		jnz	short GETCOM
		test	[Batch], 0FFFFh
		jnz	short GETCOM
		call	CRLF2

GETCOM:					; ...
		cmp	[SingleCom], 0
		jnz	short GETCOM2
		test	[Batch], 0FFFFh
		jnz	short GETCOM2
		and	[byte ptr Y_Flag], 0EFh	; Y/N question overwrite flag ;	~10h

GETCOM2:				; ...
		mov	[Call_Flag], 0
		mov	[Call_Batch_Flag], 0
		mov	ah, 19h
		int	21h		; DOS -	GET DEFAULT DISK NUMBER
		mov	[ss:CURDRV], al
		test	[PipeFlag], 0FFh ; -1
		jz	short NOPIPE
		jmp	PIPEPROC
; ---------------------------------------------------------------------------

NOPIPE:					; ...
		test	[EchoFlag], 1
		jz	short NOPDRV
		call	SINGLETEST
		jb	short NOPDRV
		test	[ForFlag], 0FFh
		jnz	short NOPDRV
		test	[Batch], 0FFFFh
		jnz	short TESTFORBAT
		call	PRINT_PROMPT

NOPDRV:					; ...
		test	[ForFlag], 0FFh
		jz	short TESTFORBAT
		jmp	FORPROC		; Continue the FOR
; ---------------------------------------------------------------------------

TESTFORBAT:				; ...
		mov	[ss:RE_INSTR], 0
		mov	[Re_OutStr], 0
		mov	[Re_Out_App], 0
		mov	[IfFlag], 0	; no more ifs...
		test	[Batch], 0FFFFh
		jz	short ISNOBAT
		push	es
		push	ds
		mov	ax, 1902h
		mov	es, [Batch]
		assume es:nothing
		mov	di, 20h		; BATCHSEGMENT.BatFile
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	dx, offset COMBUF
		int	2Fh		; - Multiplex -	DOS 4.x	only SHELLB.COM	- COMMAND.COM INTERFACE
					; ES:DI	-> ASCIZ full filename of current batch	file, with at least the
					; final	filename element uppercased
					; DS:DX	-> buffer for results
		cmp	al, 0FFh	; shell_action
		pop	ds
		assume ds:nothing
		pop	es
		jz	short JDOCOM1
		push	ds
		call	READBAT
		pop	ds
		mov	[ds:NullFlag], 0 ; reset no command flag
		test	[ds:Batch], 0FFFFh
		jnz	short JDOCOM1	; if batch still in progress continue
		mov	bx, [ds:Next_Batch]
		cmp	bx, 0
		jz	short JDOCOM1
		mov	[ds:Batch], bx	; get segment of next batch file
		mov	[ds:Next_Batch], 0 ; reset next	batch

JDOCOM1:				; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		jmp	short DOCOM0
; ---------------------------------------------------------------------------

ISNOBAT:				; ...
		cmp	[ds:SingleCom],	0
		jz	short REGCOM
		mov	si, [ds:SemiPermCom]
		xchg	si, [ds:SingleCom]
		mov	di, (offset COMBUF+2)
		xor	cx, cx

SINGLELOOP:				; ...
		lodsb
		stosb
		inc	cx
		cmp	al, 0Dh
		jnz	short SINGLELOOP
		dec	cx
		push	cs
		pop	ds
		mov	[COMBUF+1], cl
		jmp	short DOCOM0
; ---------------------------------------------------------------------------

REGCOM:					; ...
		mov	ax, 5D09h
		int	21h		; DOS -	3.1+ internal -	FLUSH REDIRECTED PRINTER OUTPUT
		mov	ax, 5D08h
		mov	dl, 1
		int	21h		; DOS -	3.1+ internal -	SET REDIRECTED PRINTER MODE
					; DL = 00h redirected output is	combined
					;      01h redirected output placed in separate	jobs
					; start	new print job now
		push	cs
		pop	ds
		mov	dx, offset UCOMBUF
		mov	ax, 4810h	; DOSKey Read Line function
		int	2Fh
		or	ax, ax
		jz	short GOTCOM	; DOSKey gave us a command line
		mov	ah, 0Ah
		int	21h		; DOS -	BUFFERED KEYBOARD INPUT
					; DS:DX	-> buffer

GOTCOM:					; ...
		mov	cl, [UCOMBUF]
		xor	ch, ch
		add	cx, 3
		mov	si, offset UCOMBUF
		mov	di, offset COMBUF
		rep movsb
		call	CRLF2
		xor	ax, ax
		jmp	short DOCOM2
; ---------------------------------------------------------------------------

DOCOM:					; ...
		call	CRLF2

DOCOM0:					; ...
		mov	ax, 1

DOCOM2:					; ...
		push	ds
		mov	ds, [RESSEG]
		assume ds:RESGROUP
		mov	[cox_Y_option],	ax
		pop	ds
		assume ds:nothing
		mov	si, offset COMBUF
		mov	cl, [si+1]
		xor	ch, ch
		add	si, 2
		call	get_cox_y_n_opt
		jnb	short DOCOM1
		jmp	NULLCOM
; ---------------------------------------------------------------------------

DOCOM1:					; ...
		call	PRESCAN
		jz	short NOPIPEPROC
		jmp	PIPEPROCSTRT
; ---------------------------------------------------------------------------

NULLCOMJ:				; ...
		jmp	NULLCOM
; ---------------------------------------------------------------------------

NOPIPEPROC:				; ...
		call	PARSELINE
		jnb	short OKPARSE

BADPARSE:				; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	dx, offset BADNAM_PTR
		call	std_eprintf
		jmp	TCOMMAND
; ---------------------------------------------------------------------------

OKPARSE:				; ...
		test	[ARGV0_ARG_FLAGS], 2 ; byte [ARG+ARGV_ELE.argflags]
		jnz	short BADPARSE
		cmp	[ARG_ARGVCNT], 0 ; word	[ARG+ARG_UNIT.argvcnt]
		jz	short NULLCOMJ
		cmp	[ARGV0_ARGLEN],	0 ; word [ARG+ARGV_ELE.arglen]
		jz	short NULLCOMJ
		mov	si, (offset COMBUF+2)
		mov	di, offset IDLEN
		mov	ax, 2901h	; (Parse_File_Descriptor<<8)|01h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		mov	bx, [ARG_ARGV]	; [ARG+ARG_UNIT.argv]
		cmp	[byte ptr bx+1], ':'
		jnz	short DRVGD
		mov	dl, [bx]	; [bx+ARGV_ELE.argpointer]
		and	dl, 0DFh	; ~20h ; uppercase
		sub	dl, 41h	; 'A'   ; CAPITAL_A
		cmp	al, 0FFh	; -1
		jz	short DRVBADJ
		mov	di, [ARGV0_ARGSTARTEL] ; [ARG+ARGV_ELE.argstartel]
		cmp	[byte ptr di], 0
		jnz	short DRVGD
		jmp	SETDRV
; ---------------------------------------------------------------------------

DRVBADJ:				; ...
		jmp	DRVBAD
; ---------------------------------------------------------------------------

DRVGD:					; ...
		mov	al, [di]
		mov	[SPECDRV], al
		mov	al, 20h	; ' '
		mov	cx, 9
		inc	di
		repne scasb		; Count	number of letters in command name
		mov	al, 8
		sub	al, cl
		mov	[IDLEN], al	; IDLEN	is truly the length
		mov	di, 81h
		push	si
		mov	si, (offset COMBUF+2)
		call	scanoff
		inc	si

DO_SKIPCOM:				; ...
		lodsb
		call	DELIM
		jz	short DO_SKIPPED
		cmp	al, 0Dh
		jz	short DO_SKIPPED
		cmp	al, [SWITCHAR]
		jnz	short DO_SKIPCOM

DO_SKIPPED:				; ...
		dec	si
		xor	cx, cx

COMTAIL:				; ...
		lodsb
		stosb
		cmp	al, 0Dh
; END OF FUNCTION CHUNK	FOR PROMPTBAT
		loopne	COMTAIL
		dec	di
		mov	bp, di
		not	cl
		mov	ds:80h,	cl
		pop	si
		mov	di, [ARGV0_ARGSW_WORD] ; [ARG+ARGV_ELE.argsw_word]
		mov	[COMSW], di
		mov	si, [ARGV1_ARGPOINTER] ; [ARG+ARGV_ELE.SIZE+ARGV_ELE.argpointer]
		or	si, si
		jnz	short DOPARSE
		mov	si, bp

DOPARSE:				; ...
		mov	di, 5Ch		; FCB
		mov	ax, 2901h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		mov	[PARM1], al
		mov	di, [ARGV1_ARGSW_WORD] ; [ARG+ARGV_ELE.SIZE+ARGV_ELE.argsw_word]
		mov	[ARG1S], di
		mov	si, [ARGV2_ARGPOINTER]
		or	si, si
		jnz	short DOPARSE2
		mov	si, bp

DOPARSE2:				; ...
		mov	di, 6Ch		; FCB+10h
		mov	ax, 2901h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		mov	[PARM2], al
		mov	di, [ARGV2_ARGSW_WORD] ; [ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argsw_word]
		mov	[DestSwitch], di
		mov	di, [ARGV0_ARGSW_WORD] ; [ARG+ARGV_ELE.argsw_word]
		not	di
		and	di, [ARG_ARGSWINFO] ; [ARG+ARG_UNIT.argswinfo]
		mov	[ARGTS], di
		mov	al, [IDLEN]
		mov	dl, [SPECDRV]
		or	dl, dl
		jnz	short EXTERNALJ1
		dec	al
		jmp	FNDCOM
; ---------------------------------------------------------------------------

EXTERNALJ1:				; ...
		jmp	EXTERNAL
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR PROMPTBAT

NULLCOM:				; ...
		mov	ds, [RESSEG]
		assume ds:RESGROUP
		test	[Batch], 0FFFFh	; -1
		jz	short NOSETFLAG
		mov	[NullFlag], 1	; only set flag	if in batch

NOSETFLAG:				; ...
		cmp	[SingleCom], 0FFFFh
		jz	short EXITJ
		jmp	GETCOM
; ---------------------------------------------------------------------------

EXITJ:					; ...
		jmp	_$EXITPREP
; END OF FUNCTION CHUNK	FOR PROMPTBAT

; =============== S U B	R O U T	I N E =======================================


proc		get_cox_y_n_opt	near	; ...
		jcxz	short ccydp4
		cmp	[byte ptr si], 0Dh
		jz	short ccydp4
		cmp	[byte ptr si], 0Ah
		jz	short ccydp4
		push	es
		mov	es, [word ptr ds:0A084h]
		assume es:nothing
		mov	al, [byte ptr es:Y_Flag]
		test	al, 10h		;  bit 1 = 1 ->	Y/N answer is needed
		jz	short ccydp3
		cmp	[es:Call_Batch_Flag], 1	; (in) Batch file ?
		jz	short ccydp3	; yes, don't check for ESCAPE
		test	al, 40h		; ESCAPE status
		jz	short ccydp5	; (bit 4 is zero if Y/N	is escaped)

ccydp1:					; ...
		test	[es:Batch], 0FFFFh
		jz	short ccydp2
		mov	es, [es:Batch]
		assume es:nothing
		mov	[byte ptr es:2], 1 ; [es:BATCHSEGMENT.BatchEOF]

ccydp2:					; ...
		stc
		pop	es
		retn
; ---------------------------------------------------------------------------

ccydp3:					; ...
		pop	es

ccydp4:					; ...
		clc
		retn
; ---------------------------------------------------------------------------

ccydp5:					; ...
		mov	dx, si
		mov	bx, 2
		mov	ah, 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		mov	dx, offset cox_Y_quest_ptr ; msg number	pointer	of ' [Y/N]?'
					; (is 1082)
		call	std_eprintf
		push	ds
		mov	ax, 1083	; cox_Y_answer number (overwrite Y/N answer letter)
		mov	dh, 0FFh	; utility_msg_class
		call	TSYSGETMSG
		mov	cx, 4E59h	; 'YN' Yes/No (CL=Y)
					; (NASM	syntax:	'YN', MASM syntax: 'NY')
		jb	short ccydp6
		mov	cx, [si]

ccydp6:					; ...
		pop	ds
		assume ds:nothing

ccydp7:					; ...
		mov	ah, 8
		int	21h		; DOS -	KEYBOARD INPUT,	NO ECHO
					; Return: AL = character
		test	al, al
		jnz	short ccydp8
		mov	ah, 8
		int	21h		; DOS -	KEYBOARD INPUT,	NO ECHO
					; Return: AL = character
		cmp	al, '?'
		jnz	short ccydp7
		or	[byte ptr es:Y_Flag], 40h ; bit	4, question flag
		jmp	short ccydp1
; ---------------------------------------------------------------------------

ccydp8:					; ...
		cmp	al, 1Bh		; ESCAPE ?
		jnz	short ccydp9
		and	[byte ptr es:Y_Flag], 0EFh ; (ESCAPE) Clear bit	4 ; ~10h
		jmp	short ccydp12
; ---------------------------------------------------------------------------

ccydp9:					; ...
		cmp	al, 41h	; 'A'
		jb	short ccydp13
		and	al, 0DFh

ccydp13:				; ...
		cmp	al, ch
		jnz	short ccydp10
		stc
		jmp	short ccydp11	; cf = 1 -> overwrite NO answer
; ---------------------------------------------------------------------------

ccydp10:				; ...
		cmp	al, cl
		jnz	short ccydp7

ccydp11:				; ...
		pushf
		mov	dl, al
		mov	ah, 2
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		popf

ccydp12:				; ...
		pushf			; cf = 0 -> overwrite YES answer
		call	CRLF2
		popf
		pop	es
		retn
endp		get_cox_y_n_opt


; =============== S U B	R O U T	I N E =======================================


proc		ROM_SCAN near		; ...
		push	es
		push	si
		push	di
		push	cx
		push	ax
		push	bx
		mov	ax, 0F000h
		mov	es, ax
		assume es:nothing
		cmp	[byte ptr es:0FFFEh], 0FDh ; check for PC Jr signature in rom
		jz	short SCAN_IT

NO_ROM:					; ...
		clc

ROM_RET:				; ...
		pop	bx
		pop	ax
		pop	cx
		pop	di
		pop	si
		pop	es
		assume es:nothing
		retn
; ---------------------------------------------------------------------------

SCAN_IT:				; ...
		mov	ax, 0C000h

SCAN_ONE:				; ...
		mov	es, ax
		assume es:nothing
		xor	di, di
		cmp	[word ptr es:di], 0AA55h
		jz	short SCAN_LIST
		add	ax, 80h

SCAN_END:				; ...
		cmp	ax, 0F000h
		jb	short SCAN_ONE
		jmp	short NO_ROM
; ---------------------------------------------------------------------------

SCAN_LIST:				; ...
		mov	bl, [es:di+2]	; [es:di+ROM_HEADER.rom_length]
		xor	bh, bh
		shl	bx, 1
		shl	bx, 1
		add	bx, 7Fh
		and	bx, 0FF80h	; round	to 2k
		mov	di, 6		; ROM_HEADER.name_list

SCAN_NAME:				; ...
		mov	cl, [es:di]	; length of name
		inc	di		; point	to name
		xor	ch, ch
		or	cx, cx
		jnz	short SCAN_TEST
		add	ax, bx
		jmp	short SCAN_END
; ---------------------------------------------------------------------------

SCAN_TEST:				; ...
		mov	si, dx
		inc	si
		repe cmpsb		; compare name
		jz	short SCAN_FOUND ; success!

SCAN_NEXT:				; ...
		add	di, cx
		add	di, 3
		jmp	short SCAN_NAME
; ---------------------------------------------------------------------------

SCAN_FOUND:				; ...
		cmp	[byte ptr si], '?'
		jz	short SCAN_SAVE
		cmp	[byte ptr si], 20h ; ' '
		jnz	short SCAN_NEXT

SCAN_SAVE:				; ...
		mov	[cs:ROM_CS], es
		mov	[cs:ROM_IP], di
		stc
		jmp	short ROM_RET
endp		ROM_SCAN

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR LoadHigh

ROM_EXEC:				; ...
		mov	bx, 0FFFFh
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		push	bx
		push	ax
		mov	ax, 2522h	; (SET_INTERRUPT_VECTOR<<8)+INT_TERMINATE
		push	ds
		mov	ds, [cs:RESSEG]
		mov	dx, 0E34h
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		mov	dx, ds
		mov	es, dx
		assume es:nothing
		pop	ds
		pop	dx
		mov	ah, 55h
		int	21h		; DOS -	2+ internal - CREATE PSP
					; DX = segment number at which to set up PSP
					; SI = (DOS 3+)	value to place in memory size field at DX:[0002h]
		mov	ds, dx
		mov	dx, 80h
		mov	ah, 1Ah
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		mov	ax, [es:543h]
		mov	[ds:2Ch], ax	; [PDB.ENVIRON]
		pop	bx
		mov	dx, ds
		add	dx, bx
		mov	[ds:2],	dx	; [PDB.BLOCK_LEN]
		mov	dx, ds
		dec	dx
		mov	ds, dx
		assume ds:nothing
		inc	dx
		mov	[ds:1],	dx	; [ARENA.owner]
		mov	ds, dx
		assume ds:nothing
		cmp	bx, 1000h
		jb	short GOT_STACK
		xor	bx, bx

GOT_STACK:				; ...
		mov	cl, 4
		shl	bx, cl
		mov	dx, ds
		mov	ss, dx
		assume ss:nothing
		mov	sp, bx
		xor	ax, ax
		push	ax
		not	ax
		push	[cs:ROM_CS]
		push	[cs:ROM_IP]
		mov	es, dx
		retf
; END OF FUNCTION CHUNK	FOR LoadHigh

; =============== S U B	R O U T	I N E =======================================


proc		int_21h_indirect near	; ...
		push	ds		; (*)
		pushf			; (**)
		push	bx
		xor	bx, bx
		mov	ds, bx		; 0
		assume ds:RESGROUP
		pop	bx
		push	cs		; simulate INT 21h
					; stack: ip, cs, flags (**)
		call	near ptr INT21h_fcall ;	call INT21h_fcall
		retn	2		; discard ds (*) on top	of stack
endp		int_21h_indirect


; =============== S U B	R O U T	I N E =======================================


proc		INT21h_fcall far	; ...
		push	[word ptr ds:86h] ; INT	21h segment
		push	[word ptr ds:84h] ; INT	21h offset
		push	bp
		mov	bp, sp
		mov	ds, [word ptr bp+12] ; DS (*) in stack
		assume ds:nothing
		push	[word ptr bp+14] ; return addr of the caller of	INT21h_fcall
		pop	[word ptr bp+12] ; return address from INT 21h
		pop	bp
		cli
		retf
endp		INT21h_fcall


; =============== S U B	R O U T	I N E =======================================


proc		int_2Fh_indirect near	; ...
		push	ds
		push	bx
		xor	bx, bx
		mov	ds, bx
		assume ds:RESGROUP
		pop	bx
		pushf
		cli
		call	[dword ptr ds:0BCh] ; call far [4*2Fh] ; INT 2Fh handler
		pop	ds
		assume ds:nothing
		retn
endp		int_2Fh_indirect


; =============== S U B	R O U T	I N E =======================================


proc		PROMPTBAT near		; ...

; FUNCTION CHUNK AT 0100 SIZE 000002AB BYTES
; FUNCTION CHUNK AT 041A SIZE 0000001E BYTES
; FUNCTION CHUNK AT 0EE9 SIZE 0000015C BYTES
; FUNCTION CHUNK AT 2600 SIZE 00000048 BYTES
; FUNCTION CHUNK AT 2C7B SIZE 00000006 BYTES
; FUNCTION CHUNK AT 3271 SIZE 00000173 BYTES

		call	BATOPEN
		jb	short PROMPTBAT1
		retn
; ---------------------------------------------------------------------------

PROMPTBAT1:				; ...
		cmp	dx, 2		; ERROR_FILE_NOT_FOUND
		jz	short BAT_REMCHECK
		cmp	dx, 3		; ERROR_PATH_NOT_FOUND
		jz	short BAT_REMCHECK
		call	output_batch_name
		jmp	short BATDIE
; ---------------------------------------------------------------------------

BAT_REMCHECK:				; ...
		call	[cs:RCH_ADDR]	; call far [cs:RCH_ADDR]
		jz	short ASKFORBAT
		call	FOROFF
		call	PipeOff
		mov	[ds:IfFlag], al
		mov	dx, offset BADBAT_PTR

BATDIE:					; ...
		call	BATCHOFF
		push	cs
		pop	ds
		assume ds:TRANGROUP
		call	std_eprintf
		jmp	TCOMMAND
; ---------------------------------------------------------------------------

ASKFORBAT:				; ...
		push	ds
		push	cs
		pop	ds
		mov	dx, offset NEEDBAT_PTR
		call	std_eprintf
		mov	dx, offset PAUSEMES_PTR
		call	std_eprintf

loc_2EC9:				; get a	keystroke and flush queue
		call	GETKEYSTROKE
		pop	ds
		assume ds:nothing

loc_2ECD:
		jmp	short PROMPTBAT
endp		PROMPTBAT


; =============== S U B	R O U T	I N E =======================================


proc		output_batch_name near	; ...
		push	ds

loc_2ED0:
		mov	ds, [ds:Batch]
		mov	si, 20h		; BATCHSEGMENT.BatFile
		call	dstrlen
		mov	di, offset BWDBUF
		rep movsb
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	[extend_buf_ptr], dx
		mov	[msg_disp_class], 1 ; ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	[string_ptr_2],	offset BWDBUF
		mov	[extend_buf_sub], 1 ; one_subst
		pop	ds
		assume ds:nothing
		retn
endp		output_batch_name


; =============== S U B	R O U T	I N E =======================================


proc		GETKEYSTROKE near	; ...
		push	dx
		mov	ax, 6302h	; (ECS_call SHL	8) OR GetInterimMode
		int	21h		; DOS -	3.2+ only - GET	KOREAN (HONGEUL) INPUT MODE
		push	dx
		mov	ax, 6301h	; (ECS_call SHL	8) OR SetInterimMode
		mov	dl, 1
		int	21h		; DOS -	3.2+ only - SET	KOREAN (HONGEUL) INPUT MODE
					; DL = new mode
					; 00h return only full characters on DOS keyboard input	functions
					; 01h return partially-formed characters also
		mov	ax, 0C08h	; (STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_no_echo
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		mov	ax, 0C00h	; (STD_CON_INPUT_FLUSH SHL 8) +	0
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		mov	ax, 6301h	; (ECS_call SHL	8) OR SetInterimMode
		pop	dx
		int	21h		; DOS -	3.2+ only - SET	KOREAN (HONGEUL) INPUT MODE
					; DL = new mode
					; 00h return only full characters on DOS keyboard input	functions
					; 01h return partially-formed characters also
		pop	dx
		retn
endp		GETKEYSTROKE


; =============== S U B	R O U T	I N E =======================================


proc		READBAT	near		; ...
		mov	[ds:Suppress], 1 ; YES_ECHO
		test	[ds:Batch_Abort], 0FFh
		jnz	short TRYING_TO_ABORT
		mov	[ds:In_Batch], 1 ; set flag to indicate	batch job
		push	ds
		mov	ds, [ds:Batch]
		cmp	[byte ptr ds:2], 0 ; [BATCHSEGMENT.BatchEOF]
		pop	ds
		jz	short CONTBAT
		call	GETBATBYT
		mov	[es:COMBUF+2], al
		call	CRLF2
		retn
; ---------------------------------------------------------------------------

CONTBAT:				; ...
		call	PROMPTBAT

TRYING_TO_ABORT:			; ...
		mov	di, (offset COMBUF+2)

TESTNOP:				; ...
		mov	ax, ds
		mov	ds, [ds:Batch]
		push	[word ptr ds:8]	; [BATCHSEGMENT.BatSeek]
		push	[word ptr ds:0Ah] ; [BATCHSEGMENT.BatSeek+2]
		mov	ds, ax
		call	SKIPDELIM
		cmp	al, 3Ah	; ':'
		pop	cx
		pop	dx
		jz	short NOPLINE
		test	[ds:Batch], 0FFFFh
		jz	short RDBAT
		cmp	al, 40h	; '@'   ; No_Echo_Char
		jnz	short SET_BAT_POS
		mov	[ds:Suppress], 0 ; NO_ECHO
		jmp	short RDBAT
; ---------------------------------------------------------------------------

SET_BAT_POS:				; ...
		push	ds
		mov	ds, [ds:Batch]
		mov	[ds:8],	dx	; [BATCHSEGMENT.BatSeek]
		mov	[ds:0Ah], cx	; [BATCHSEGMENT.BatSeek+2]
		pop	ds
		mov	ax, 4200h	; (LSEEK*256) ;	seek back
		call	int_21h_indirect
		mov	[es:BATBUFPOS],	0FFFFh ; -1
		xor	cx, cx
		jmp	short RDBAT
; ---------------------------------------------------------------------------

NOPLINE:				; ...
		call	SKIPTOEOL
		call	GETBATBYT
		test	[ds:Batch], 0FFFFh
		jnz	short TESTNOP

READBAT_RETN:				; ...
		retn
; ---------------------------------------------------------------------------

RDBAT:					; ...
		call	GETBATBYT
		inc	cx
		call	testkanj
		jz	short RDBAT1
		cmp	cx, 127		; COMBUFLEN-1
		jnb	short TOOLONG
		stosb
		call	GETBATBYT
		inc	cx
		jmp	short SAVBATBYT
; ---------------------------------------------------------------------------

RDBAT1:					; ...
		cmp	cx, 128		; COMBUFLEN
		jnb	short TOOLONG
		cmp	al, 25h	; '%'
		jz	short NEEDPARM

SAVBATBYT:				; ...
		stosb
		cmp	al, 0Dh
		jnz	short RDBAT

FOUND_EOL:				; ...
		sub	di, (offset COMBUF+3)
		mov	ax, di
		mov	[es:COMBUF+1], al ; Set	length of line
		call	GETBATBYT	; Eat linefeed
		call	BATCLOSE
		cmp	[ds:Suppress], 0 ; NO_ECHO
		jz	short RESET
		test	[ds:EchoFlag], 1
		jnz	short TRY_NEXTFLAG

RESET:					; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		jz	short READBAT_RETN

TRY_NEXTFLAG:				; ...
		cmp	[ds:NullFlag], 1 ; nullcommand
		jz	short NO_CRLF_PRINT
		call	CRLF2

NO_CRLF_PRINT:				; ...
		call	PRINT_PROMPT
		push	cs
		pop	ds
		mov	dx, (offset COMBUF+2)
		call	CRPRINT
		call	CRLF2
		retn
; ---------------------------------------------------------------------------

TOOLONG:				; ...
		cmp	al, 0Dh
		jz	short LTLCONT
		call	SKIPTOEOL

LTLCONT:				; ...
		stosb
		jmp	short FOUND_EOL
; ---------------------------------------------------------------------------

NEEDPARM:				; ...
		call	GETBATBYT
		cmp	al, 25h	; '%'
		jz	short SAVBATBYT
		cmp	al, 0Dh
		jz	short SAVBATBYT
		sub	al, 30h	; '0'
		jb	short NEEDENV
		cmp	al, 9
		ja	short NEEDENV
		cbw
		mov	bx, ax
		shl	bx, 1
		push	es
		mov	es, [ds:Batch]
		mov	si, [es:bx+0Ch]	; [es:bx+BATCHSEGMENT.BatParm]
		pop	es
		cmp	si, 0FFFFh
		jnz	short YES_THERE_IS
		jmp	RDBAT
; ---------------------------------------------------------------------------

YES_THERE_IS:				; ...
		push	ds
		mov	ds, [ds:Batch]
		assume ds:nothing
		dec	cx

COPYPARM:				; ...
		lodsb
		cmp	al, 0Dh
		jz	short ENDPARAM
		inc	cx
		cmp	cx, 128		; COMBUFLEN
		jnb	short LINETOOL
		stosb
		jmp	short COPYPARM
; ---------------------------------------------------------------------------

LINETOOL:				; ...
		xor	al, al
		pop	ds
		jmp	short TOOLONG
; ---------------------------------------------------------------------------

ENDPARAM:				; ...
		pop	ds
		jmp	RDBAT
; ---------------------------------------------------------------------------

NEEDENV:				; ...
		dec	cx
		push	ds
		push	di
		mov	di, offset ID
		add	al, '0'
		stosb

GETENV1:				; ...
		call	GETBATBYT
		stosb
		cmp	al, 0Dh
		jnz	short GETENV15
		mov	[byte ptr es:di-1], 0
		mov	si, offset ID
		pop	di
		push	cs
		pop	ds
		assume ds:TRANGROUP
		call	STRCPY
		jb	short LINETOOL
		pop	ds
		assume ds:nothing
		jmp	SAVBATBYT
; ---------------------------------------------------------------------------

GETENV15:				; ...
		cmp	al, 25h	; '%'
		jnz	short GETENV1
		mov	al, 3Dh	; '='
		mov	[es:di-1], al
		mov	si, offset ID
		push	cs
		pop	ds
		assume ds:TRANGROUP
		push	cx
		call	find_name_in_environment
		pop	cx
		push	es
		pop	ds
		assume ds:nothing
		push	cs
		pop	es
		assume es:TRANGROUP
		mov	si, di
		pop	di
		jb	short GETENV6
		call	STRCPY

GETENV6:				; ...
		pop	ds
		jmp	RDBAT
endp		READBAT


; =============== S U B	R O U T	I N E =======================================


proc		SKIPTOEOL near		; ...
		test	[ds:Batch], 0FFFFh ; read from batch file until	end of line
		jnz	short SKIPTOEOL1
		retn
; ---------------------------------------------------------------------------

SKIPTOEOL1:				; ...
		call	GETBATBYT
		cmp	al, 0Dh
		jnz	short SKIPTOEOL
		retn
endp		SKIPTOEOL


; =============== S U B	R O U T	I N E =======================================


proc		FREE_TPA near		; ...
		push	es
		mov	es, [ds:RESSEG]
		assume es:nothing
		mov	es, [es:Res_Tpa]
		mov	ah, 49h		; DEALLOC
		call	int_21h_indirect
		pop	es
		retn
endp		FREE_TPA


; =============== S U B	R O U T	I N E =======================================


proc		ALLOC_TPA near		; ...
		push	es
		mov	es, [ds:RESSEG]
		assume es:RESGROUP
		mov	bx, 0FFFFh
		mov	ah, 48h		; ALLOC
		call	int_21h_indirect ; indirect call to INT	21h handler
					; (by simulating INT 21h interrupt)
		push	bx
		mov	ah, 48h
		call	int_21h_indirect
		pop	bx
		mov	[es:Res_Tpa], ax
		mov	[ds:TRAN_TPA], ax
		mov	dx, ax
		and	ax, 0FFFh
		jnz	short CALC_TPA
		mov	ax, dx
		and	ax, 0F000h
		jnz	short NOROUND

CALC_TPA:				; ...
		mov	ax, dx
		and	ax, 0F000h
		add	ax, 1000h
		jb	short NOROUND
		mov	dx, [es:Res_Tpa]
		add	dx, bx
		cmp	dx, ax
		jb	short NOROUND
		mov	bx, cs
		cmp	bx, ax
		jb	short NOROUND
		sub	bx, ax
		cmp	bx, 1000h
		jnb	short ROUNDDONE

NOROUND:				; ...
		mov	ax, [es:Res_Tpa]

ROUNDDONE:				; ...
		mov	[es:Ltpa], ax
		mov	[ds:TPA], ax
		mov	bx, ax
		mov	ax, cs
		sub	ax, bx
		push	bx
		mov	bx, 16
		mul	bx
		pop	bx
		or	dx, dx
		jz	short SAVSIZ2
		mov	ax, 0FFFFh	; -1

SAVSIZ2:				; ...
		cmp	ax, 512
		jbe	short GOTSIZE2
		and	ax, 0FE00h	; ~1FFh	; NOT 511

GOTSIZE2:				; ...
		mov	[ds:BYTCNT], ax
		pop	es
		assume es:nothing
		retn
endp		ALLOC_TPA

; ---------------------------------------------------------------------------

BATCOM:					; ...
		mov	es, [ds:RESSEG]
		assume es:RESGROUP
		cmp	[es:Call_Batch_Flag], 1	; call_in_progress
		jz	short skip_ioset
		call	IOSET

skip_ioset:				; ...
		call	FREE_TPA
		cmp	[es:Call_Batch_Flag], 1
		jz	short GETECHO
		call	FOROFF

GETECHO:				; ...
		call	PipeOff
		mov	al, [es:EchoFlag]
		and	al, 1
		push	ax
		xor	ax, ax
		test	[es:Batch], 0FFFFh
		jz	short LEAVEBAT
		mov	ax, [es:Batch]
		cmp	[es:Call_Batch_Flag], 1	; call_in_progress
		jz	short LEAVEBAT
		push	es
		mov	es, ax
		assume es:nothing
		mov	ax, [es:3]	; [es:BATCHSEGMENT.BatLast]
		pop	es

LEAVEBAT:				; ...
		push	ax
		cmp	[es:Call_Batch_Flag], 1
		jz	short STARTBAT
		call	BATCHOFF

STARTBAT:				; ...
		mov	[es:Call_Batch_Flag], 0
		mov	si, offset EXECPATH
		mov	ax, 0B711h	; AppendTruename
		int	2Fh		; - Multiplex -	DOS 4.0	APPEND - SET RETURN FOUND NAME STATE
		mov	ah, 4Eh		; Find_First
		mov	dx, si
		mov	cx, 13h		; search_attr
		call	int_21h_indirect
		call	dstrlen
		mov	bx, cx
		add	bx, 191		; 15+BATCHSEGMENT.SIZE+COMBUFLEN+15
		push	cx
		mov	cl, 4
		shr	bx, cl
		push	bx
		mov	ah, 48h		; ALLOC
		call	int_21h_indirect
		pop	bx
		jb	short MEM_ERROR
		push	ax
		add	ax, bx
		add	ax, 20h
		mov	bx, cs
		mov	dx, 0AA9Ah	; TRANSPACEEND
		add	dx, 0Fh		; TRANSPACEEND+15
		shr	dx, cl
		add	dx, bx
		cmp	ax, bx
		jb	short ENOUGH_MEM
		cmp	ax, dx
		ja	short ENOUGH_MEM
		pop	ax
		push	es
		mov	es, ax
		mov	ax, 4900h	; DEALLOC*256
					; deallocate the batch segment
		call	int_21h_indirect
		pop	es

MEM_ERROR:				; ...
		jmp	NO_MEMORY
; ---------------------------------------------------------------------------

ENOUGH_MEM:				; ...
		pop	ax
		mov	[es:Batch], ax
		call	ALLOC_TPA
		pop	dx
		pop	ax
		inc	[es:Nest]
		push	es
		mov	es, [es:Batch]
		mov	[byte ptr es:0], 0 ; [es:BATCHSEGMENT.BatType],BATCHTYPE
		mov	[es:3],	ax	; [es:BATCHSEGMENT.BatLast]
		push	ds
		mov	ds, [ds:RESSEG]
		assume ds:RESGROUP
		xor	ax, ax
		mov	bl, [ForFlag]
		mov	[es:7],	bl	; [es:BATCHSEGMENT.BatForFlag]
		test	bl, 0FFh
		jz	short FOR_NOT_ON
		mov	ax, [ForPtr]
		mov	[ForFlag], 0	; byte

FOR_NOT_ON:				; ...
		mov	[es:5],	ax	; [es:BATCHSEGMENT.BatForPtr]
		xor	ax, ax
		mov	[ForPtr], ax
		mov	bl, [EchoFlag]
		pop	ds
		assume ds:nothing
		mov	[es:1],	bl	; [es:BATCHSEGMENT.BatEchoFlag]
		mov	[byte ptr es:2], 0 ; [es:BATCHSEGMENT.BatchEOF]
		mov	[es:8],	ax	; [es:BATCHSEGMENT.BatSeek]
		mov	[es:0Ah], ax	; [es:BATCHSEGMENT.BatSeek+2]
		dec	ax
		mov	di, 12		; BATCHSEGMENT.BatParm
		mov	bx, di
		mov	cx, 10
		rep stosw
		mov	cx, dx
		rep movsb
		mov	si, (offset COMBUF+2)
		mov	cx, 10

EACHPARM:				; ...
		call	scanoff
		cmp	al, 0Dh
		jz	short HAVPARM
		jcxz	short MOVPARM
		mov	[es:bx], di
		add	bx, 2

MOVPARM:				; ...
		lodsb
		call	DELIM
		jz	short ENDPARM
		stosb
		cmp	al, 0Dh
		jz	short HAVPARM
		jmp	short MOVPARM
; ---------------------------------------------------------------------------

ENDPARM:				; ...
		mov	al, 0Dh
		stosb
		jcxz	short EACHPARM
		dec	cx
		jmp	short EACHPARM
; ---------------------------------------------------------------------------

HAVPARM:				; ...
		xor	al, al
		stosb
		lea	bx, [di+15]
		mov	cl, 4
		shr	bx, cl
		mov	ah, 4Ah		; SETBLOCK
		call	int_21h_indirect ; ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs
		pop	es
		push	es
		pop	ds
		cmp	[ds:SingleCom],	0FFFFh
		jnz	short NOBATSING
		mov	[ds:SingleCom],	0FFF0h ; Flag single command BATCH job

NOBATSING:				; ...
		pop	ax
		mov	[ds:EchoFlag], al
		jmp	TCOMMAND
; ---------------------------------------------------------------------------

NO_MEMORY:				; ...
		pop	dx
		pop	ax
		pop	ax
		call	ALLOC_TPA
		mov	[ds:msg_disp_class], 1 ; ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	[ds:extend_buf_ptr], 8 ; ERROR_NOT_ENOUGH_MEMORY
		jmp	cerror

; =============== S U B	R O U T	I N E =======================================


proc		BATCHOFF near		; ...
		push	ax
		push	es
		push	ds
		push	bx
		mov	es, [cs:RESSEG]
		assume es:RESGROUP
		mov	ds, [cs:RESSEG]
		assume ds:RESGROUP
		mov	ax, [Batch]
		or	ax, ax
		jz	short NOTFREE
		push	es
		mov	es, ax
		assume es:nothing
		test	[EchoFlag], 1
		jnz	short ECHO_LAST_LINE
		mov	[Suppress], 0	; NO_ECHO

ECHO_LAST_LINE:				; ...
		mov	bl, [es:1]	; [es:BATCHSEGMENT.BatEchoFlag]
		mov	[EchoFlag], bl
		mov	bx, [es:5]	; [es:BATCHSEGMENT.BatForPtr]
		mov	[ForPtr], bx
		mov	bl, [es:7]	; [es:BATCHSEGMENT.BatForFlag]
		mov	[ForFlag], bl
		mov	bx, [es:3]	; [es:BATCHSEGMENT.BatLast]
		mov	ah, 49h		; DEALLOC
		call	int_21h_indirect ; FREE	MEMORY
					; ES = segment address of area to be freed
		pop	es
		mov	[Next_Batch], bx
		dec	[es:Nest]
		xor	ax, ax
		mov	[Batch], ax

NOTFREE:				; ...
		pop	bx
		pop	ds
		assume ds:nothing
		pop	es
		pop	ax
		retn
endp		BATCHOFF


; =============== S U B	R O U T	I N E =======================================


proc		STRCPY near		; ...
		push	ax

ccycle:					; ...
		lodsb
		inc	cx
		cmp	cx, 128		; COMBUFLEN
		jb	short ccopy
		stc
		jmp	short ccend
; ---------------------------------------------------------------------------

ccopy:					; ...
		stosb
		or	al, al
		jnz	short ccycle

ccend:					; ...
		dec	cx
		dec	di
		pop	ax
		retn
endp		STRCPY


; =============== S U B	R O U T	I N E =======================================


proc		GETBATBYT near		; ...
		push	bx
		push	cx
		push	ds
		test	[ds:Batch_Abort], 0FFh
		jz	short getbatbyt1
		jmp	BATEOF
; ---------------------------------------------------------------------------

getbatbyt1:				; ...
		test	[ds:Batch], 0FFFFh
		jnz	short getbatbyt2
		jmp	BATEOF
; ---------------------------------------------------------------------------

getbatbyt2:				; ...
		push	es
		mov	es, [ds:Batch]
		cmp	[byte ptr es:2], 0 ; [es:BATCHSEGMENT.BatchEOF]
		jz	short not_eof
		jmp	At_EOF
; ---------------------------------------------------------------------------

not_eof:				; ...
		add	[word ptr es:8], 1 ; [es:BATCHSEGMENT.BatSeek]
		adc	[word ptr es:0Ah], 0 ; [es:BATCHSEGMENT.BatSeek+2]
		pop	es
		mov	ax, cs
		mov	ds, ax
		assume ds:TRANGROUP
		mov	bx, [BATBUFPOS]
		cmp	bx, 0FFFFh
		jnz	short UNBUF
		mov	dx, offset BATBUF
		mov	cx, [BATBUFLEN]
		mov	bx, [BATHAND]
		mov	ah, 3Fh		; READ
		call	int_21h_indirect
		jnb	short bat_read_ok
		call	get_ext_error_number
		push	ds
		mov	ds, [RESSEG]
		assume ds:RESGROUP
		mov	dx, ax
		call	output_batch_name
		pop	ds
		assume ds:nothing
		call	std_eprintf
		mov	[ds:COMBUF+2], 0Dh ; END_OF_LINE_IN
		mov	[ds:COMBUF+3], 0 ; END_OF_LINE_OUT
		mov	ds, [ds:RESSEG]
		jmp	short BATEOF
; ---------------------------------------------------------------------------

bat_read_ok:				; ...
		mov	cx, ax
		jcxz	short BATEOFDS
		mov	[ds:BATBUFEND],	cx
		xor	bx, bx
		mov	[ds:BATBUFPOS],	bx

UNBUF:					; ...
		mov	al, [ds:BATBUF+bx]
		inc	bx
		cmp	bx, [ds:BATBUFEND] ; beyond end	of buffer?
		jb	short SETBUFPOS
		mov	bx, 0FFFFh	; -1

SETBUFPOS:				; ...
		mov	[ds:BATBUFPOS],	bx
		cmp	al, 1Ah		; ^Z for termination
		jnz	short GETBYTEDONE

BATEOFDS:				; ...
		push	es
		mov	es, [ds:RESSEG]
		mov	es, [es:Batch]
		cmp	[byte ptr es:2], 0 ; [es:BATCHSEGMENT.BatchEOF]
		jnz	short crpresent
		inc	[byte ptr es:2]	; [es:BATCHSEGMENT.BatchEOF]
		mov	bx, [ds:0AA78h]
		cmp	[byte ptr ds:(BATBUFPOS+1)+bx],	0Ah ; [bx+BATBUF-1],0Ah
					; was a	LF present?
		jz	short crpresent	; yes, no need to fake it
		add	[byte ptr es:2], 3 ; add byte [es:BATCHSEGMENT.BatchEOF],3
					; BatchEOF == 4	to fake	CR-LF

crpresent:				; ...
		mov	ds, [ds:RESSEG]

At_EOF:					; ...
		shr	[byte ptr es:2], 1 ; [es:BATCHSEGMENT.BatchEOF]
		jz	short turn_off	; zero,turn batch off
		cmp	[byte ptr es:2], 1 ; [es:BATCHSEGMENT.BatchEOF]
					; BatchEOF was 2, return LF
		jz	short ret_lf
		mov	al, 0Dh		; return fake CR
		pop	es
		jmp	short GETBYTEDONE
; ---------------------------------------------------------------------------

ret_lf:					; ...
		mov	al, 0Ah		; return fake LF
		pop	es
		jmp	short GETBYTEDONE
; ---------------------------------------------------------------------------

turn_off:				; ...
		pop	es

BATEOF:					; ...
		call	BATCHOFF
		call	BATCLOSE
		mov	al, 0Dh		; If end-of-file, then end of line
		test	[ds:Batch_Abort], 0FFh
		mov	[ds:Batch_Abort], 0
		jz	short CONT_GET_BYT
		mov	di, (offset COMBUF+2)
		xor	cx, cx
		jmp	short GETBYTEDONE
; ---------------------------------------------------------------------------

CONT_GET_BYT:				; ...
		cmp	[ds:SingleCom],	0FFF0h
		jnz	short GETBYTEDONE
		cmp	[ds:Nest], 0
		jnz	short GETBYTEDONE
		mov	[ds:SingleCom],	0FFFFh

GETBYTEDONE:				; ...
		pop	ds
		pop	cx
		pop	bx
		retn
endp		GETBATBYT

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR _$IF

IFERRORP:				; ...
		pop	ax

IFERROR:				; ...
		mov	dx, offset SYNTMES_PTR
		jmp	cerror
; END OF FUNCTION CHUNK	FOR _$IF

; =============== S U B	R O U T	I N E =======================================


proc		_$IF near		; ...

; FUNCTION CHUNK AT 0BA7 SIZE 00000007 BYTES

		push	ds
		mov	ds, [ds:RESSEG]
		cmp	[ds:PipeFiles],	0
		jz	short IFNoPipe
		call	PIPEDEL

IFNoPipe:				; ...
		pop	ds
		mov	[ds:IFNOTFLAG],	0
		mov	[ds:IF_NOT_COUNT], 0
		mov	si, 81h

IFREENT:				; ...
		call	scanoff
		cmp	al, 0Dh
		jz	short IFERROR
		mov	bp, si
		mov	di, offset IFTAB ; "\x03NOT"
		mov	ch, 0

IFINDCOM:				; ...
		mov	si, bp
		mov	cl, [di]
		inc	di
		jcxz	short IFSTRING
		jmp	short FIRSTCOMP
; ---------------------------------------------------------------------------

IFCOMP:					; ...
		jnz	short IF_DIF

FIRSTCOMP:				; ...
		lodsb
		mov	ah, [es:di]
		inc	di
		cmp	al, ah
		jz	short IFLP
		or	ah, 20h
		cmp	al, ah

IFLP:					; ...
		loop	IFCOMP

IF_DIF:					; ...
		lahf
		add	di, cx
		mov	bx, [di]
		inc	di
		inc	di
		sahf
		jnz	short IFINDCOM
		lodsb
		cmp	al, 0Dh

IFERRJ:					; ...
		jz	short IFERROR
		call	DELIM
		jnz	short IFINDCOM
		call	scanoff
		jmp	bx
; ---------------------------------------------------------------------------

IFNOT:					; ...
		not	[ds:IFNOTFLAG]	; byte
		inc	[ds:IF_NOT_COUNT] ; word
		jmp	short IFREENT
; ---------------------------------------------------------------------------

IFSTRING:				; ...
		push	si
		xor	cx, cx

FIRST_STRING:				; ...
		lodsb
		cmp	al, 0Dh
		jz	short IFERRORP
		call	DELIM
		jz	short EQUAL_CHECK
		inc	cx
		jmp	short FIRST_STRING
; ---------------------------------------------------------------------------

EQUAL_CHECK:				; ...
		cmp	al, 3Dh	; '='
		jz	short EQUAL_CHECK2
		cmp	al, 0Dh
		jz	short IFERRPJ
		lodsb
		jmp	short EQUAL_CHECK
; ---------------------------------------------------------------------------

EQUAL_CHECK2:				; ...
		lodsb
		cmp	al, 3Dh	; '='
		jnz	short IFERRPJ
		call	scanoff
		cmp	al, 0Dh
		jz	short IFERRPJ
		pop	di
		repe cmpsb
		jz	short MATCH
		dec	si
		cmp	[byte ptr si], 0Dh
		jz	short IFERRJ

SKIPSTRINGEND:				; ...
		lodsb

NOTMATCH:				; ...
		cmp	al, 0Dh

IFERRORJ2:				; ...
		jz	short IFERRJ
		call	DELIM
		jnz	short SKIPSTRINGEND
		mov	al, 0FFh	; -1
		jmp	short IFRET
; ---------------------------------------------------------------------------

IFERRPJ:				; ...
		jmp	IFERRORP
; ---------------------------------------------------------------------------

MATCH:					; ...
		lodsb
		call	DELIM
		jnz	short NOTMATCH
		xor	al, al
		jmp	short IFRET
; ---------------------------------------------------------------------------

IFEXISTS:				; ...
		lodsb
		call	DELIM
		jnz	short IFEXISTS
		mov	dx, offset BWDBUF ; DIRBUF
		mov	ax, 1A00h
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		mov	bx, 2
		add	bx, [ds:IF_NOT_COUNT]
		mov	ax, offset ARG_ARGV ; ARG+ARG_UNIT.argv	; ARG
		call	argv_calc
		mov	dx, [bx]
		mov	cx, 6		; IFEXIST_ATTR
		mov	ax, 4E00h
		int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
					; CX = search attributes
					; DS:DX	-> ASCIZ filespec
					; (drive, path,	and wildcards allowed)
		jb	short IF_EX_C
		xor	al, al
		jmp	short IFRET
; ---------------------------------------------------------------------------

IF_EX_C:				; ...
		mov	al, 0FFh

IFRET:					; ...
		test	[ds:IFNOTFLAG],	0FFh
		jz	short REALTEST
		not	al

REALTEST:				; ...
		or	al, al
		jz	short IFTRUE
		jmp	TCOMMAND
; ---------------------------------------------------------------------------

IFTRUE:					; ...
		call	scanoff
		mov	cx, si
		sub	cx, 81h
		sub	[ds:80h], cl
		mov	cl, [ds:80h]
		mov	[ds:COMBUF+1], cl
		mov	di, (offset COMBUF+2)
		cld
		rep movsb
		mov	al, 0Dh
		stosb
		push	ds
		mov	ds, [ds:RESSEG]
		mov	[ds:IfFlag], 0FFh ; -1
		pop	ds
		jmp	DOCOM0
endp		_$IF

; ---------------------------------------------------------------------------

IFERRORJ3:				; ...
		jmp	IFERRORJ2
; ---------------------------------------------------------------------------

IFERLEV:				; ...
		cmp	[byte ptr si], 0F2h
		jnz	short IFERLEV_@
		inc	si

IFERLEV_@:				; ...
		mov	bh, 10
		xor	bl, bl

GETNUMLP:				; ...
		lodsb
		cmp	al, 0Dh
		jz	short IFERRORJ3
		call	DELIM
		jz	short GOTNUM
		sub	al, 30h	; '0'
		xchg	al, bl
		mul	bh
		add	al, bl
		xchg	al, bl
		jmp	short GETNUMLP
; ---------------------------------------------------------------------------

GOTNUM:					; ...
		push	ds
		mov	ds, [ds:RESSEG]
		mov	ah, [byte ptr ds:RetCode]
		pop	ds
		xor	al, al
		cmp	ah, bl
		jnb	short IFRET
		dec	al
		jmp	short IFRET
; ---------------------------------------------------------------------------

_SHIFT:					; ...
		mov	ds, [ds:RESSEG]
		mov	ax, [ds:Batch]
		or	ax, ax
		jnz	short SHIFT1

SHIFT_RETN:				; ...
		retn
; ---------------------------------------------------------------------------

SHIFT1:					; ...
		mov	es, ax
		mov	ds, ax
		mov	di, 0Ch		; BATCHSEGMENT.BatParm
		lea	si, [di+2]
		mov	cx, 9
		rep movsw
		cmp	[word ptr di], 0FFFFh
		jz	short SHIFT_RETN
		mov	si, [di]
		mov	[word ptr di], 0FFFFh

SKIPCRLP:				; ...
		lodsb
		cmp	al, 0Dh
		jnz	short SKIPCRLP
		cmp	[byte ptr si], 0
		jz	short SHIFT_RETN
		mov	[di], si
		retn

; =============== S U B	R O U T	I N E =======================================


proc		SKIPDELIM near		; ...
		test	[ds:Batch], 0FFFFh
		jz	short SKIPERR
		call	GETBATBYT
		call	DELIM
		jz	short SKIPDELIM
		clc
		retn
; ---------------------------------------------------------------------------

SKIPERR:				; ...
		stc

GOTO_RETN:				; ...
		retn
endp		SKIPDELIM

; ---------------------------------------------------------------------------

_$CALL:					; ...
		push	si
		push	di
		push	ax
		push	cx
		mov	si, (offset COMBUF+2)
		call	scanoff
		add	si, 4
		mov	di, (offset COMBUF+2)
		mov	cx, 124		; COMBUFLEN-length_call
		rep movsb
		pop	cx
		pop	ax
		pop	di
		pop	si
		push	ds
		mov	ds, [ds:RESSEG]
		mov	[ds:Call_Flag],	1 ; call_in_progress
		mov	[ds:Call_Batch_Flag], 1	; call_in_progress
		cmp	[ds:PipeFiles],	0
		jz	short _NOPIPE
		call	PIPEDEL

_NOPIPE:				; ...
		pop	ds
		retn
; ---------------------------------------------------------------------------

_GOTO:					; ...
		mov	ds, [ds:RESSEG]
		test	[ds:Batch], 0FFFFh
		jz	short GOTO_RETN
		xor	dx, dx
		push	ds
		mov	ds, [ds:Batch]
		mov	[ds:8],	dx	; [BATCHSEGMENT.BatSeek]
		mov	[ds:0Ah], dx	; [BATCHSEGMENT.BatSeek+2]
		mov	[byte ptr ds:2], 0 ; [BATCHSEGMENT.BatchEOF]
		pop	ds
		call	PROMPTBAT
		mov	di, 5Dh		; FCB+1
		mov	cx, 11
		mov	al, 20h		; space
		repne scasb
		jnz	short NOINC
		inc	cx

NOINC:					; ...
		sub	cx, 11
		neg	cx
		mov	[word ptr es:BWDBUF], cx ; word	[es:GOTOLEN]
		call	SKIPDELIM
		jb	short BADGOTO
		cmp	al, ':'
		jz	short CHKLABEL

LABLKLP:				; ...
		call	GETBATBYT
		cmp	al, 0Ah
		jnz	short LABLKTST
		call	SKIPDELIM
		jb	short BADGOTO
		cmp	al, 3Ah	; ':'
		jz	short CHKLABEL

LABLKTST:				; ...
		test	[ds:Batch], 0FFFFh
		jnz	short LABLKLP

BADGOTO:				; ...
		call	BATCLOSE
		call	free_batch
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	dx, offset BADLAB_PTR
		jmp	cerror
; ---------------------------------------------------------------------------

CHKLABEL:				; ...
		call	SKIPDELIM
		jb	short BADGOTO
		mov	di, 5Dh		; FCB+1
		mov	cx, [word ptr es:BWDBUF] ; [es:GOTOLEN]
		jmp	short GOTBYTE
; ---------------------------------------------------------------------------

NEXTCHRLP:				; ...
		push	cx
		call	GETBATBYT
		pop	cx

GOTBYTE:				; ...
		call	testkanj
		jz	short NOTKANJ1
		cmp	al, [es:di]
		jnz	short LABLKTST
		inc	di
		dec	cx
		jcxz	short LABLKTST
		push	cx
		call	GETBATBYT
		pop	cx
		cmp	al, [es:di]
		jmp	short KNEXTLABCHR
; ---------------------------------------------------------------------------

NOTKANJ1:				; ...
		or	al, 20h
		cmp	al, [es:di]
		jnz	short TRYUPPER
		jmp	short NEXTLABCHR
; ---------------------------------------------------------------------------

TRYUPPER:				; ...
		sub	al, 20h
		cmp	al, [es:di]

KNEXTLABCHR:				; ...
		jnz	short LABLKTST

NEXTLABCHR:				; ...
		inc	di
		loop	NEXTCHRLP
		call	GETBATBYT
		cmp	[word ptr es:BWDBUF], 8	; [es:GOTOLEN]
		jge	short GOTOCONT
		cmp	al, 20h	; ' '
		ja	short LABLKTST

GOTOCONT:				; ...
		cmp	al, 0Dh
		jz	short SKIPLFEED

TONEXTBATLIN:				; ...
		call	GETBATBYT
		cmp	al, 0Dh
		jnz	short TONEXTBATLIN

SKIPLFEED:				; ...
		call	GETBATBYT
		push	es
		mov	es, [ds:Batch]
		mov	[byte ptr es:2], 0 ; [es:BATCHSEGMENT.BatchEOF]
		pop	es
		call	BATCLOSE
		retn

; =============== S U B	R O U T	I N E =======================================


proc		BATCLOSE near		; ...
		mov	bx, [cs:BATHAND]
		cmp	bx, 5
		jb	short CLOSERETURN
		mov	ah, 3Eh		; CLOSE
		call	int_21h_indirect

CLOSERETURN:				; ...
		mov	[ds:In_Batch], 0
		retn
endp		BATCLOSE


; =============== S U B	R O U T	I N E =======================================


proc		BATOPEN	near		; ...
		push	ds
		mov	ds, [ds:Batch]
		assume ds:nothing
		mov	dx, 20h	; ' '   ; BATCHSEGMENT.BatFile
		mov	ax, 3D20h
		call	int_21h_indirect
		jb	short SETERRDL
		mov	dx, [ds:8]	; [BATCHSEGMENT.BatSeek]
		mov	cx, [ds:0Ah]	; [BATCHSEGMENT.BatSeek+2]
		pop	ds
		mov	[es:BATHAND], ax
		mov	bx, ax
		mov	ax, 4200h	; (LSEEK<<8)
		call	int_21h_indirect
		mov	[es:BATBUFPOS],	0FFFFh
		retn
; ---------------------------------------------------------------------------

SETERRDL:				; ...
		mov	bx, dx
		call	get_ext_error_number
		mov	dx, ax
		mov	al, [bx]
		sub	al, 40h	; '@'   ; A = 1, B = 2 ..
		pop	ds
		stc
		retn
endp		BATOPEN


; =============== S U B	R O U T	I N E =======================================


proc		free_batch near		; ...
		push	es
		mov	bx, [ds:Next_Batch]
		or	bx, bx
		jz	short fb_ret

_ClearBatch:				; ...
		mov	es, bx
		mov	bx, [es:5]	; [es:BATCHSEGMENT.BatForPtr]
		cmp	bx, 0		; is a FOR in progress ?
		jz	short no_bat_for ; no -	don't deallocate
		push	es
		mov	es, bx
		mov	ah, 49h		; DEALLOC
		call	int_21h_indirect
		pop	es

no_bat_for:				; ...
		mov	cl, [es:1]	; [es:BATCHSEGMENT.BatEchoFlag]
		mov	bx, [es:3]	; [es:BATCHSEGMENT.BatLast]
		mov	ah, 49h		; DEALLOC
		call	int_21h_indirect
		mov	[ds:Batch], bx
		dec	[ds:Nest]	; word
		jnz	short _ClearBatch
		mov	[ds:EchoFlag], cl
		mov	[ds:Batch], 0

fb_ret:					; ...
		pop	es
		retn
endp		free_batch

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR PROMPTBAT

FORTERM:				; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		push	cs
		pop	es
		assume es:TRANGROUP
		call	FOROFF
		mov	ds, [es:RESSEG]
		assume ds:RESGROUP
		cmp	[SingleCom], 0FF00h
		jnz	short BAT_CRLF
		cmp	[Nest],	0	; word
		jnz	short BAT_CRLF
		mov	[SingleCom], 0FFFFh ; -1
		jmp	short NOFORP2
; ---------------------------------------------------------------------------

BAT_CRLF:				; ...
		test	[EchoFlag], 1	; byte
		jz	short NOFORP2
		test	[Batch], 0FFFFh	; -1
		jz	short NOFORP2
		call	CRLF2

NOFORP2:				; ...
		jmp	TCOMMAND
; ---------------------------------------------------------------------------

_$FOR_EXIT:				; ...
		jmp	short FORTERM
; ---------------------------------------------------------------------------

FORPROC:				; ...
		mov	ax, [ForPtr]
		mov	ds, ax
		assume ds:nothing
		mov	es, ax
		assume es:nothing
		mov	dx, 4CBh	; offset FOR_INFO.FORDMA
		mov	ax, 1A00h
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer

FOR_BEGIN:				; ...
		cmp	[word ptr ds:445h], 0 ;	[FOR_INFO.FOR_EXPAND]
		jz	short FOR_BEGIN1
		inc	[word ptr ds:447h] ; [FOR_INFO.FOR_MINARG]

FOR_BEGIN1:				; ...
		mov	bx, [ds:447h]	; [FOR_INFO.FOR_MINARG]
		cmp	bx, [ds:449h]	; [FOR_INFO.FOR_MAXARG]
		jg	short _$FOR_EXIT
		mov	ax, 0
		call	argv_calc
		mov	cx, [bx+3]	; [bx+ARGV_ELE.argstartel]
		mov	dx, [bx]
		test	[byte ptr bx+2], 4 ; [bx+ARGV_ELE.argflags],4 ;	path_sep
		jnz	short FORSUB
		mov	si, [bx]	; [bx+ARGV_ELE.argpointer]
		mov	al, 28h	; '('
		cmp	[si-1],	al
		jnz	short FORSUB
		inc	cx
		mov	al, 3Ah	; ':'
		cmp	[si+1],	al
		jnz	short FORSUB
		add	cx, 2

FORSUB:					; ...
		sub	cx, dx
		cmp	[word ptr ds:445h], 0 ;	[FOR_INFO.FOR_EXPAND]
		jz	short FOR_FIND_NEXT
		test	[byte ptr bx+2], 2 ; [bx+ARGV_ELE.argflags],2 ;	wildcard
		jnz	short FOR_FIND_FIRST
		mov	cx, [bx+5]	; [bx+ARGV_ELE.arglen]
		jmp	short FOR_SMOOSH
; ---------------------------------------------------------------------------

FOR_FIND_FIRST:				; ...
		push	cx
		xor	cx, cx
		mov	ax, 4E00h
		int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
					; CX = search attributes
					; DS:DX	-> ASCIZ filespec
					; (drive, path,	and wildcards allowed)
		pop	cx
		jmp	short FOR_RESULT
; ---------------------------------------------------------------------------

FOR_FIND_NEXT:				; ...
		mov	ax, 4F00h
		int	21h		; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
					; [DTA]	= data block from
					; last AH = 4Eh/4Fh call

FOR_RESULT:				; ...
		mov	ax, 0FFFFh	; -1
		jb	short FOR_CHECK
		mov	ax, 0

FOR_CHECK:				; ...
		mov	[ds:445h], ax	; [FOR_INFO.FOR_EXPAND]
		or	ax, ax
		jnz	short FOR_BEGIN

FOR_SMOOSH:				; ...
		mov	si, [bx]
		mov	di, 44Bh	; offset FOR_INFO.FORBUF
		rep movsb
		cmp	[word ptr ds:445h], 0 ;	[FOR_INFO.FOR_EXPAND]
		jnz	short FOR_MAKE_COM
		mov	si, 4E9h	; offset FOR_INFO.FORDMA+FIND_BUF.PNAME

FOR_MORE:				; ...
		cmp	[byte ptr si], 0
		jz	short FOR_MAKE_COM
		movsb
		jnz	short FOR_MORE

FOR_MAKE_COM:				; ...
		xor	al, al
		stosb
		xor	cx, cx
		not	cx
		xor	bx, bx
		mov	di, (offset COMBUF+2)
		mov	bl, [ds:444h]	; [FOR_INFO.FOR_COM_START]
		mov	dh, [ds:54Bh]	; [FOR_INFO.FOR_VAR]
		push	cs
		pop	es
		assume es:TRANGROUP
		mov	ax, 0		; FOR_INFO.FOR_ARGS
		call	argv_calc
		mov	si, [bx+9]	; [bx+ARGV_ELE.arg_ocomptr]
		inc	si

FOR_MAKE_LOOP:				; ...
		mov	al, [si]
		inc	si
		cmp	al, 25h	; '%'
		jnz	short FOR_STOSB
		cmp	[si], dh
		jnz	short FOR_STOSB
		inc	si
		push	si
		mov	si, 44Bh	; offset FOR_INFO.FORBUF

SLOOP:					; ...
		lodsb
		stosb
		or	al, al
		loopne	SLOOP
		dec	di
		inc	cx
		pop	si
		jmp	short FOR_MAKE_LOOP
; ---------------------------------------------------------------------------

FOR_STOSB:				; ...
		stosb
		dec	cx
		cmp	al, 0Dh
		jnz	short FOR_MAKE_LOOP
		not	cl
		mov	[es:COMBUF+1], cl
		mov	ds, [es:RESSEG]
		assume ds:RESGROUP
		test	[EchoFlag], 1	; byte
		jz	short NOECHO3
		cmp	[NullFlag], 1	; cmp byte [NullFlag],nullcommand
		jz	short NO_CRLF_PR
		call	CRLF2

NO_CRLF_PR:				; ...
		mov	[NullFlag], 0	; byte
		push	cs
		pop	ds
		assume ds:TRANGROUP
		push	di
		call	PRINT_PROMPT
		pop	di
		mov	[byte ptr es:di-1], 0
		mov	[string_ptr_2],	(offset	COMBUF+2)
		mov	dx, offset string_buf_ptr
		call	std_printf
		mov	[byte ptr es:di-1], 0Dh
		jmp	DOCOM
; ---------------------------------------------------------------------------

NOECHO3:				; ...
		mov	[ds:NullFlag], 0 ; byte
		push	cs
		pop	ds
		jmp	DOCOM0
; END OF FUNCTION CHUNK	FOR PROMPTBAT
; ---------------------------------------------------------------------------

FORNESTERRJ:				; ...
		call	FOROFF
		jmp	FORNESTERR
; ---------------------------------------------------------------------------

FORERRORJ:				; ...
		jmp	IFERROR
; ---------------------------------------------------------------------------

_$FOR:					; ...
		mov	es, [RESSEG]
		assume es:RESGROUP
		cmp	[es:ForFlag], 0	; byte
		jnz	short FORNESTERRJ
		cmp	[es:PipeFiles],	0 ; byte
		jz	short NO_PIPE
		call	PIPEDEL

NO_PIPE:				; ...
		xor	dx, dx
		call	NEXTARG
		jb	short FORERRORJ
		cmp	al, 25h	; '%'
		jnz	short FORERRORJ
		mov	bp, ax
		lodsb
		or	al, al
		jnz	short FORERRORJ
		call	NEXTARG
		jb	short FORERRORJ
		and	ax, 0DFDFh	; ~2020h ; uppercase letters
		cmp	ax, 4E49h	; 'IN' (NASM syntax)
		jnz	short FORERRORJ
		lodsb
		or	al, al
		jnz	short FORERRORJ

CHECKLPAREN:
		call	NEXTARG
		jb	short FORERRORJ
		cmp	al, 28h	; '('
		jnz	short FORERRORJ
		cmp	ah, 0
		jz	short FOR_PAREN_TOKEN
		cmp	ah, 29h	; ')'
		jnz	short FOR_LIST_NOT_EMPTY
		jmp	FORTERM
; ---------------------------------------------------------------------------

FOR_LIST_NOT_EMPTY:			; ...
		inc	[word ptr bx]	; [bx+ARGV_ELE.argpointer] ; [bx+0]
		dec	[word ptr bx+5]	; [bx+ARGV_ELE.arglen]
		inc	si
		jmp	short FOR_LIST
; ---------------------------------------------------------------------------

FOR_PAREN_TOKEN:			; ...
		call	NEXTARG
		jb	short FORERRORJ
		cmp	ax, 29h	; ')'
		jnz	short FOR_LIST
		jmp	FORTERM
; ---------------------------------------------------------------------------

FORERORJJ:				; ...
		jmp	IFERROR
; ---------------------------------------------------------------------------

FOR_LIST:				; ...
		mov	cx, dx

SKIP_LIST:				; ...
		add	si, [bx+5]	; [bx+ARGV_ELE.arglen]
		sub	si, 3
		mov	al, 29h	; ')'
		cmp	[si], al
		jz	short FOR_END_LIST
		call	NEXTARG
		jb	short FORERORJJ
		jmp	short SKIP_LIST
; ---------------------------------------------------------------------------

FOR_END_LIST:				; ...
		mov	di, dx
		mov	[byte ptr si], 0
		cmp	ax, 29h	; ')'   ; db ')',0
		jz	short FOR_DO
		inc	di

FOR_DO:					; ...
		call	NEXTARG
		jb	short FORERORJJ
		and	ax, 0DFDFh	; ~2020h ; uppercase the letters
		cmp	ax, 4F44h	; 'DO' (NASM syntax)
		jnz	short FORERORJJ
		lodsb
		or	al, al
		jnz	short FORERORJJ
		call	NEXTARG
		jb	short FORERORJJ
		push	ax
		push	bx
		push	cx
		push	dx
		push	di
		push	si
		push	bp
		call	FREE_TPA
		call	FOROFF
		mov	bx, 264		; FOR_INFO.size-ARG_UNIT.SIZE
		call	SAVE_ARGS
		pushf
		mov	[es:ForPtr], ax
		call	ALLOC_TPA
		popf
		pop	bp
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		jb	short FOR_ALLOC_ERR
		push	es
		push	[es:ForPtr]
		pop	es
		assume es:nothing
		dec	cx
		dec	di
		mov	[es:447h], cx	; [es:FOR_INFO.FOR_MINARG]
		mov	[es:449h], di	; [es:FOR_INFO.FOR_MAXARG]
		mov	[es:444h], dl	; [es:FOR_INFO.FOR_COM_START]
		mov	[word ptr es:445h], 0FFFFh ; [es:FOR_INFO.FOR_EXPAND],-1
		mov	ax, bp
		mov	[es:54Bh], ah	; [es:FOR_INFO.FOR_VAR]
		pop	es
		inc	[es:ForFlag]	; byte
		cmp	[es:SingleCom],	0FFFFh ; -1
		jnz	short FOR_RET
		mov	[es:SingleCom],	0FF00h

FOR_RET:				; ...
		retn
; ---------------------------------------------------------------------------

FOR_ALLOC_ERR:				; ...
		mov	[msg_disp_class], 1 ; ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	[extend_buf_ptr], 8 ; ERROR_NOT_ENOUGH_MEMORY
		jmp	cerror

; =============== S U B	R O U T	I N E =======================================


proc		NEXTARG	near		; ...
		inc	dx
		cmp	dx, [ARG_ARGVCNT] ; [ARG+ARG_UNIT.argvcnt]
		jge	short NEXTARG_ERR
		mov	bx, dx
		mov	ax, offset ARG_ARGV
		call	argv_calc
		mov	si, [bx]	; [bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
		lodsw
		clc
		retn
; ---------------------------------------------------------------------------

NEXTARG_ERR:				; ...
		stc
		retn
endp		NEXTARG

; ---------------------------------------------------------------------------

FORNESTERR:				; ...
		push	ds
		mov	ds, [RESSEG]
		assume ds:RESGROUP
		mov	dx, offset FORNESTMES_PTR
		cmp	[SingleCom], 0FF00h
		jnz	short NOFORP3
		mov	[SingleCom], 0FFFFh ; -1

NOFORP3:				; ...
		pop	ds
		assume ds:nothing
		jmp	cerror

; =============== S U B	R O U T	I N E =======================================


proc		FOROFF near		; ...
		push	ax
		push	es
		mov	es, [cs:RESSEG]
		assume es:RESGROUP
		mov	ax, [es:ForPtr]
		or	ax, ax
		jz	short FREEDONE
		push	es
		mov	es, ax
		assume es:nothing
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		pop	es

FREEDONE:				; ...
		mov	[es:ForPtr], 0	; word
		mov	[es:ForFlag], 0	; byte
		pop	es
		pop	ax
		retn
endp		FOROFF

; ---------------------------------------------------------------------------

CATALOG:				; ...
		mov	[ds:nocommas], 0
		mov	[ds:bfree_not_kilo], 0 ; use kilobyte if number	of bytes is very big
		push	ax
		push	cx
		push	di
		push	si
		push	es
		mov	si, offset no_sep_text ; NO_SEP=1 ; Removes the	commas from numbers
		call	find_name_in_environment
		jb	short catalog0
		mov	[ds:bfree_not_kilo], 0FFh ; no need to kilobyte	(short)	display
		mov	[ds:nocommas], 0FFh ; do not use commas	for displaying numbers

catalog0:				; ...
		pop	es
		pop	si
		pop	di
		pop	cx
		pop	ax
		call	SetDefaults
		call	ParseEnvironment
		call	ParseCmdLine
		jnb	short catalog1	; no parse error
		jmp	catErr
; ---------------------------------------------------------------------------

catalog1:				; ...
		call	SetOptions
		call	SetCollatingTable
		mov	[ds:narrow], 0
		test	[ds:_Bits], 20h	; /Z switch (narrow)
		jz	short catalog1_1
		mov	[ds:narrow], 0FFh
		mov	[ds:nocommas], 0FFh

catalog1_1:				; ...
		test	[ds:_Bits], 40h	; /4 switch
		jz	short catalog1_2
		mov	[cs:yeardigit4], 0FFh ;	4 digits year
		jmp	short catalog1_3
; ---------------------------------------------------------------------------

catalog1_2:				; ...
		mov	[cs:yeardigit4], 0 ; 2 digits year

catalog1_3:				; ...
		test	[ds:_Bits], 8	; mask.bare
		jnz	short catalog2
		call	OkVolArg
		sub	[ds:LeftOnPage], 2
		jmp	short catCrunch
; ---------------------------------------------------------------------------

catalog2:				; ...
		call	DisAppend
		mov	dx, offset BWDBUF ; DIRBUF
		mov	ah, 1Ah
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		mov	di, 5Dh		; FCB+1
		mov	al, 3Fh	; '?'
		mov	cx, 11
		rep stosb

catCrunch:				; ...
		call	CrunchPath
		jb	short catRecErr
		cmp	[ds:COMSW], 0	; word
		jnz	short catRecErr
		call	InstallCtrlC
		call	ZeroTotals
		call	ListDir
		jb	short catExtErr
		test	[ds:_Bits], 4	; mask.subd
		jz	short catalog3
		call	ListSubds
		jb	short catExtErr

catalog3:				; ...
		test	[ds:_Bits], 8	; mask.bare
		jnz	short catRet
		mov	cx, [ds:FileCntTotal]
		or	cx, [ds:FileCntTotal+2]
		jcxz	short catNoFiles
		call	DisplayTotals
		jmp	short catRet
; ---------------------------------------------------------------------------

catRecErr:				; ...
		test	[ds:COMSW], 1	; mask.dev
		jnz	short catNoFiles
		test	[ds:COMSW], 2	; mask.baddir
		jz	short catExtErr
		mov	dx, offset badcd_ptr
		jmp	short catErr
; ---------------------------------------------------------------------------

catNoFiles:				; ...
		call	DisplayHeader
		mov	ax, 2		; ERROR_FILE_NOT_FOUND
		mov	[ds:msg_disp_class], 1 ; ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	[ds:extend_buf_ptr], ax
		jmp	short catErr
; ---------------------------------------------------------------------------

catExtErr:				; ...
		call	Set_Ext_Error_Msg
		cmp	[ds:extend_buf_ptr], 18	; ERROR_NO_MORE_FILES
		jnz	short catErr
		mov	[ds:extend_buf_ptr], 2 ; ERROR_FILE_NOT_FOUND

catErr:					; ...
		jmp	cerror
; ---------------------------------------------------------------------------

catRet:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================


proc		SetDefaults near	; ...
		mov	di, offset SrcBuf
		mov	[ds:PathPos], di ; PathPos = ptr to pathname
		mov	al, 2Ah	; '*'   ; STAR
		stosb
		mov	al, 0Dh		; END_OF_LINE_IN
		stosb			; SrcBuf = '*',0Dh
		mov	[ds:PathCnt], 1	; PathCnt = pathname length
		xor	ax, ax		; 0
		mov	[ds:COMSW], ax	; = no error
		mov	[ds:_Bits], ax	; = options off
		mov	[ds:DestBuf], al ; = no	sort
		mov	[ds:AttrSpecified], 6 ;	ATTR_HIDDEN+ATTR_SYSTEM
		mov	[ds:AttrSelect], al ; exclude hidden, system files
		retn
endp		SetDefaults


; =============== S U B	R O U T	I N E =======================================


proc		ParseEnvironment near	; ...
		call	GetEnvValue
		jb	short peRet
		call	Parse_Line
		cmp	ax, 0FFFFh	; -1
		jz	short peRet
		call	std_eprintf
		mov	[ds:msg_disp_class], 0FFh ; util_msg_class ; -1
		mov	dx, offset errparsenv_ptr
		call	Printf_Crlf

peRet:					; ...
		retn
endp		ParseEnvironment


; =============== S U B	R O U T	I N E =======================================


proc		ParseCmdLine near	; ...
		mov	si, 81h
		call	Parse_Line
		cmp	ax, 0FFFFh	; -1
		jz	short pcOk
		stc
		jmp	short pcRet
; ---------------------------------------------------------------------------

pcOk:					; ...
		clc

pcRet:					; ...
		retn
endp		ParseCmdLine


; =============== S U B	R O U T	I N E =======================================


proc		SetCollatingTable near	; ...
		mov	dx, offset STACK ; INTERNATVARS
		mov	ax, 3800h
		int	21h		; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
					; get current-country info
					; DS:DX	-> buffer for returned info
		jb	short scNoTable
		cmp	bx, 1
		jz	short scNoTable
		mov	ax, 6506h	; (GETEXTCNTRY shl 8) +	SETCOLLATE
		mov	bx, 0FFFFh	; -1
		mov	cx, 5
		mov	dx, bx
		mov	di, offset CountryPtrId	; CountryPtrInfo
		int	21h		; DOS -	4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
					; AL = function	-
		jnb	short scRet

scNoTable:				; ...
		mov	[ds:CountryPtrId], 0

scRet:					; ...
		retn
endp		SetCollatingTable


; =============== S U B	R O U T	I N E =======================================


proc		SetOptions near		; ...
		test	[ds:_Bits], 8	; mask.bare
		jz	short setopts1
		and	[ds:_Bits], 0FFFEh ; ~mask.wide

setopts1:				; ...
		push	ds
		mov	ax, 40h		; ROMBIOS_DATA
		mov	ds, ax
		assume ds:nothing
		mov	al, [ds:84h]	; [CRT_Rows]
		pop	ds
		assume ds:nothing
		or	al, al
		jnz	short setopts3
		mov	al, 25		; LINESPERPAGE

setopts3:				; ...
		xor	ah, ah
		inc	al
		mov	[ds:LinPerPag],	ax
		mov	ax, 440Ch	; (IOCTL shl 8)+GENERIC_IOCTL_HANDLE
		mov	bx, 1		; STDOUT
		mov	ch, 3		; IOC_SC
		mov	cl, 7Fh		; get_generic
		mov	dx, offset Display_Ioctl
		int	21h		; DOS -	2+ - IOCTL -
		mov	ax, [ds:LinPerPag]
		mov	[ds:LeftOnPage], ax
		mov	[ds:PerLine], 1
		test	[ds:_Bits], 1	; mask.wide
		jz	short setopts4
		mov	[ds:PerLine], 5	; WIDEPERLIN

setopts4:				; ...
		cmp	[ds:SrcBuf+1], 3Ah ; ':'
		jnz	short soRet
		mov	al, [ds:SrcBuf]
		and	al, 0DFh	; not 20h
		sub	al, 40h	; '@'
		mov	[ds:5Ch], al	; [FCB]

soRet:					; ...
		retn
endp		SetOptions


; =============== S U B	R O U T	I N E =======================================


proc		CrunchPath near		; ...
		call	FileIsDevice
		jnz	short crpath1
		or	[ds:COMSW], 1	; or byte [COMSW],mask.dev
		jmp	short cpErr
; ---------------------------------------------------------------------------

crpath1:				; ...
		push	[ds:PathPos]
		mov	[ds:DirFlag], 0FFh ; -1
		call	PathCrunch
		mov	[ds:DirFlag], 0	; byte
		pop	si
		jb	short cpNoDir
		jz	short cpRet
		mov	si, [ds:DestTail]
		jmp	short cpFile
; ---------------------------------------------------------------------------

cpNoDir:				; ...
		mov	ax, [ds:Msg_Numb]
		or	ax, ax
		jnz	short cpErr
		cmp	[ds:DestIsDir],	0
		jz	short cpMaybe
		or	[ds:COMSW], 2	; or byte [COMSW],mask.baddir
		jmp	short cpErr
; ---------------------------------------------------------------------------

cpMaybe:				; ...
		cmp	[byte ptr si+1], 3Ah ; ':' ; COLON_CHAR
		jnz	short crpath2
		lodsw

crpath2:				; ...
		cmp	[word ptr si], 2E2Eh ; ".." ?
		jnz	short cpFile	; if not "..", treat as	a file
		cmp	[byte ptr si+2], 0
		jnz	short cpFile	; or if	there's more after "..", treat as file
		or	[ds:COMSW], 2	; or byte [COMSW],mask.baddir
		jmp	short cpErr
; ---------------------------------------------------------------------------

cpFile:					; ...
		mov	di, 5Ch		; FCB
		mov	ax, 290Eh	; (Parse_File_Descriptor<<8)|0Eh
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		clc
		jmp	short cpRet
; ---------------------------------------------------------------------------

cpErr:					; ...
		stc

cpRet:					; ...
		retn
endp		CrunchPath


; =============== S U B	R O U T	I N E =======================================


proc		InstallCtrlC near	; ...
		push	es
		mov	ax, 3523h
		int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
					; AL = interrupt number
					; Return: ES:BX	= value	of interrupt vector
		mov	[word ptr ds:OldCtrlCHandler], bx
		mov	[word ptr ds:OldCtrlCHandler+2], es
		pop	es
		mov	dx, offset CtrlCHandler
		mov	ax, 2523h
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		retn
endp		InstallCtrlC


; =============== S U B	R O U T	I N E =======================================


proc		ListSubds near		; ...
		call	SetRest1
		mov	bx, offset ScanBuf

lsNode:					; ...
		mov	[byte ptr bx], 0

lsLoop:					; ...
		call	FindNextChild
		jb	short lsErr
		mov	dx, bx
		call	ChangeDir
		jnb	short lstsd1
		cmp	ax, 3		; ERROR_PATH_NOT_FOUND
		jz	short lsLoop
		jmp	short lsRet
; ---------------------------------------------------------------------------

lstsd1:					; ...
		push	bx
		call	ListDir
		pop	bx
		mov	di, bx
		mov	cx, 13
		xor	al, al
		repne scasb
		push	bx
		mov	bx, di
		call	lsNode
		pop	bx
		pushf
		mov	ax, 0
		push	ax
		mov	ax, 2E2Eh	; ".."
		push	ax
		mov	dx, sp
		call	ChangeDir
		pop	ax
		pop	ax
		popf
		jb	short lsRet
		jmp	short lsLoop
; ---------------------------------------------------------------------------

lsErr:					; ...
		call	get_ext_error_number
		cmp	ax, 2		; ERROR_FILE_NOT_FOUND
		jz	short lsRet
		cmp	ax, 18		; ERROR_NO_MORE_FILES
		jz	short lsRet
		stc

lsRet:					; ...
		retn
endp		ListSubds


; =============== S U B	R O U T	I N E =======================================


proc		CheckChild near		; ...
		test	[ds:BWDBUF+15h], 10h ; [DIRBUF+FIND_BUF.ATTR],ATTR_DIRECTORY
		jz	short ccRet
		cmp	[ds:BWDBUF+1Eh], 2Eh ; '.' ; [DIRBUF+FIND_BUF.PNAME],'.'
		jz	short ccRet
		mov	si, (offset BWDBUF+1Eh)	; offset DIRBUF+FIND_BUF.PNAME
		mov	di, bx
		call	CmpAscz
		jbe	short ccRet
		mov	si, (offset BWDBUF+1Eh)	; offset DIRBUF+FIND_BUF.PNAME
		mov	di, bp
		call	CmpAscz
		jnb	short ccRet
		mov	si, (offset BWDBUF+1Eh)
		mov	di, bp
		mov	cx, 13
		rep movsb

ccRet:					; ...
		retn
endp		CheckChild


; =============== S U B	R O U T	I N E =======================================


proc		CmpEntry near		; ...
		mov	si, offset DestBuf

ceLoop:					; ...
		xor	ax, ax
		mov	al, [si]
		or	al, al
		jz	short ceDone
		inc	si
		push	si
		dec	al
		shl	al, 1
		mov	si, ax
		mov	ax, [cs:FieldCmps+si]
		jb	short ceDn
		call	ax
		jmp	short ceNs
; ---------------------------------------------------------------------------

ceDn:					; ...
		xchg	bx, bp
		call	ax
		xchg	bx, bp

ceNs:					; ...
		pop	si
		jz	short ceLoop

ceDone:					; ...
		retn
endp		CmpEntry

; ---------------------------------------------------------------------------
FieldCmps	dw offset CmpName	; ...
		dw offset CmpExt
		dw offset CmpTime
		dw offset CmpSize
		dw offset CmpType
; ---------------------------------------------------------------------------

CmpName:				; ...
		mov	si, bx
		mov	di, bp
		add	si, 1
		add	di, 1
		mov	cx, 8
		jmp	short CmpStr
; ---------------------------------------------------------------------------

CmpExt:					; ...
		mov	si, bx
		mov	di, bp
		add	si, 9
		add	di, 9
		mov	cx, 3

CmpStr:					; ...
		cmp	[ds:CountryPtrId], 6 ; byte
		jnz	short cnNoCollTable
		push	bp
		push	bx
		push	ds
		lds	bx, [ds:CountryPtr]
		mov	bp, [bx]
		inc	bx
		inc	bx
		xor	ax, ax
		xor	dh, dh

cnNextChar:				; ...
		mov	al, [es:di]
		inc	di
		test	dh, dh
		jz	short cn1
		xor	dh, dh
		mov	dl, al
		lods	[byte ptr es:si]
		jmp	short cn4
; ---------------------------------------------------------------------------

cn1:					; ...
		call	testkanj
		jz	short cn2
		mov	dh, 1

cn2:					; ...
		cmp	ax, bp
		jnb	short cn3
		xlat

cn3:					; ...
		mov	dl, al
		lods	[byte ptr es:si]
		cmp	ax, bp
		jnb	short cn4
		xlat

cn4:					; ...
		cmp	al, dl
		loope	cnNextChar
		pop	ds
		pop	bx
		pop	bp
		retn
; ---------------------------------------------------------------------------

cnNoCollTable:				; ...
		repe cmps [byte	ptr es:si], [byte ptr es:di] ;
					; repe	  ; 0F3h
					; es	  ; 26h
					; cmpsb	  ; 0A6h
					; retn	  ; 0C3h
		retn
; ---------------------------------------------------------------------------

CmpTime:				; ...
		mov	si, bx
		mov	di, bp
		add	si, 16
		add	di, 16
		mov	cx, 4
		std
		repe cmps [byte	ptr es:si], [byte ptr es:di] ;
					; repe	; 0F3h
					; es	; 26h
					; cmpsb	; 0A6h
		cld
		retn
; ---------------------------------------------------------------------------

CmpSize:				; ...
		mov	si, bx
		mov	di, bp
		add	si, 20
		add	di, 20
		mov	cx, 4
		std
		repe cmps [byte	ptr es:si], [byte ptr es:di]
		cld
		retn
; ---------------------------------------------------------------------------

CmpType:				; ...
		mov	al, [es:bx+0Ch]	; es:[bx].fileattr
		mov	ah, [es:bp+0Ch]	; es:[bp].fileattr
		and	ax, 1010h	; (ATTR_DIRECTORY<<8)+ATTR_DIRECTORY
		cmp	ah, al
		retn

; =============== S U B	R O U T	I N E =======================================


proc		DefaultAttr near	; ...
		mov	[ds:AttrSpecified], 6 ;	ATTR_HIDDEN+ATTR_SYSTEM
		mov	[ds:AttrSelect], 0 ; H and S must be off
		clc
		retn
endp		DefaultAttr


; =============== S U B	R O U T	I N E =======================================


proc		DisplayTotals near	; ...
		test	[ds:_Bits], 4	; mask.subd
		jz	short dtFree
		call	CRLF2
		call	UseLine
		mov	dx, offset total_ptr ; MSG_1080
		call	std_printf
		call	UseLine
		mov	ax, [ds:FileCntTotal]
		mov	si, offset FileSizTotal
		mov	di, offset FileSiz
		movsw
		movsw
		movsw
		movsw
		mov	dx, [ds:FileCntTotal+2]
		call	DisplayCntSiz

dtFree:					; ...
		call	GetDriveLtr
		mov	[byte ptr ds:efs_drive], al ; "C:\\"
		mov	dx, offset efs_drive ; "C:\\"
		mov	di, offset efs_buffer
		mov	cx, 44
		mov	[es:di], cx
		mov	[word ptr es:di+2], 0
		mov	ax, 7303h	; GET EXTENDED FREE SPACE ON DRIVE
					; DS:DX	-> ASCIZ string	for drive ("C:\" or "\\SERVER\Share")
					; ES:DI	-> buffer for extended free space structure
					; CX = length of buffer	for extended free space
		int	21h		; DOS -
					;
					; Return:
					; CF clear if successful
					; ES:DI	buffer filled
					; CF set on error
					; AX = error code
					;
					; Format of extended free space	structure:
					;
					; Offset  Size	  Description
					; 00h	 WORD	 (ret) size of returned	structure
					; 02h	 WORD	 (call)	structure version (0000h)
					;		 (ret) actual structure	version	(0000h)
					; 04h	 DWORD	 number	of sectors per cluster
					;		 (with adjustment for compression)
					; 08h	 DWORD	 number	of bytes per sector
					; 0Ch	 DWORD	 number	of available clusters
					; 10h	 DWORD	 total number of clusters on the drive
					; 14h	 DWORD	 number	of physical sectors available on the drive,
					;		 without adjustment for	compression
					; 18h	 DWORD	 total number of physical sectors on the drive,
					;		 without adjustment for	compression
					; 1Ch	 DWORD	 number	of available allocation	units,
					;		 without adjustment for	compression
					; 20h	 DWORD	 total allocation units,
					;		 without adjustment for	compression
					; 24h  8 BYTEs	 reserved
		mov	cx, ax		; error	code (cf=1) or (cf=0) efs structure size (44)
		mov	bx, [es:di+8]	; bytes	per sector
		mov	ax, [es:di+14h]	; number of sectors available
		mov	dx, [es:di+16h]
		jb	short get_efs_err
		or	cl, cl
		jnz	short dtFree_1	; cl = 44 (IBMDOS 7.1 Kernel, INT 21h, AX=7303h	return value)

get_efs_err:				; ...
		mov	ah, 36h
		mov	dl, [ds:5Ch]	; [FCB]
		int	21h		; DOS -	2+ - GET DISK SPACE
					; DL = drive code (0 = default,	1 = A, 2 = B, etc.)
		cmp	ax, 0FFFFh	; ax = sectors per cluster
		jz	short dtRet	; invalid drive
		mul	cx		; * bytes per sectors
					; dx:ax	= bytes	per cluster
					; bx = free clusters

dtFree_1:				; ...
		mov	cx, dx		; hw of	free sectors
		mul	bx		; lw of	free sectors * bytes per sector
		xchg	ax, cx
		xchg	dx, bx
		mul	dx
		add	ax, bx
		adc	dx, 0		; dx:ax:cx = free bytes
		or	dx, dx
		jz	short dtFree_2
		mov	cl, ch		; prints free space as kilobytes
		mov	ch, al		; save al
		mov	al, ah		; / 256
		mov	ah, dl
		ror	dh, 1		; / 2 (= free bytes / 512)
		rcr	ax, 1
		rcr	cx, 1
		ror	dh, 1		; / 2 (= free bytes / 1024)
		rcr	ax, 1
		rcr	cx, 1
		mov	dl, 0FFh	; dx > 0

dtFree_2:				; ...
		mov	[word ptr ds:Bytes_Free], cx
		mov	[word ptr ds:Bytes_Free+2], ax
		or	dx, dx		; is dx	> 0 ?
		jz	short dtFree_3	; no
		mov	dx, offset kbytesf_ptr ; MSG_1106 (".. K bytes free" msg)
					; 30 digits, long binary do decimal
		cmp	[ds:bfree_not_kilo], 0
		jz	short dtFree_5
		mov	dx, offset kbytesf_n_ptr ; MSG_1106 (narrow)
					; ".. K	bytes free" msg, 28 digits
		jmp	short dtFree_5
; ---------------------------------------------------------------------------

dtFree_3:				; ...
		mov	dx, offset bytmes1_ptr ; MSG_1020 (".. bytes free" msg)
					; 30 digits, long binary do decimal
		cmp	[ds:narrow], 0	; narrow display area ?
		jnz	short dtFree_4	; yes
		mov	dx, offset bytmes2_ptr ; MSG_1020, 33 digits

dtFree_4:				; ...
		cmp	[ds:bfree_not_kilo], 0 ; not kilobyte option
		jz	short dtFree_5	; use kilo bytes (if number of free bytes is big)
		mov	dx, offset bytmes_n_ptr	; narrow (28 digits), MSG_1020

dtFree_5:				; ...
		call	std_printf
		call	UseLine

dtRet:					; ...
		retn
endp		DisplayTotals


; =============== S U B	R O U T	I N E =======================================


proc		FileIsDevice near	; ...
		mov	dx, [ds:PathPos]
		mov	di, dx
		add	di, [ds:PathCnt]
		xor	bl, bl
		xchg	bl, [di]
		xor	cx, cx
		mov	ah, 4Eh
		int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
					; CX = search attributes
					; DS:DX	-> ASCIZ filespec
					; (drive, path,	and wildcards allowed)
		xchg	bl, [di]
		jb	short piCol
		test	[ds:BWDBUF+15h], 40h ; [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
		jz	short piCol
		xor	cx, cx
		jmp	short piRet
; ---------------------------------------------------------------------------

piCol:					; ...
		dec	di
		mov	al, ':'         ; COLON_CHAR
		mov	cx, [ds:PathCnt]
		dec	cx
		dec	cx
		or	cx, cx
		js	short piRet
		or	di, di
		std
		repne scasb
		cld

piRet:					; ...
		retn
endp		FileIsDevice


; =============== S U B	R O U T	I N E =======================================


proc		FindFirst near		; ...
		mov	ax, offset GetFirst
		jmp	short ffFindEntry
endp		FindFirst


; =============== S U B	R O U T	I N E =======================================


proc		FindNext near		; ...
		mov	ax, offset GetNext

ffFindEntry:				; ...
		push	es
		test	[ds:_Bits], 80h	; mask.inmem
		jz	short ffDisk
		call	FindInMem
		jmp	short ffRet
; ---------------------------------------------------------------------------

ffDisk:					; ...
		call	ax
		jb	short ffGetErr
		mov	es, [ds:TPA]
		xor	di, di
		mov	bx, di
		call	LoadEntry
		clc
		jmp	short ffRet
; ---------------------------------------------------------------------------

ffGetErr:				; ...
		call	get_ext_error_number
		stc

ffRet:					; ...
		pop	es
		retn
endp		FindNext


; =============== S U B	R O U T	I N E =======================================


proc		FindInMem near		; ...
		mov	es, [ds:TPA]
		xor	bx, bx
		cld
		call	FindOneInMem
		jb	short fiNoMore

fiBest:					; ...
		mov	bp, bx

fiNext:					; ...
		call	FindNextInMem
		jb	short fiFound
		call	CmpEntry
		jnb	short fiNext
		jmp	short fiBest
; ---------------------------------------------------------------------------

fiNoMore:				; ...
		mov	ax, 18		; ERROR_NO_MORE_FILES
		stc
		jmp	short fiRet
; ---------------------------------------------------------------------------

fiFound:				; ...
		mov	bx, bp
		mov	[byte ptr es:bx], 1 ; mark entry 'used'
		clc

fiRet:					; ...
		retn
endp		FindInMem


; =============== S U B	R O U T	I N E =======================================


proc		FindNextChild near	; ...
		sub	sp, 12		; make temp filename buf on stack
		mov	ax, 0FFh
		push	ax
		mov	bp, sp
		mov	ax, 2Ah	; '*'
		push	ax
		mov	ax, 2E2Ah	; "*." (NASM syntax)
		push	ax
		call	GetDriveLtr
		push	ax		; AX = "d:"
		mov	dx, sp		; DX = ptr to "d:*.*",0	on stack
		mov	cx, 10h		; ATTR_DIRECTORY
		mov	ah, 4Eh
		int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
					; CX = search attributes
					; DS:DX	-> ASCIZ filespec
					; (drive, path,	and wildcards allowed)
		jb	short fcRet
		call	CheckChild	; check	child against last, temp

fcNext:					; ...
		mov	cx, 10h		; ATTR_DIRECTORY
		mov	ah, 4Fh
		int	21h		; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
					; [DTA]	= data block from
					; last AH = 4Eh/4Fh call
		jb	short fcErr
		call	CheckChild
		jmp	short fcNext
; ---------------------------------------------------------------------------

fcErr:					; ...
		call	get_ext_error_number
		cmp	ax, 18		; ERROR_NO_MORE_FILES
		jnz	short fcNope
		cmp	[byte ptr bp+0], 0FFh
		jz	short fcNope
		mov	si, bp
		mov	di, bx

fcMove:					; ...
		lodsb
		stosb
		or	al, al
		jz	short fcRet
		jmp	short fcMove
; ---------------------------------------------------------------------------

fcNope:					; ...
		stc

fcRet:					; ...
		lahf
		add	sp, 20		; restore stack
		sahf
		retn
endp		FindNextChild


; =============== S U B	R O U T	I N E =======================================


proc		FindOneInMem near	; ...

; FUNCTION CHUNK AT 1721 SIZE 00000002 BYTES

		mov	al, [es:bx]
		cmp	al, 1
		jz	short FindNextInMem
		cmp	al, 0FFh
		jz	short foNoMore
		clc
		retn
endp		FindOneInMem


; =============== S U B	R O U T	I N E =======================================


proc		FindNextInMem near	; ...
		add	bx, 22		; size EntryStruc
		jmp	short FindOneInMem
endp		FindNextInMem

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR FindOneInMem

foNoMore:				; ...
		stc
		retn
; END OF FUNCTION CHUNK	FOR FindOneInMem

; =============== S U B	R O U T	I N E =======================================


proc		GetEnvValue near	; ...
		push	es
		mov	si, offset DirEnvVar ; "DIRCMD="
		call	find_name_in_environment
		jb	short geRet
		push	ds
		push	es
		pop	ds
		pop	es
		mov	si, di
		mov	di, offset ScanBuf

geLoop:					; ...
		lodsb
		or	al, al
		stosb
		loopne	geLoop
		push	es
		pop	ds
		mov	si, offset ScanBuf

geRet:					; ...
		pop	es
		retn
endp		GetEnvValue


; =============== S U B	R O U T	I N E =======================================


proc		GetFirst near		; ...
		mov	[byte ptr ds:55h], 0FFh	; [FCB-7]
		mov	[byte ptr ds:5Bh], 16h ; [FCB-1],ATTR_ALL
		mov	dx, 55h		; FCB-7
		mov	ah, 11h
		int	21h		; DOS -	SEARCH FIRST USING FCB
					; DS:DX	-> FCB
		shl	al, 1
		jb	short gfRet
		jmp	short gfFound
endp		GetFirst


; =============== S U B	R O U T	I N E =======================================


proc		GetNext	near		; ...
		mov	dx, 55h		; FCB-7
		mov	ah, 12h
		int	21h		; DOS -	SEARCH NEXT USING FCB
					; DS:DX	-> FCB
					; Return: AL = status
		shl	al, 1
		jb	short gfRet

gfFound:				; ...
		mov	al, [ds:BWDBUF+13h] ; [DIRBUF+8+DIR_ENTRY.DIR_ATTR]
		mov	ah, [ds:AttrSpecified]
		and	al, ah
		and	ah, [ds:AttrSelect]
		cmp	al, ah
		jnz	short GetNext

gfRet:					; ...
		retn
endp		GetNext


; =============== S U B	R O U T	I N E =======================================


proc		ListDir	near		; ...
		xor	ax, ax		; 0
		mov	[ds:FileCnt], ax
		mov	[ds:FileSiz], ax
		mov	[ds:FileSiz+2],	ax
		mov	[ds:FileSiz+4],	ax
		mov	[ds:FileSiz+6],	ax
		cmp	[ds:DestBuf], 0
		jz	short ld1
		call	LoadEntries
		jnb	short ld1
		call	get_ext_error_number
		stc
		jmp	short ldErr
; ---------------------------------------------------------------------------

ld1:					; ...
		call	FindFirst
		jb	short ldErr
		call	DisplayHeader
		call	DisplayFile

ldNext:					; ...
		call	FindNext
		jb	short ldErr
		call	DisplayFile
		jmp	short ldNext
; ---------------------------------------------------------------------------

ldErr:					; ...
		cmp	ax, 2		; ERROR_FILE_NOT_FOUND
		jz	short ldDone
		cmp	ax, 18		; ERROR_NO_MORE_FILES
		jz	short ldDone
		stc
		jmp	short ldRet
; ---------------------------------------------------------------------------

ldDone:					; ...
		cmp	[ds:FileCnt], 0	; word
		jz	short ld2
		call	DisplayTrailer

ld2:					; ...
		clc

ldRet:					; ...
		retn
endp		ListDir


; =============== S U B	R O U T	I N E =======================================


proc		LoadEntries near	; ...
		push	es
		mov	es, [ds:TPA]
		xor	di, di
		and	[ds:_Bits], 0FF7Fh ; ~mask.inmem
		call	GetFirst
		jb	short leRet
		call	LoadEntry

leNext:					; ...
		call	GetNext
		jb	short leLoaded
		mov	ax, [ds:BYTCNT]
		sub	ax, di
		cmp	ax, 24
		jb	short leOk
		call	LoadEntry
		jmp	short leNext
; ---------------------------------------------------------------------------

leLoaded:				; ...
		mov	[byte ptr es:di], 0FFh
		or	[ds:_Bits], 80h	; mask.inmem

leOk:					; ...
		clc

leRet:					; ...
		pop	es
		retn
endp		LoadEntries


; =============== S U B	R O U T	I N E =======================================


proc		LoadEntry near		; ...
		mov	si, (offset BWDBUF+8) ;	DIRBUF+8
		xor	al, al
		stosb
		mov	cx, 11
		rep movsb
		lodsb
		stosb
		add	si, 10		; (DIR_ENTRY.DIR_TIME-DIR_ENTRY.DIR_ATTR)-1
		movsw
		movsw
		mov	cl, al
		lodsw
		and	cl, 10h		; ATTR_DIRECTORY
		jnz	short leSetDirSize
		movsw
		movsw
		xor	ax, ax
		stosb
		retn
; ---------------------------------------------------------------------------

leSetDirSize:				; ...
		xor	ax, ax
		stosw
		stosw
		dec	al
		stosb
		retn
endp		LoadEntry


; =============== S U B	R O U T	I N E =======================================


proc		NoOrder	near		; ...
		mov	[ds:DestBuf], 0
		clc
		retn
endp		NoOrder


; =============== S U B	R O U T	I N E =======================================


proc		OnOffSw	near		; ...
		mov	cx, di
		shr	cx, 1
		shr	cx, 1
		mov	ax, 1
		shl	ax, cl
		test	di, 2		; check	if it is a negated option
		jz	short oo1
		or	[ds:_Bits], ax
		jmp	short ooRet
; ---------------------------------------------------------------------------

oo1:					; ...
		not	ax
		and	[ds:_Bits], ax

ooRet:					; ...
		clc
		retn
endp		OnOffSw


; =============== S U B	R O U T	I N E =======================================


proc		ParseAttr near		; ...
		push	si
		mov	[ds:AttrSpecified], 0
		mov	si, [bx+4]

paLoop:					; ...
		mov	dx, 1
		lodsb
		or	al, al
		jz	short paOk
		cmp	al, 2Dh	; '-'
		jnz	short pa1
		dec	dx
		lodsb

pa1:					; ...
		mov	di, offset AttrLtrs ; "RHSvDA"
		mov	cx, 6		; NUM_ATTR_LTRS
		repne scasb
		jnz	short paErr
		not	cx
		add	cx, 6		; NUM_ATTR_LTRS
		mov	al, 1
		shl	al, cl
		or	[ds:AttrSpecified], al
		not	al
		and	[ds:AttrSelect], al
		shl	dl, cl
		or	[ds:AttrSelect], dl
		jmp	short paLoop
; ---------------------------------------------------------------------------

paErr:					; ...
		call	SetupParamError
		stc
		jmp	short paRet
; ---------------------------------------------------------------------------

paOk:					; ...
		clc

paRet:					; ...
		pop	si
		retn
endp		ParseAttr


; =============== S U B	R O U T	I N E =======================================


proc		Parse_Line near		; ...
		mov	di, offset PARSE_DIR
		xor	cx, cx

plPars:					; ...
		call	Parse_With_Msg
		cmp	ax, 0FFFFh	; END_OF_LINE ;	-1
		jz	short plRet
		cmp	ax, 0		; RESULT_NO_ERROR
		jnz	short plRet
		mov	bx, dx
		cmp	[byte ptr bx], 5 ; RESULT_FILESPEC
		jz	short plFil
		call	ParseSwitch
		jb	short plRet
		jmp	short plPars
; ---------------------------------------------------------------------------

plFil:					; ...
		call	CopyPathname
		jmp	short plPars
; ---------------------------------------------------------------------------

plRet:					; ...
		retn
endp		Parse_Line


; =============== S U B	R O U T	I N E =======================================


proc		ParseOrder near		; ...
		push	si
		push	bx
		mov	si, [bx+4]	; [bx+ResultBuffer.ValuePtr]
		mov	bx, offset DestBuf
		mov	al, [si]
		or	al, al
		jnz	short poLtr
		mov	[byte ptr bx], 5
		inc	bx
		mov	[byte ptr bx], 1
		inc	bx
		mov	[byte ptr bx], 2
		inc	bx
		jmp	short poOk
; ---------------------------------------------------------------------------

poLtr:					; ...
		xor	dl, dl
		lodsb
		or	al, al
		jz	short poOk
		cmp	al, 2Dh	; '-'
		jnz	short po1
		mov	dl, 80h
		lodsb

po1:					; ...
		mov	di, offset OrderLtrs ; "NEDSG"
		mov	cx, 5		; NUM_ORDER_LTRS
		repne scasb
		jnz	short poErr
		neg	cx
		add	cx, 5		; NUM_ORDER_LTRS
		or	cl, dl
		mov	[bx], cl
		inc	bx
		cmp	bx, offset EndDestBuf
		jb	short poLtr

poErr:					; ...
		pop	bx
		call	SetupParamError
		stc
		jmp	short poRet
; ---------------------------------------------------------------------------

poOk:					; ...
		mov	[byte ptr bx], 0
		pop	bx
		clc

poRet:					; ...
		pop	si
		retn
endp		ParseOrder


; =============== S U B	R O U T	I N E =======================================


proc		ParseSwitch near	; ...
		push	cx
		push	di
		mov	ax, [bx+2]	; [bx+ResultBuffer.SynPtr]
		mov	di, offset Dir_Sw_Ptrs
		mov	cx, 18		; NUM_DIR_SWS
		cld
		repne scasw
		sub	di, offset Dir_Sw_Ptrs_2 ; Dir_Sw_Ptrs+2
		call	[cs:SwHandler+di]
		pop	di
		pop	cx
		retn
endp		ParseSwitch

; ---------------------------------------------------------------------------
SwHandler	dw offset OnOffSw	; ...
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset NoOrder
		dw offset ParseOrder
		dw offset DefaultAttr
		dw offset ParseAttr

; =============== S U B	R O U T	I N E =======================================


proc		ChangeDir near		; ...
		mov	di, offset BWDBUF ; DIRBUF
		call	GetDriveLtr
		stosw
		mov	si, dx

cdLoop:					; ...
		lodsb
		stosb
		or	al, al
		jnz	short cdLoop
		mov	dx, offset BWDBUF ; DIRBUF
		mov	ah, 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		retn
endp		ChangeDir


; =============== S U B	R O U T	I N E =======================================


proc		CmpAscz	near		; ...
		push	di
		mov	di, si
		xor	al, al
		mov	cx, 0FFFFh
		repne scasb
		not	cx
		pop	di
		repe cmpsb
		retn
endp		CmpAscz


; =============== S U B	R O U T	I N E =======================================


proc		CopyPathname near	; ...
		push	si
		lds	si, [bx+4]	; [bx+ResultBuffer.ValuePtr]
		call	Move_To_SrcBuf
		pop	si
		retn
endp		CopyPathname


; =============== S U B	R O U T	I N E =======================================


proc		CountFile near		; ...
		push	es
		mov	es, [ds:TPA]
		inc	[ds:FileCnt]	; word
		inc	[ds:FileCntTotal]
		jnz	short cntf1
		inc	[ds:FileCntTotal+2]

cntf1:					; ...
		mov	ax, [es:bx+11h]	; [es:bx+EntryStruc.filesize]
		mov	dx, [es:bx+13h]	; [es:bx+EntryStruc.filesize+2]
		add	[ds:FileSiz], ax
		adc	[ds:FileSiz+2],	dx
		adc	[ds:FileSiz+4],	0
		add	[ds:FileSizTotal], ax
		adc	[ds:FileSizTotal+2], dx
		adc	[ds:FileSizTotal+4], 0
		pop	es
		retn
endp		CountFile


; =============== S U B	R O U T	I N E =======================================


proc		DisplayBare near	; ...
		mov	cx, ds
		mov	ds, [ds:TPA]
		cmp	[byte ptr bx+1], 2Eh ; '.' ; [bx+EntrStruc.filename]
		mov	ds, cx
		jz	short dbRet
		test	[ds:_Bits], 4	; mask.subd
		jz	short dbNameExt
		call	build_dir_string
		mov	di, offset BWDBUF
		test	[ds:_Bits], 10h	; mask.lcase
		jz	short dbare1
		mov	si, di
		call	LowercaseString

dbare1:					; ...
		xor	al, al
		mov	cx, 0FFFFh
		cld
		repne scasb
		dec	di
		push	si
		push	di
		mov	si, offset BWDBUF
		dec	di
		call	CheckDBCSTailByte
		pop	di
		pop	si
		jz	short dbTailByte
		cmp	[byte ptr es:di-1], 5Ch	; '\'
		jz	short dbare2

dbTailByte:				; ...
		mov	ax, 5Ch	; '\'
		stosw

dbare2:					; ...
		mov	[ds:string_ptr_2], offset BWDBUF
		mov	dx, offset string_buf_ptr
		call	std_printf

dbNameExt:				; ...
		call	DisplayDotForm
		call	CRLF2
		call	UseLine

dbRet:					; ...
		retn
endp		DisplayBare


; =============== S U B	R O U T	I N E =======================================


proc		DisplayDotForm near	; ...
		push	ds
		push	es
		mov	ax, [cs:TPA]
		mov	ds, ax
		assume ds:RESGROUP
		mov	es, ax
		assume es:RESGROUP
		mov	di, bx
		add	di, 8
		mov	cx, 8
		mov	al, 20h	; ' '
		std
		repe scasb
		inc	cx
		mov	dx, cx
		mov	si, bx
		add	si, 1

NextNameChar:				; ...
		cld
		lodsb
		call	testkanj
		jz	short ddf3
		call	PRINT_CHAR
		dec	cx
		jz	short ExtChar
		lodsb
		jmp	short ddf1
; ---------------------------------------------------------------------------

ddf3:					; ...
		test	[ss:_Bits], 10h	; mask.lcase
		jz	short ddf1
		call	LowerCase

ddf1:					; ...
		call	PRINT_CHAR
		loop	NextNameChar

ExtChar:				; ...
		mov	di, bx
		add	di, 11		; fileext + size fileext - 1 ; 9+3-1
		mov	cx, 3		; size fileext
		mov	al, 20h	; ' '
		std
		repe scasb
		jz	short ddDone
		inc	cx
		add	dx, cx
		inc	dx
		mov	al, 2Eh	; '.'
		call	PRINT_CHAR
		mov	si, bx
		add	si, 9		; fileext

NextExtChar:				; ...
		cld
		lodsb
		call	testkanj
		jz	short ddf4
		call	PRINT_CHAR
		dec	cx
		jz	short ddDone
		lodsb
		jmp	short ddf2
; ---------------------------------------------------------------------------

ddf4:					; ...
		test	[cs:_Bits], 10h	; mask.lcase
		jz	short ddf2
		call	LowerCase

ddf2:					; ...
		call	PRINT_CHAR
		loop	NextExtChar

ddDone:					; ...
		pop	es
		assume es:nothing
		pop	ds
		assume ds:nothing
		cld
		retn
endp		DisplayDotForm


; =============== S U B	R O U T	I N E =======================================


proc		DisplayFile near	; ...
		test	[ds:_Bits], 8	; mask.bare
		jz	short dfNorm
		call	DisplayBare
		jmp	short dhRet
; ---------------------------------------------------------------------------

dfNorm:					; ...
		call	DisplayNext
		test	[ds:_Bits], 1	; mask.wide
		jz	short dfFull
		call	DisplayWide
		jmp	short dfCnt
; ---------------------------------------------------------------------------

dfFull:					; ...
		call	DisplayName
		call	DisplayTheRest

dfCnt:					; ...
		call	CountFile

dhRet:					; ...
		retn
endp		DisplayFile


; =============== S U B	R O U T	I N E =======================================


proc		DisplayHeader near	; ...
		test	[ds:_Bits], 8	; mask.bare
		jnz	short dhRet
		test	[ds:_Bits], 4	; mask.subd
		jz	short dhNorm
		call	CRLF2
		call	UseLine
		jmp	short dhCom
; ---------------------------------------------------------------------------

dhNorm:					; ...
		mov	al, 20h	; ' '
		call	PRINT_CHAR

dhCom:					; ...
		call	build_dir_string
		mov	dx, offset dirhead_ptr
		call	std_printf
		call	UseLine
		call	CRLF2
		call	UseLine

dhRet:					; ...
		retn
endp		DisplayHeader


; =============== S U B	R O U T	I N E =======================================


proc		DisplayName near	; ...
		push	ds
		mov	ds, [ds:TPA]
		mov	si, bx
		add	si, 1
		mov	di, offset CHARBUF
		mov	cx, 8
		cld
		rep movsb
		mov	al, 20h	; ' '
		stosb
		mov	cx, 3
		rep movsb
		xor	al, al
		stosb
		pop	ds
		test	[ds:_Bits], 10h	; mask.lcase
		jz	short dn1
		mov	si, offset CHARBUF
		call	LowercaseString

dn1:					; ...
		mov	[ds:string_ptr_2], offset CHARBUF
		mov	dx, offset string_buf_ptr
		call	std_printf
		retn
endp		DisplayName


; =============== S U B	R O U T	I N E =======================================


proc		DisplayNext near	; ...
		cmp	[ds:FileCnt], 0
		jz	short dn1st
		cmp	[ds:LeftOnLine], 0
		jle	short dnEol
		mov	dx, offset tab_ptr
		call	std_printf
		jmp	short dnDone
; ---------------------------------------------------------------------------

dnEol:					; ...
		call	CRLF2
		call	UseLine

dn1st:					; ...
		mov	al, [ds:PerLine]
		mov	[ds:LeftOnLine], al

dnDone:					; ...
		dec	[ds:LeftOnLine]
		retn
endp		DisplayNext


; =============== S U B	R O U T	I N E =======================================


proc		DisplayTheRest near	; ...
		push	es
		mov	es, [ds:TPA]
		mov	bp, bx
		test	[byte ptr es:bp+0Ch], 10h ; [es:bp+EntryStruc.fileattr],ATTR_DIRECTORY
		jz	short drNonDir
		cmp	[ds:nocommas], 0
		jnz	short dr_2
		mov	[ds:string_ptr_2], offset twospacechars	; "  "
		mov	dx, offset string_buf_ptr
		call	std_printf

dr_2:					; ...
		mov	dx, offset dmes_ptr ; MSG_1068
		cmp	[ds:bfree_not_kilo], 0
		jz	short dr_3
		mov	dx, offset space_4_ptr

dr_3:					; ...
		call	std_printf
		jmp	short drCom
; ---------------------------------------------------------------------------

drNonDir:				; ...
		mov	dx, [es:bp+11h]	; [es:bp+EntryStruc.filesize]
		mov	[ds:File_Size_Low], dx
		mov	dx, [es:bp+13h]	; [es:bp+EntryStruc.filesize+2]
		mov	[ds:File_Size_High], dx
		mov	dx, offset disp_file_size_ptr
		cmp	[ds:narrow], 0
		jnz	short dr_4	; narrow display
		mov	dx, offset disp_file_size_w_ptr	; big file (wide)

dr_4:					; ...
		cmp	[ds:bfree_not_kilo], 0
		jz	short dr_5	; big file
		mov	dx, offset disp_file_size_n_ptr	; not big file

dr_5:					; ...
		call	std_printf

drCom:					; ...
		mov	ax, [es:bp+0Fh]	; [es:bp+EntryStruc.filedate]
		or	ax, ax
		jnz	short dr_6
		jmp	drDone
; ---------------------------------------------------------------------------

dr_6:					; ...
		mov	bx, ax
		and	ax, 1Fh		; AX = day of month
		mov	dl, al
		mov	ax, bx		; AX = date word
		mov	cl, 5
		shr	ax, cl		; shift	day out
		and	al, 0Fh		; AL = month
		mov	dh, al
		mov	cl, bh
		shr	cl, 1		; CL = year - 1980
		xor	ch, ch		; CX = year - 1980
		add	cx, 1980	; CX = 4-digit year
		cmp	[ds:yeardigit4], 0
		jnz	short dr_1
		sub	cx, 2000	; after	year 2000
		jns	short dr_1
		add	cx, 100		; before year 2000

dr_1:					; ...
		xchg	dh, dl
		mov	[ds:DirDat_Yr],	cx
		mov	[ds:DirDat_Mo_Day], dx
		mov	cx, [es:bp+0Dh]	; [es:bp+EntryStruc.filetime]
		jcxz	short drPrint	; no time field	- go print
		shr	cx, 1
		shr	cx, 1
		shr	cx, 1		; CH = hours
		shr	cl, 1
		shr	cl, 1		; CL = minutes
		xchg	ch, cl		; CX = hr/min
		mov	[ds:DirTim_Hr_Min], cx

drPrint:				; ...
		mov	[ds:dirdattim_ptr], 1077 ; MSG_1077 (normal)
		mov	[ds:DirDat_form], 0A4h ; Right_Align+DATE_MDY_2
		mov	[word ptr ds:DirDat_width], 80Ah ; 10 (max), 8 (min)
		cmp	[ds:narrow], 0
		jnz	short dr_narrow
		mov	[ds:dirdattim_ptr], 1075 ; MSG_1075 (narrow)
		add	[word ptr ds:DirDat_width], 202h ; 12 (max), 10	(min)

dr_narrow:				; ...
		cmp	[ds:yeardigit4], 0
		jz	short dr_7
		mov	[ds:DirDat_form], 0B4h ; Right_Align+DATE_MDY_4
		add	[word ptr ds:DirDat_width], 202h ; 12 (max), 10	(min)

dr_7:					; ...
		mov	dx, offset dirdattim_ptr
		call	std_printf
		mov	[ds:dirdattim_ptr], 1077 ; MSG_1077
		mov	[ds:DirDat_form], 0A4h ; Right_Align+DATE_MDY_2
		mov	[word ptr ds:DirDat_width], 80Ah ; 10 (max), 8 (min)
		mov	[ds:DirDat_Yr],	0 ; word
		mov	[ds:DirDat_Mo_Day], 0 ;	word
		mov	[ds:DirTim_Hr_Min], 0 ;	word

drDone:					; ...
		pop	es
		mov	bx, bp
		retn
endp		DisplayTheRest


; =============== S U B	R O U T	I N E =======================================


proc		DisplayTrailer near	; ...
		test	[ds:_Bits], 8
		jnz	short dtrRet
		call	CRLF2
		call	UseLine
		mov	ax, [ds:FileCnt]
		xor	dx, dx
endp		DisplayTrailer


; =============== S U B	R O U T	I N E =======================================


proc		DisplayCntSiz near	; ...
		mov	[ds:Dir_Num], ax
		mov	[ds:Dir_Num+2],	dx
		mov	dx, offset dirmes_ptr
		cmp	[ds:narrow], 0
		jnz	short dcs_1
		mov	dx, offset dirmes_w_ptr

dcs_1:					; ...
		cmp	[ds:bfree_not_kilo], 0
		jz	short dcs_2
		mov	dx, offset dirmes2_ptr

dcs_2:					; ...
		call	std_printf
		mov	cx, [ds:FileSiz+4]
		jcxz	short dcs_3
		mov	dx, [ds:FileSiz+3]
		mov	ax, [ds:FileSiz+1]
		ror	ch, 1
		rcr	dx, 1
		rcr	ax, 1
		ror	ch, 1
		rcr	dx, 1
		rcr	ax, 1
		mov	[ds:FileSiz+2],	dx
		mov	[ds:FileSiz], ax
		mov	dx, offset kbytes_ptr
		cmp	[ds:bfree_not_kilo], 0
		jz	short dcs_5
		mov	dx, offset kybytes_n_ptr
		jmp	short dcs_5
; ---------------------------------------------------------------------------

dcs_3:					; ...
		mov	dx, offset bytes_ptr
		cmp	[ds:narrow], 0
		jnz	short dcs_4
		mov	dx, offset bytes_w_tr

dcs_4:					; ...
		cmp	[ds:bfree_not_kilo], 0
		jz	short dcs_5
		mov	dx, offset bytes_n_ptr

dcs_5:					; ...
		call	std_printf
		call	UseLine

dtrRet:					; ...
		retn
endp		DisplayCntSiz


; =============== S U B	R O U T	I N E =======================================


proc		DisplayWide near	; ...
		push	ds
		mov	ds, [ds:TPA]
		test	[byte ptr bx+0Ch], 10h ; [bx+EntryStruc.fileattr],ATTR_DIRECTORY
		jz	short dw1
		mov	al, 5Bh	; '['
		call	PRINT_CHAR

dw1:					; ...
		call	DisplayDotForm
		test	[byte ptr bx+0Ch], 10h
		jz	short dw2
		mov	al, 5Dh	; ']'
		call	PRINT_CHAR

dw2:					; ...
		mov	cx, 12		; 8+3+1
		sub	cx, dx		; CX = # pad char's
		jcxz	short dwDone
		mov	al, 20h	; ' '

dw3:					; ...
		call	PRINT_CHAR
		loop	dw3

dwDone:					; ...
		pop	ds
		retn
endp		DisplayWide


; =============== S U B	R O U T	I N E =======================================


proc		EndPage	near		; ...
		test	[ds:_Bits], 2	; mask.pagd
		jz	short epNew
		push	bx
		push	cx
		call	PAUSE
		call	build_dir_string
		mov	dx, offset dircont_ptr
		call	Printf_Crlf
		pop	cx
		pop	bx

epNew:					; ...
		mov	ax, [ds:LinPerPag]
		dec	ax
		mov	[ds:LeftOnPage], ax
		retn
endp		EndPage


; =============== S U B	R O U T	I N E =======================================


proc		GetDriveLtr near	; ...
		mov	al, [ds:5Ch]	; [FCB]
		or	al, al
		jnz	short gdl1
		mov	al, [ds:CURDRV]
		inc	al

gdl1:					; ...
		add	al, 40h	; '@'   ; 'A'-1
		mov	ah, 3Ah	; ':'
		retn
endp		GetDriveLtr


; =============== S U B	R O U T	I N E =======================================


proc		SetupParamError	near	; ...
		mov	ax, 9
		mov	[ds:msg_disp_class], 2 ; parse_msg_class
		mov	[ds:extend_buf_ptr], ax
		mov	si, [bx+4]	; [bx+ResultBuffer.ValuePtr]
		mov	[ds:string_ptr_2], si
		mov	[ds:extend_buf_sub], 1 ; one_subst
		mov	dx, offset extend_buf_ptr
		retn
endp		SetupParamError


; =============== S U B	R O U T	I N E =======================================


proc		UseLine	near		; ...
		dec	[ds:LeftOnPage]	; word
		cmp	[ds:LeftOnPage], 2
		ja	short ulRet
		call	EndPage

ulRet:					; ...
		retn
endp		UseLine


; =============== S U B	R O U T	I N E =======================================


proc		ZeroTotals near		; ...
		mov	di, offset FileCntTotal
		mov	cx, 12
		xor	al, al
		rep stosb
		retn
endp		ZeroTotals

; ---------------------------------------------------------------------------

CtrlCHandler:				; ...
		push	ds
		push	cs
		pop	ds
		assume ds:TRANGROUP
		push	ax
		push	bx
		push	dx
		call	RestUDir
		pop	dx
		pop	bx
		pop	ax
		pop	ds
		assume ds:nothing
		jmp	[cs:OldCtrlCHandler]

; =============== S U B	R O U T	I N E =======================================


proc		LowerCase near		; ...
		cmp	al, 41h	; 'A'
		jb	short lcRet
		cmp	al, 5Ah	; 'Z'
		ja	short lcRet
		or	al, 20h		; convert to ASCII lowercase

lcRet:					; ...
		retn
endp		LowerCase


; =============== S U B	R O U T	I N E =======================================


proc		LowercaseString	near	; ...
		push	di
		mov	di, si
		cld

NextChar:				; ...
		lodsb
		or	al, al
		jz	short EndOfString
		call	testkanj
		jz	short NextChar_@
		stosb
		lodsb
		or	al, al
		jz	short EndOfString
		stosb
		jmp	short NextChar
; ---------------------------------------------------------------------------

NextChar_@:				; ...
		call	LowerCase
		stosb
		jmp	short NextChar
; ---------------------------------------------------------------------------

EndOfString:				; ...
		pop	di
		retn
endp		LowercaseString


; =============== S U B	R O U T	I N E =======================================


proc		CheckDBCSTailByte near	; ...
		push	ax
		push	cx
		push	di
		mov	cx, di

cdtb_check:				; ...
		cmp	di, si
		jz	short cdtb_next
		dec	di
		mov	al, [di]
		call	testkanj
		jnz	short cdtb_check ; not Kanji
		inc	di

cdtb_next:				; ...
		sub	cx, di
		xor	cl, 1
		test	cl, 1
		pop	di
		pop	cx
		pop	ax
		retn
endp		CheckDBCSTailByte


; =============== S U B	R O U T	I N E =======================================


proc		PAUSE near		; ...
		mov	dx, offset PAUSEMES_PTR
		call	std_printf
		call	GETKEYSTROKE
		call	CRLF2
		retn
endp		PAUSE

; ---------------------------------------------------------------------------

ERASE:					; ...
		mov	si, 81h		; get command line
		mov	[ds:COMSW], 0	; word
		mov	di, offset PARSE_ERASE
		xor	cx, cx

erase_scan:				; ...
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0FFFFh
		jz	short good_line
		cmp	ax, 0
		jnz	short errj2
		cmp	[ds:PARSE1_SYN], offset	SLASH_P_SYN ; "/P"
		jz	short set_erase_prompt
		push	si
		lds	si, [ds:PARSE1_ADDR]
		cmp	[byte ptr si+1], 3Ah ; ':'
		jnz	short erase_drive_ok
		cmp	[byte ptr si+2], 0
		jnz	short erase_drive_ok
		mov	ax, 2		; ERROR_FILE_NOT_FOUND
		jmp	short extend_setup
; ---------------------------------------------------------------------------

erase_drive_ok:				; ...
		call	Move_To_SrcBuf
		pop	si
		jmp	short erase_scan
; ---------------------------------------------------------------------------

set_erase_prompt:			; ...
		cmp	[ds:COMSW], 0
		jz	short ok_to_set_erase_prompt
		mov	ax, 1		; MoreArgs_Ptr
		call	setup_parse_error_msg
		jmp	short errj2
; ---------------------------------------------------------------------------

ok_to_set_erase_prompt:			; ...
		inc	[ds:COMSW]	; word
		jmp	short erase_scan
; ---------------------------------------------------------------------------

good_line:				; ...
		call	PathCrunch
		jnb	short checkdr
		mov	ax, [ds:Msg_Numb]
		cmp	ax, 0
		jnz	short extend_setup
		cmp	[ds:DestIsDir],	0
		jnz	short badpath_err

checkdr:				; ...
		cmp	[ds:COMSW], 0
		jz	short notest2j
		jmp	slashp_erase
; ---------------------------------------------------------------------------

notest2j:				; ...
		jmp	notest2
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR BUILDPATH

badpath_err:				; ...
		mov	ax, 3		; ERROR_PATH_NOT_FOUND

extend_setup:				; ...
		mov	[ds:msg_disp_class], 1 ; ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	[ds:extend_buf_ptr], ax

errj2:					; ...
		jmp	cerror
; END OF FUNCTION CHUNK	FOR BUILDPATH
; ---------------------------------------------------------------------------

CRENAME:				; ...
		mov	si, 81h
		mov	di, offset PARSE_RENAME
		xor	cx, cx
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0
		jnz	short crename_parse_error
		push	si
		lds	si, [ds:PARSE1_ADDR]
		call	Move_To_SrcBuf
		pop	si
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0
		jnz	short crename_parse_error
		push	si
		lds	si, [ds:PARSE1_ADDR]
		mov	al, 3Ah	; ':'
		cmp	[si+1],	al
		jnz	short ren_no_drive
		mov	[ds:msg_disp_class], 2
		mov	dx, offset extend_buf_ptr
		mov	[ds:extend_buf_ptr], 0Ah ; BadParm_Ptr
		pop	si

crename_parse_error:			; ...
		jmp	short errj
; ---------------------------------------------------------------------------

ren_no_drive:				; ...
		mov	di, 6Ch		; FCB+10h
		mov	ax, 2901h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		lodsb
		mov	[ds:One_Char_Val], al
		pop	si
		mov	di, offset PARSE_RENAME
		call	parse_check_eol
		jnz	short crename_parse_error
		call	PathCrunch
		mov	dx, offset BADCPMES_PTR
		jz	short errj2
		jnb	short notest3
		mov	ax, [ds:Msg_Numb]
		cmp	ax, 0
		jnz	short extend_setup
		cmp	[ds:DestIsDir],	0
		jz	short notest3
		jmp	badpath_err
; ---------------------------------------------------------------------------

notest3:				; ...
		mov	al, [ds:One_Char_Val]
		mov	dx, offset INORNOT_PTR
		call	pathchrcmp
		jz	short errj
		mov	ah, 17h		; FCB_Rename
		mov	dx, 5Ch		; FCB
		call	int_21h_indirect
		cmp	al, 0FFh
		jnz	short renameok
		call	get_ext_error_number
		push	ax
		mov	al, 0FFh

renameok:				; ...
		push	ax
		call	RestUDir
		pop	ax
		inc	al
		jz	short rn1
		retn
; ---------------------------------------------------------------------------

rn1:					; ...
		pop	ax
		cmp	ax, 2		; ERROR_FILE_NOT_FOUND
		jz	short use_renerr
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		jz	short use_renerr
		jmp	extend_setup
; ---------------------------------------------------------------------------

use_renerr:				; ...
		mov	dx, offset RENERR_PTR

errj:					; ...
		jmp	cerror
; ---------------------------------------------------------------------------
		retn
; ---------------------------------------------------------------------------

TYPEFIL:				; ...
		mov	si, 81h
		mov	di, offset PARSE_MRDIR
		xor	cx, cx
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0
		jnz	short typefil_parse_error
		push	si
		lds	si, [ds:PARSE1_ADDR]
		call	Move_To_SrcBuf
		pop	si
		mov	di, offset PARSE_MRDIR
		call	parse_check_eol
		jz	short gottarg

typefil_parse_error:			; ...
		jmp	cerror
; ---------------------------------------------------------------------------

gottarg:				; ...
		call	SETPATH
		test	[ds:DestInfo], 2
		jz	short nowilds
		mov	dx, offset INORNOT_PTR
		jmp	cerror
; ---------------------------------------------------------------------------

nowilds:				; ...
		mov	ax, 6C00h	; ExtOpen SHL 8
		mov	bx, 0		; read_open_mode
		xor	cx, cx		; no special files
		mov	dx, 101h	; read_open_flag
		mov	si, offset SrcBuf
		call	int_21h_indirect
		jnb	short typecont

typerr:					; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		call	Set_Ext_Error_Msg
		mov	[string_ptr_2],	offset SrcBuf
		mov	[extend_buf_sub], 1 ; one_subst
		jmp	cerror
; ---------------------------------------------------------------------------

typecont:				; ...
		mov	bx, ax
		mov	ax, 4400h	; (IOCTL shl 8)	or 0
		call	int_21h_indirect
		test	dl, 80h
		jz	short not_device
		mov	[File_Size_High], 0FFFFh ; indicate it is a device
		jmp	short dotype
; ---------------------------------------------------------------------------

not_device:				; ...
		mov	ax, 4202h	; (LSEEK shl 8)	or 2
		xor	dx, dx
		mov	cx, dx
		call	int_21h_indirect
		mov	[File_Size_Low], ax
		mov	[File_Size_High], dx
		mov	ax, 4200h	; (LSEEK shl 8)	or 0
		xor	dx, dx
		call	int_21h_indirect

dotype:					; ...
		mov	[zflag], 0
		mov	ds, [TPA]
		assume ds:RESGROUP
		xor	dx, dx

typelp:					; ...
		cmp	[cs:zflag], 0	; Is the ^Z flag set?
		jz	short tf1	; no
		retn			; yes, return
; ---------------------------------------------------------------------------

tf1:					; ...
		mov	cx, [cs:BYTCNT]
		cmp	[cs:File_Size_High], 0FFFFh ; -1 ; is it a device?
		jz	short typ_read	; yes, just read from it
		cmp	[cs:File_Size_High], 0 ; word
		jz	short lt64k
		sub	[cs:File_Size_Low], cx
		sbb	[cs:File_Size_High], 0
		jmp	short typ_read
; ---------------------------------------------------------------------------

lt64k:					; ...
		cmp	cx, [cs:File_Size_Low]
		jbe	short gtbuf
		mov	cx, [cs:File_Size_Low]
		jcxz	short typelp_ret
		mov	[cs:File_Size_Low], 0 ;	word
		jmp	short typ_read
; ---------------------------------------------------------------------------

gtbuf:					; ...
		sub	[cs:File_Size_Low], cx

typ_read:				; ...
		mov	ah, 3Fh		; read
		call	int_21h_indirect
		jnb	short tf2
		jmp	typerr
; ---------------------------------------------------------------------------

tf2:					; ...
		mov	cx, ax
		jcxz	short typelp_ret
		push	ds
		pop	es
		assume es:RESGROUP
		xor	di, di		; Check	to see if a ^Z was read.
		push	ax
		mov	al, 1Ah
		repne scasb
		pop	ax
		xchg	ax, cx
		cmp	ax, 0
		jnz	short foundz
		cmp	[byte ptr di-1], 1Ah ; double check
		jnz	short typecont2	; No ^Z, continue

foundz:					; ...
		sub	cx, ax
		dec	cx
		push	cs
		pop	es
		assume es:TRANGROUP
		not	[es:zflag]	; Turn on ^Z flag so that the routine
					;  will	quit after this	write.

typecont2:				; ...
		push	bx
		mov	bx, 1
		mov	ah, 40h	; '@'   ; Write
		call	int_21h_indirect
		pop	bx
		jb	short Error_outputj
		cmp	ax, cx
		jnz	short tf3
		jmp	typelp
; ---------------------------------------------------------------------------

tf3:					; ...
		dec	cx
		cmp	ax, cx
		jnz	short Error_outputj

tf4:					; ...
		retn
; ---------------------------------------------------------------------------

Error_outputj:				; ...
		mov	bx, 1
		mov	ax, 4400h	; IOCTL	SHL 8
		call	int_21h_indirect
		test	dl, 80h
		jnz	short tf4
		jmp	error_output
; ---------------------------------------------------------------------------

typelp_ret:				; ...
		retn
; ---------------------------------------------------------------------------

VOLUME:					; ...
		mov	si, 81h
		mov	di, offset PARSE_VOL
		xor	cx, cx
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0FFFFh
		jz	short OkVolArg
		cmp	ax, 0
		jnz	short badvolarg
		mov	di, offset PARSE_VOL
		xor	dx, dx
		call	parse_check_eol
		jz	short OkVolArg

badvolarg:				; ...
		jmp	cerror

; =============== S U B	R O U T	I N E =======================================


proc		DisAppend near		; ...
		push	ds
		push	es
		push	di
		mov	ax, 0B700h	; APPENDINSTALL
		call	int_2Fh_indirect
		or	al, al
		jz	short daRet
		mov	ax, 0B702h	; APPENDDOS
		call	int_2Fh_indirect
		cmp	ax, 0FFFFh
		jnz	short daRet
		mov	ax, 0B706h	; APPENDGETSTATE
		call	int_2Fh_indirect
		mov	ds, [ds:RESSEG]
		assume ds:nothing
		mov	[ds:Append_State], bx
		mov	[ds:Append_Flag], 0FFh ; -1
		xor	bx, bx
		mov	ax, 0B707h	; APPENDSETSTATE
		call	int_2Fh_indirect

daRet:					; ...
		pop	di
		pop	es
		assume es:nothing
		pop	ds
		retn
endp		DisAppend


; =============== S U B	R O U T	I N E =======================================


proc		OkVolArg near		; ...
		call	DisAppend
		call	CRLF2
		mov	al, 20h	; ' '   ; black (space)
		call	PRINT_CHAR
		push	ds
		pop	es
		mov	di, 55h		; FCB-7
		mov	al, 0FFh	; -1
		stosb
		xor	ax, ax
		stosw
		stosw
		stosb
		mov	al, 8		; ATTR_VOLUME_ID
		stosb
		inc	di
		mov	cx, 11
		mov	al, 3Fh	; '?'
		rep stosb
		mov	dx, offset BWDBUF ; DIRBUF
		mov	ah, 1Ah		; Set_DMA
		call	int_21h_indirect
		mov	dx, 55h		; FCB-7
		mov	ah, 11h		; Dir_Search_First
		call	int_21h_indirect
		push	ax
		mov	al, [ds:5Ch]	; [FCB]
		add	al, 40h	; '@'
		cmp	al, 40h	; '@'
		jnz	short drvok
		mov	al, [ds:CURDRV]
		add	al, 41h	; 'A'

drvok:					; ...
		mov	[ds:vol_drv], al
		pop	ax
		or	al, al
		jz	short Get_vol_name
		mov	dx, offset VolMes_Ptr_2
		jmp	short print_serial
; ---------------------------------------------------------------------------

Get_vol_name:				; ...
		mov	di, offset CHARBUF
		mov	dx, di
		mov	si, (offset BWDBUF+8) ;	offset DIRBUF+8
		mov	cx, 11
		rep movsb
		xor	al, al
		stosb
		mov	dx, offset VolMes_Ptr

print_serial:				; ...
		push	dx
		mov	ax, 6900h	; (GetSetMediaID SHL 8)
		mov	bl, [ds:5Ch]	; [FCB]
		mov	dx, offset vol_ioctl_buf
		call	int_21h_indirect
		pop	dx
		jb	short printvol_end
		call	std_printf
		mov	al, 20h	; ' '   ; blank (space)
		call	PRINT_CHAR
		mov	dx, offset VolSerMes_Ptr

printvol_end:				; ...
		jmp	std_printf
endp		OkVolArg


; =============== S U B	R O U T	I N E =======================================


proc		Set_Ext_Error_Msg near	; ...
		call	get_ext_error_number
		mov	[ds:msg_disp_class], 1 ; ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	[ds:extend_buf_ptr], ax
		stc
		retn
endp		Set_Ext_Error_Msg


; =============== S U B	R O U T	I N E =======================================


proc		get_ext_error_number near ; ...
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		push	bp
		push	es
		push	ds
		mov	ah, 59h		; GetExtendedError
		xor	bx, bx
		int	21h		; DOS -	3+ - GET EXTENDED ERROR	CODE
					; BX = version code (0000h for DOS 3.x)
		pop	ds
		pop	es
		pop	bp
		pop	di
		pop	si
		pop	dx
		pop	cx
		pop	bx
		retn
endp		get_ext_error_number

; ---------------------------------------------------------------------------

VERSION:				; ...
		mov	si, 81h
		mov	di, offset PARSE_VER
		xor	cx, cx
		call	Parse_With_Msg
		mov	bl, 1
		cmp	ax, 0
		jz	short verPrintVer
		dec	bl
		cmp	ax, 0FFFFh	; END_OF_LINE
		jz	short verPrintVer
		jmp	cerror
; ---------------------------------------------------------------------------

verPrintVer:				; ...
		push	bx
		call	CRLF2
		call	PRINT_VERSION
		call	CRLF2
		mov	ax, 3306h
		int	21h		; DOS -	5+ Get TRUE Version Number (BL major, BH minor,	DL revision, DH	flags)
		mov	al, dl
		mov	bh, dh
		cmp	al, 25		; 'Z'-'A'
		jbe	short ver1
		mov	al, 0E9h	; '*'-'A' ; -23

ver1:					; ...
		add	al, 30h		; '0'
		mov	[ds:One_Char_Val], al
		mov	dx, offset dosrev_ptr ;	MSG_1090
		call	std_printf
		pop	dx
		or	dl, dl
		jz	short verDone	; Revision 0
		mov	cl, 4
		shr	bh, cl
		jb	short verRom
		shr	bh, 1
		jb	short verHma	; MSG_1093
		mov	dx, offset DosLow_Ptr
		jmp	short verPrintLoc
; ---------------------------------------------------------------------------

verRom:					; ...
		mov	dx, offset DosRom_Ptr ;	MSG_1091
		jmp	short verPrintLoc
; ---------------------------------------------------------------------------

verHma:					; ...
		mov	dx, offset DosHma_Ptr ;	MSG_1092

verPrintLoc:				; ...
		call	std_printf

verDone:				; ...
		jmp	CRLF2

; =============== S U B	R O U T	I N E =======================================


proc		PRINT_VERSION near	; ...
		mov	ah, 30h
		int	21h		; DOS -	GET DOS	VERSION
					; Return: AL = major version number (00h for DOS 1.x)
		push	ax
		xor	ah, ah
		mov	[ds:Major_Ver_Num], ax
		pop	ax
		xchg	ah, al
		xor	ah, ah
		mov	[ds:Minor_Ver_Num], ax
		mov	dx, offset VerMes_Ptr ;	MSG_1040
		jmp	std_printf
endp		PRINT_VERSION


; =============== S U B	R O U T	I N E =======================================


proc		PRINT_PROMPT near	; ...
		push	ds
		push	cs
		pop	ds
		assume ds:TRANGROUP
		push	es
		pushf

PP0:					; ...
		mov	ax, 4A10h	; SMARTDRV INSTALLATION	CHECK (*)
		mov	bx, 0		; (*)
		int	2Fh
		cmp	ax, 0BABEh	; 0BABEh if installed
		jnz	short PP1
		cmp	cx, 0		; number of dirty cache	elements
		jnz	short PP3

PP1:					; ...
		popf
		call	find_prompt
		jb	short PP2
		cmp	[byte ptr es:di], 0
		jnz	short PP4

PP2:					; ...
		push	ds
		pop	es
		assume es:TRANGROUP
		call	build_dir_for_prompt
		call	PRINT_G
		jmp	short PP8
; ---------------------------------------------------------------------------

PP3:					; ...
		mov	ax, 4A10h	; SMARTDRV - FLUSH BUFFERS (**)
		mov	bx, 1		; (**)
		int	2Fh
		jmp	short PP0
; ---------------------------------------------------------------------------

PP4:					; ...
		mov	al, [es:di]
		inc	di
		or	al, al
		jz	short PP8
		cmp	al, '$'
		jz	short PP5
		call	PRINT_CHAR
		jmp	short PP4
; ---------------------------------------------------------------------------

PP5:					; ...
		mov	al, [es:di]
		inc	di
		mov	bx, offset PROMPT_TABLE_3 ; PROMPT_TABLE-3
		or	al, al
		jz	short PP8

PP6:					; ...
		add	bx, 3
		call	UPCONV
		cmp	al, [bx]
		jz	short PP7
		cmp	[byte ptr bx], 0
		jnz	short PP6
		jmp	short PP4
; ---------------------------------------------------------------------------

PP7:					; ...
		push	es
		push	di
		push	cs
		pop	es
		call	[word ptr bx+1]
		pop	di
		pop	es
		assume es:nothing
		jmp	short PP4
; ---------------------------------------------------------------------------

PP8:					; ...
		pop	es
		pop	ds
		assume ds:nothing
		retn
endp		PRINT_PROMPT

; ---------------------------------------------------------------------------

PRINT_BACK:				; ...
		mov	dx, offset dback_ptr
		jmp	std_printf
; ---------------------------------------------------------------------------

PRINT_EQ:				; ...
		mov	al, 3Dh	; '='
		jmp	short PRINT_CHAR
; ---------------------------------------------------------------------------

PRINT_R:				; ...
		push	ds
		mov	ds, [ds:RESSEG]
		mov	al, [byte ptr ds:RetCode]
		pop	ds
		xor	ah, ah
		mov	dl, 10
		mov	si, offset RetCode_str ; "000"
		div	dl
		add	ah, 30h	; '0'
		mov	[si+2],	ah
		xor	ah, ah
		div	dl
		add	ax, 3030h
		mov	[si], ax
		cmp	al, 30h	; '0'
		jnz	short Print_R_@
		inc	si
		cmp	ah, 30h	; '0'
		jnz	short Print_R_@
		inc	si

Print_R_@:				; ...
		mov	[ds:string_ptr_2], si
		clc
		jmp	short Print_R_@@
; ---------------------------------------------------------------------------
RetCode_str	db '000',0              ; ...
; ---------------------------------------------------------------------------

PRINT_ESC:				; ...
		mov	al, 1Bh
		jmp	short PRINT_CHAR

; =============== S U B	R O U T	I N E =======================================


proc		PRINT_G	near		; ...
		mov	al, 3Eh	; '>'   ; RABRACKET
		jmp	short PRINT_CHAR
endp		PRINT_G

; ---------------------------------------------------------------------------

PRINT_L:				; ...
		mov	al, 3Ch	; '<'   ; LABRACKET
		jmp	short PRINT_CHAR
; ---------------------------------------------------------------------------

Print_B:				; ...
		mov	al, 7Ch	; '|'   ; VBAR

; =============== S U B	R O U T	I N E =======================================


proc		PRINT_CHAR near		; ...
		push	es
		push	ds
		pop	es
		push	di
		push	dx
		mov	dl, al
		mov	ah, 2		; STD_CON_OUTPUT
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		pop	dx
		pop	di
		pop	es
		retn
endp		PRINT_CHAR

; ---------------------------------------------------------------------------

PRINT_DRIVE:				; ...
		mov	ah, 19h
		int	21h		; DOS -	GET DEFAULT DISK NUMBER
		add	al, 41h	; 'A'
		call	PRINT_CHAR
		retn

; =============== S U B	R O U T	I N E =======================================


proc		build_dir_for_prompt near ; ...
		xor	dl, dl
		mov	si, offset BWDBUF
		mov	di, si
		mov	al, [ds:CURDRV]
		add	al, 'A'
		mov	ah, ':'
		stosw
		mov	al, [ds:DIRCHAR]
		stosb
		xchg	si, di
		mov	[ds:string_ptr_2], di
		mov	ah, 47h
		int	21h		; DOS -	2+ - GET CURRENT DIRECTORY
					; DL = drive (0=default, 1=A, etc.)
					; DS:SI	points to 64-byte buffer area

Print_R_@@:				; ...
		mov	dx, offset string_buf_ptr
		jnb	short doprint
		mov	dx, offset BADCURDRV

doprint:				; ...
		call	std_printf
		retn
endp		build_dir_for_prompt


; =============== S U B	R O U T	I N E =======================================


proc		build_dir_for_chdir near ; ...
		call	build_dir_string
		mov	dx, offset BWDBUF ; DIRBUF
		mov	[ds:string_ptr_2], dx
		mov	dx, offset string_buf_ptr
		call	std_printf
		retn
endp		build_dir_for_chdir


; =============== S U B	R O U T	I N E =======================================


proc		build_dir_string near	; ...
		mov	dl, [ds:5Ch]	; FCB
		mov	al, dl
		add	al, 40h	; '@'
		cmp	al, 40h	; '@'
		jnz	short gotdrive
		add	al, [ds:CURDRV]
		inc	al

gotdrive:				; ...
		push	ax
		mov	si, (offset BWDBUF+3)
		mov	ah, 47h
		int	21h		; DOS -	2+ - GET CURRENT DIRECTORY
					; DL = drive (0=default, 1=A, etc.)
					; DS:SI	points to 64-byte buffer area
		jnb	short dpbisok
		push	cs
		pop	ds
		assume ds:TRANGROUP
		jmp	DRVBAD
; ---------------------------------------------------------------------------

dpbisok:				; ...
		mov	di, offset BWDBUF
		mov	dx, di
		pop	ax
		mov	ah, ':'
		stosw
		mov	al, [DIRCHAR]
		stosb
		retn
endp		build_dir_string


; =============== S U B	R O U T	I N E =======================================


proc		PATH near		; ...
		xor	al, al
		mov	di, offset SRCXNAME
		stosb
		dec	di
		call	PGETARG
		jz	short disppath
		cmp	al, 3Bh	; ';'   ; semicolon
		jnz	short pathslp
		inc	si
		jmp	short scan_white
; ---------------------------------------------------------------------------

pathslp:				; ...
		lodsb
		cmp	al, 0Dh		; END_OF_LINE_IN
		jz	short path_eol
		call	testkanj	; See if DBCS
		jz	short notkanj2	; No - continue
		stosb
		lodsb

path_hold:				; ...
		stosb
		jmp	short pathslp
; ---------------------------------------------------------------------------

notkanj2:				; ...
		call	UPCONV		; upper	case the character
		cmp	al, 3Bh	; ';'   ; semicolon
		jz	short path_hold
		call	DELIM
		jnz	short path_hold

scan_white:				; ...
		lodsb
		cmp	al, 0Dh		; END_OF_LINE_IN
		jz	short path_eol
		cmp	al, 20h	; ' '   ; blank
		jz	short scan_white
		cmp	al, 9		; tab_chr
		jz	short scan_white
		mov	dx, offset extend_buf_ptr
		mov	[extend_buf_ptr], 1 ; MoreArgs_Ptr
		mov	[msg_disp_class], 2 ; parse_msg_class
		jmp	cerror
; ---------------------------------------------------------------------------

path_eol:				; ...
		xor	al, al
		stosb
		call	find_path
		call	delete_path
		call	scan_double_null
		call	move_name
		mov	si, offset SRCXNAME

store_path:				; ...
		lodsb
		cmp	al, 0
		jz	short got_paths
		call	store_char
		jmp	short store_path
; ---------------------------------------------------------------------------

got_paths:				; ...
		xor	ax, ax
		stosw
		retn
; ---------------------------------------------------------------------------

disppath:				; ...
		call	find_path
		call	print_path
		call	CRLF2
		retn
endp		PATH


; =============== S U B	R O U T	I N E =======================================


proc		print_path near		; ...
		cmp	[byte ptr es:di], 0
		jnz	short path1

path0:					; ...
		mov	dx, offset NULLPATH_PTR
		push	cs
		pop	es
		assume es:TRANGROUP
		push	cs
		pop	ds
		jmp	std_printf
; ---------------------------------------------------------------------------

path1:					; ...
		push	es
		pop	ds
		sub	di, 5
		mov	si, di
		call	SCASB2		; Look for null
		cmp	cx, 0FFh
		jz	short path0
		push	cs
		pop	es
		mov	di, offset TPBUF ; Arg_Buf ; = TPBUF
		mov	dx, 256
		sub	dx, cx		; ch = 0
		xchg	dx, cx		; cl = neg cl (256-cl)
		rep movsb
		mov	dx, offset arg_buf_ptr
		push	cs
		pop	ds
		jmp	std_printf
endp		print_path


; =============== S U B	R O U T	I N E =======================================


proc		CLS near		; ...
		mov	ah, 1Ah
		mov	al, 0
		int	2Fh		; - Multiplex -	DOS 4+ ANSI.SYS	internal - INSTALLATION	CHECK
					; Return: AL = FFh if installed
		cmp	al, 0FFh
		jz	short ansicls
		mov	ax, 440Ch	; (IOCTL SHL 8)	+ generic_ioctl_handle
		mov	bx, 1		; handle
		mov	ch, 3		; CON device
		mov	cl, 7Fh		; minor	function, get display info
		mov	dx, offset Display_Ioctl
		int	21h		; DOS -	2+ - IOCTL -
		jb	short no_variable
		mov	ax, [LinPerPag]
		mov	dh, al
		mov	ax, [display_width]
		mov	dl, al
		jmp	short regcls
; ---------------------------------------------------------------------------

no_variable:				; ...
		mov	bx, 1		; stdout
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		test	dl, 80h		; devid_ISDEV
		jz	short ansicls
		test	dl, 10h		; devid_SPECIAL
		jnz	short cls_normal

ansicls:				; ...
		call	ansi_cls
		jmp	short cls_ret
; ---------------------------------------------------------------------------

cls_normal:				; ...
		mov	ah, 0Fh
		int	10h		; - VIDEO - GET	CURRENT	VIDEO MODE
					; Return: AH = number of columns on screen
					; AL = current video mode
					; BH = current active display page
		cmp	al, 3		; video_alpha
		jbe	short DoAlpha
		cmp	al, 7		; video_bw
		jz	short DoAlpha
		mov	ah, 0
		int	10h		; - VIDEO - SET	VIDEO MODE
					; AL = mode
		jmp	short cls_ret
; ---------------------------------------------------------------------------

DoAlpha:				; ...
		push	ds
		mov	ax, 40h		; ROMBIOS_DATA segment
		mov	ds, ax
		assume ds:nothing
		mov	dx, [ds:4Ah]	; [CRT_Cols]
		mov	dh, [ds:84h]	; [CRT_Rows]
		pop	ds
		assume ds:nothing
		or	dh, dh
		jnz	short regcls
		mov	dh, 25		; LINESPERPAGE

regcls:					; ...
		inc	dh
		call	reg_cls

cls_ret:				; ...
		retn
endp		CLS


; =============== S U B	R O U T	I N E =======================================


proc		reg_cls	near		; ...
		dec	dh		; Clear	the screen using INT 10H
		dec	dl
		push	dx
		mov	ah, 0Bh

loc_4CB3:
		xor	bx, bx
		int	10h		; - VIDEO - SET	COLOR PALETTE
					; BH = 00h, BL = border	color
					; BH = 01h, BL = palette (0-3)
		pop	dx
		xor	ax, ax
		mov	cx, ax
		mov	ah, 6
		mov	bh, 7
		xor	bl, bl
		int	10h		; - VIDEO - SCROLL PAGE	UP
					; AL = number of lines to scroll window	(0 = blank whole window)
					; BH = attributes to be	used on	blanked	lines
					; CH,CL	= row,column of	upper left corner of window to scroll
					; DH,DL	= row,column of	lower right corner of window
		mov	ah, 0Fh
		int	10h		; - VIDEO - GET	CURRENT	VIDEO MODE
					; Return: AH = number of columns on screen
					; AL = current video mode
					; BH = current active display page
		mov	ah, 2
		xor	dx, dx
		int	10h		; - VIDEO - SET	CURSOR POSITION
					; DH,DL	= row, column (0,0 = upper left)
					; BH = page number
		retn
endp		reg_cls


; =============== S U B	R O U T	I N E =======================================


proc		ansi_cls near		; ...
		mov	si, offset CLSSTRING
		lodsb
		mov	cl, al
		xor	ch, ch
		mov	ah, 6

clrloop:				; ...
		lodsb
		mov	dl, al
		int	21h		; DOS -	DIRECT CONSOLE I/O CHARACTER OUTPUT
					; DL = character <> FFh
					;  Return: ZF set = no character
					;   ZF clear = character recieved, AL =	character
		loop	clrloop
		retn
endp		ansi_cls


; =============== S U B	R O U T	I N E =======================================


proc		CTTY far		; ...
		push	ds
		pop	es
		assume es:nothing
		mov	si, 81h
		mov	di, offset PARSE_CTTY
		xor	cx, cx
		xor	dx, dx
		call	cmd_parse
		cmp	ax, 0FFFFh
		jz	short ctty_error
		cmp	ax, 0
		jnz	short ctty_error
		push	si
		lds	si, [ds:PARSE1_ADDR]
		mov	di, offset SrcBuf

ctty_move_filename:			; ...
		lodsb
		stosb
		cmp	al, 0
		jnz	short ctty_move_filename
		pop	si
		mov	di, offset PARSE_CTTY
		call	parse_check_eol
		jz	short nocolon

ctty_error:				; ...
		jmp	short isbaddev
; ---------------------------------------------------------------------------

nocolon:				; ...
		mov	dx, offset SrcBuf
		mov	ax, 3D02h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 2 - read & write
		jb	short isbaddev
		mov	bx, ax
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		test	dl, 80h
		jnz	short devisok

closedev:				; ...
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle

isbaddev:				; ...
		mov	dx, offset BADDEV_PTR
		call	std_printf
		jmp	short resret
; ---------------------------------------------------------------------------

devisok:				; ...
		push	dx
		mov	ax, [ds:acrlf_ptr]
		mov	dh, 0FFh	; -1
		push	bx
		call	TSYSGETMSG
		mov	dx, si
		mov	ax, 4000h	; (Write shl 8)
		mov	cx, 2
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		pop	bx
		pop	dx
		jb	short closedev
		xor	dh, dh
		or	dl, 3
		mov	ax, 4401h	; (IOCTL SHL 8)	OR 1
		int	21h		; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
					; BX = device handle, DH = 0
					; DL = device information to set (bits 0-7 from	function 0)
		push	bx
		mov	cx, 3
		xor	bx, bx

iclloop:				; ...
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		inc	bx
		loop	iclloop
		pop	bx
		mov	ah, 45h		; XDUP
		int	21h		; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
					; BX = file handle to duplicate
		mov	ah, 45h
		int	21h		; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
					; BX = file handle to duplicate
		mov	ah, 45h
		int	21h		; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
					; BX = file handle to duplicate
		mov	ah, 3Eh		; CLOSE
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle

resret:					; ...
		mov	ds, [ds:RESSEG]
		push	ds
		mov	ax, [ds:18h]	; [PDB.JFN_TABLE]
		mov	[ds:Io_Save], ax
		mov	ax, offset TrnLodCom1_Trap
		push	ax
		retf
endp		CTTY

; ---------------------------------------------------------------------------

CHCP:					; ...
		push	ds
		pop	es
		mov	si, 81h
		mov	di, offset PARSE_CHCP
		xor	cx, cx
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0FFFFh
		jz	short getcp
		cmp	ax, 0
		jnz	short cp_error
		push	cx
		mov	bx, offset PARSE1_ADDR
		mov	cx, [bx]
		mov	[ds:system_cpage], cx
		pop	cx
		mov	di, offset PARSE_CHCP
		call	parse_check_eol
		jnz	short cp_error
		mov	ah, 14h		; NLSFUNC
		mov	al, 0
		int	2Fh		; - Multiplex -	NLSFUNC.COM - INSTALLATION CHECK
					; Return: AL = 00h not installed, OK to	install
					; 01h not installed, not OK
					; FFh installed
		cmp	al, 0FFh
		jz	short got_NLS
		mov	dx, offset NLSFUNC_PTR
		jmp	short cp_error
; ---------------------------------------------------------------------------

got_NLS:				; ...
		mov	bx, [ds:system_cpage]
		mov	ah, 66h
		mov	al, 2
		int	21h		; DOS -	3.3+ - SET GLOBAL CODE PAGE TABLE
					; BX = active code page
					; DX = system code page	(active	page at	boot time)
		jnb	short chcp_return
		cmp	ax, 2		; ERROR_FILE_NOT_FOUND
		jnz	short chcp_other_error
		mov	ah, 59h
		xor	bx, bx
		int	21h		; DOS -	3+ - GET EXTENDED ERROR	CODE
					; BX = version code (0000h for DOS 3.x)
		cmp	ax, 0Dh		; ERROR_INVALID_DATA
		jnz	short no_countrysys
		mov	dx, offset INV_CODE_PAGE
		jmp	short cp_error
; ---------------------------------------------------------------------------

no_countrysys:				; ...
		mov	dx, offset NoCntry_Ptr
		jmp	short cp_error
; ---------------------------------------------------------------------------

chcp_other_error:			; ...
		mov	ah, 59h
		xor	bx, bx
		int	21h		; DOS -	3+ - GET EXTENDED ERROR	CODE
					; BX = version code (0000h for DOS 3.x)
		cmp	ax, 65		; was it access	denied?
		jnz	short none_set	; no - assume all failed
		mov	dx, offset cp_not_all_ptr
		jmp	short cp_error
; ---------------------------------------------------------------------------

none_set:				; ...
		mov	dx, offset cp_not_set_ptr

cp_error:				; ...
		jmp	cerror
; ---------------------------------------------------------------------------

getcp:					; ...
		mov	ah, 66h
		mov	al, 1
		int	21h		; DOS -	3.3+ - GET GLOBAL CODE PAGE TABLE
		mov	[ds:system_cpage], bx
		mov	dx, offset cp_active_ptr
		call	std_printf

chcp_return:				; ...
		retn
; ---------------------------------------------------------------------------

TRUENAME:				; ...
		push	ds
		pop	es
		mov	si, 81h
		mov	di, offset PARSE_CHDIR
		xor	cx, cx
		xor	dx, dx
		call	Parse_With_Msg
		mov	di, offset SRCXNAME
		cmp	ax, 0FFFFh
		jz	short tn_eol
		cmp	ax, 0
		jnz	short tn_parse_error
		cmp	[ds:PARSE1_OUTPUT], 6 ;	byte [PARSE1_TYPE],result_drive
		jz	short tn_drive
		jmp	short tn_filespec
; ---------------------------------------------------------------------------

tn_eol:					; ...
		mov	ah, 0		; END_OF_LINE_OUT
		mov	al, 2Eh	; '.'
		stosw
		jmp	short tn_doit
; ---------------------------------------------------------------------------

tn_drive:				; ...
		push	si
		mov	si, offset PARSE1_ADDR
		lodsb
		add	al, 40h	; '@'   ; "A"-1
		stosb
		mov	ax, 2E3Ah	; ':.' (NASM syntax)
		stosw
		mov	al, 0		; END_OF_LINE_OUT
		stosb
		pop	si
		jmp	short tn_check_eol
; ---------------------------------------------------------------------------

tn_filespec:				; ...
		push	si
		lds	si, [ds:PARSE1_ADDR]

tn_move_filename:			; ...
		lodsb
		stosb
		cmp	al, 0
		jnz	short tn_move_filename
		pop	si

tn_check_eol:				; ...
		mov	di, offset PARSE_CHDIR
		call	parse_check_eol
		jz	short tn_doit

tn_parse_error:				; ...
		jmp	cerror
; ---------------------------------------------------------------------------

tn_doit:				; ...
		mov	si, offset SRCXNAME
		mov	di, offset COMBUF
		mov	ax, 6000h	; ax = (xNameTrans<<8)
		int	21h		; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
					; DS:SI	-> ASCIZ relative path string or directory name
					; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
		jnb	short tn_print_xname
		call	Set_Ext_Error_Msg
		mov	[ds:string_ptr_2], offset SRCXNAME
		mov	[ds:extend_buf_sub], 1 ; one_subst
		jmp	cerror
; ---------------------------------------------------------------------------

tn_print_xname:				; ...
		mov	[ds:string_ptr_2], offset COMBUF
		mov	dx, offset string_buf_ptr
		call	CRLF2
		call	Printf_Crlf
		retn
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR PROMPTBAT

_$EXIT:					; ...
		push	ds
		mov	ds, [ds:RESSEG]
		cmp	[ds:PermCom], 0	; byte ; is this a permanent COMMAND?
		jz	short free_com	; no - free everything
		cmp	[ds:SingleCom],	0FFFFh ; -1
		jz	short free_com	; exit singlecom
		jmp	TCOMMAND	; permanent command, recycle
; ---------------------------------------------------------------------------

free_com:				; ...
		pop	ds
		call	RestUDir1
		mov	es, [ds:RESSEG]
		mov	ax, [es:Parent]
		mov	[es:16h], ax	; [es:PDB.PARENT_PID]
		mov	ax, [word ptr es:OldTerm]
		mov	[es:0Ah], ax	; [es:PDB.EXIT]
		mov	ax, [word ptr es:OldTerm+2]
		mov	[es:0Ch], ax	; [es:PDB.EXIT+2]
		push	es
		mov	es, [ds:TRAN_TPA]
		mov	ah, 49h		; DEALLOC
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		pop	es
		mov	ah, 4Ch		; Exit
		mov	al, [byte ptr es:RetCode]
		int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
; END OF FUNCTION CHUNK	FOR PROMPTBAT	; AL = exit code

; =============== S U B	R O U T	I N E =======================================


proc		parse_check_eol	near	; ...
		xor	dx, dx
		mov	[ds:parse_last], si
		call	cmd_parse
		cmp	al, 0FFh
		jz	short parse_good_eol
		cmp	ax, 0
		jnz	short ok_to_setup_pmsg
		inc	ax

ok_to_setup_pmsg:			; ...
		call	setup_parse_error_msg

parse_good_eol:				; ...
		retn
endp		parse_check_eol


; =============== S U B	R O U T	I N E =======================================


proc		Parse_With_Msg near	; ...
		mov	[ds:parse_last], si
		call	cmd_parse
		cmp	al, 0FFh
		jz	short parse_msg_good
		cmp	ax, 0
		jz	short parse_msg_good
		call	setup_parse_error_msg

parse_msg_good:				; ...
		retn
endp		Parse_With_Msg


; =============== S U B	R O U T	I N E =======================================


proc		setup_parse_error_msg near ; ...
		mov	[ds:msg_disp_class], 2 ; parse_msg_class
		mov	dx, offset extend_buf_ptr
		mov	[byte ptr si], 0 ; END_OF_LINE_OUT
		mov	[ds:extend_buf_ptr], ax
		cmp	ax, 2		; LessArgs_Ptr
		jz	short setup_parse_msg_ret
		mov	si, [ds:parse_last]
		mov	[ds:string_ptr_2], si
		mov	[ds:extend_buf_sub], 1 ; one_subst

setup_parse_msg_ret:			; ...
		inc	si
		retn
endp		setup_parse_error_msg

; ---------------------------------------------------------------------------

ADD_PROMPT:				; ...
		call	delete_prompt
		call	scan_double_null
		push	si
		call	GETARG
		pop	si
		jnz	short ADD_PROMPT3

ADD_PROMPT_RETN:			; ...
		retn
; ---------------------------------------------------------------------------

ADD_PROMPT3:				; ...
		call	move_name
		call	GETARG
		push	si
		jmp	short ADD_NAME
; ---------------------------------------------------------------------------

DISP_ENVJ:				; ...
		jmp	DISP_ENV
; ---------------------------------------------------------------------------

ADD_NAME_TO_ENVIRONMENT:		; ...
		call	GETARG
		jz	short DISP_ENVJ
		xor	bx, bx
		push	si

EQLP:					; ...
		lodsb
		cmp	al, 0Dh
		jz	short QUEQ
		cmp	al, 3Dh	; '='
		jnz	short EQLP
		inc	bl
		cmp	[byte ptr si], 0Dh
		jnz	short EQLP
		inc	bh
		jmp	short EQLP
; ---------------------------------------------------------------------------

QUEQ:					; ...
		pop	si
		dec	bl
		jz	short ONEQ
		mov	dx, offset SYNTMES_PTR
		jmp	cerror
; ---------------------------------------------------------------------------

ONEQ:					; ...
		push	bx
		call	delete_name_in_environment
		pop	bx
		dec	bh
		jz	short ADD_PROMPT_RETN
		call	scan_double_null
		mov	bx, di
		call	move_name
		push	si
		xchg	bx, di
		mov	[ds:comspec_flag], 0 ; byte
		mov	si, offset COMSPECSTR ;	"COMSPEC="
		mov	cx, 4
		repe cmpsw
		jnz	short NOT_COMSPEC
		inc	[ds:comspec_flag] ; byte

NOT_COMSPEC:				; ...
		mov	di, bx

ADD_NAME:				; ...
		pop	si
		push	si

ADD_NAME1:				; ...
		lodsb
		cmp	al, 0Dh		; 13
		jz	short ADD_NAME_RET
		call	store_char
		jmp	short ADD_NAME1
; ---------------------------------------------------------------------------

ADD_NAME_RET:				; ...
		pop	si
		cmp	[ds:comspec_flag], 0 ; byte

ADD_NAME_JZ_RET:			; ...
		jz	short ADD_PROMPT_RETN
		call	scanoff
		mov	es, [ds:RESSEG]
		mov	di, offset ComSpec
		mov	bx, di
		xor	ax, ax
		mov	[es:ComDrv], al
		push	ax
		mov	al, [si]
		call	testkanj
		pop	ax
		jnz	short _GOTDRIVE
		cmp	[byte ptr si+1], ':'
		jnz	short _GOTDRIVE
		mov	al, [si]
		call	UPCONV
		sub	al, 'A'
		add	di, 2
		inc	al
		mov	[es:ComDrv], al
		add	al, 40h	; '@'   ; 'A'-1

_GOTDRIVE:				; ...
		mov	[es:PutBackComSpec], di
		mov	[es:PutBackDrv], al
		mov	di, bx

COPY_COMSPEC:				; ...
		lodsb
		call	DELIM
		jz	short COPYDONE
		cmp	al, 0Dh		; 13
		jz	short COPYDONE
		stosb
		jmp	short COPY_COMSPEC
; ---------------------------------------------------------------------------

COPYDONE:				; ...
		xor	al, al
		stosb
		mov	[ds:comspec_flag], 0 ; byte
		dec	di
		mov	[es:ComSpec_End], di
		retn
; ---------------------------------------------------------------------------

DISP_ENV:				; ...
		mov	ds, [ds:RESSEG]
		mov	ds, [ds:EnvirSeg]
		xor	si, si

PENVLP:					; ...
		cmp	[byte ptr si], 0
		jz	short ADD_NAME_JZ_RET
		mov	di, offset TPBUF ; Arg_Buf

PENVLP2:				; ...
		lodsb
		stosb
		or	al, al
		jnz	short PENVLP2
		mov	dx, offset arg_buf_ptr
		push	ds
		push	es
		pop	ds
		call	Printf_Crlf
		pop	ds
		jmp	short PENVLP

; =============== S U B	R O U T	I N E =======================================


proc		delete_path near	; ...
		mov	si, offset PATH_TEXT ; "PATH="
		jmp	short delete_name_in_environment
; ---------------------------------------------------------------------------

delete_prompt:				; ...
		mov	si, offset PROMPT_TEXT ; "PROMPT="

delete_name_in_environment:		; ...
		push	si
		push	ds
		call	FIND
		jb	short del1
		mov	si, di
		call	SCASB2
		xchg	si, di
		cmp	[byte ptr es:si], 0
		jnz	short not_dnull
		dec	si

not_dnull:				; ...
		call	GETENVSIZ
		sub	cx, si
		push	es
		pop	ds
		rep movsb

del1:					; ...
		pop	ds
		pop	si
endp		delete_path


find_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


proc		find_path near		; ...
		mov	si, offset PATH_TEXT ; "PATH="
		jmp	short find_name_in_environment
endp		find_path


; =============== S U B	R O U T	I N E =======================================


proc		find_prompt near	; ...
		mov	si, offset PROMPT_TEXT ; "PROMPT="
endp		find_prompt


; =============== S U B	R O U T	I N E =======================================


proc		find_name_in_environment near ;	...
		call	FIND
		jb	short find_retn
		jmp	SCASB1
endp		find_name_in_environment


; =============== S U B	R O U T	I N E =======================================


proc		FIND near		; ...
		cld
		call	COUNT0
		mov	es, [ds:RESSEG]
		mov	es, [es:EnvirSeg]
		xor	di, di

find1:					; ...
		push	cx
		push	si
		push	di

find11:					; ...
		lodsb
		call	testkanj
		jz	short notkanj3
		dec	si
		lodsw
		inc	di
		inc	di
		cmp	ax, [es:di-2]
		jnz	short find12
		dec	cx
		loop	find11
		jmp	short find12
; ---------------------------------------------------------------------------

notkanj3:				; ...
		call	UPCONV
		inc	di
		cmp	al, [es:di-1]
		jnz	short find12
		loop	find11

find12:					; ...
		pop	di
		pop	si
		pop	cx
		jz	short find_retn
		push	cx
		call	SCASB2
		pop	cx
		cmp	[byte ptr es:di], 0
		jnz	short find1
		stc
		retn
endp		FIND


; =============== S U B	R O U T	I N E =======================================


proc		COUNT0 near		; ...
		push	ds
		pop	es
		mov	di, si
		push	di
		call	SCASB1
		jmp	short COUNTX
; ---------------------------------------------------------------------------
		push	di
		call	SCASB2

COUNTX:					; ...
		pop	cx
		sub	di, cx
		xchg	di, cx

move_name_retn:				; ...
		retn
endp		COUNT0


; =============== S U B	R O U T	I N E =======================================


proc		move_name near		; ...
		cmp	[byte ptr si], 0Dh
		jz	short move_name_retn
		lodsb
		call	testkanj
		jz	short notkanj1
		call	store_char
		lodsb
		call	store_char
		jmp	short move_name
; ---------------------------------------------------------------------------

notkanj1:				; ...
		call	UPCONV
		call	store_char
		cmp	al, 3Dh	; '='
		jnz	short move_name

getarg_retn:				; ...
		retn
endp		move_name


; =============== S U B	R O U T	I N E =======================================


proc		GETARG near		; ...
		mov	si, 80h
		lodsb
		or	al, al
		jz	short getarg_retn
		call	scanoff
		cmp	al, 0Dh		; 13

sdn_retn:				; ...
		retn
endp		GETARG


; =============== S U B	R O U T	I N E =======================================


proc		scan_double_null near	; ...
		mov	es, [ds:RESSEG]
		mov	es, [es:EnvirSeg]
		xor	di, di

sdn1:					; ...
		cmp	[byte ptr es:di], 0
		jz	short sdn_retn
		call	SCASB2
		jmp	short sdn1
endp		scan_double_null


; =============== S U B	R O U T	I N E =======================================


proc		SCASB1 near		; ...
		mov	al, 3Dh	; '='
		jmp	short SCASBX
endp		SCASB1


; =============== S U B	R O U T	I N E =======================================


proc		SCASB2 near		; ...
		xor	al, al

SCASBX:					; ...
		mov	cx, 256
		repne scasb
		retn
endp		SCASB2


; =============== S U B	R O U T	I N E =======================================


proc		testkanj near		; ...
		push	ds
		push	si
		push	ax
		mov	ds, [cs:RESSEG]
		assume ds:RESGROUP
		lds	si, [Dbcs_Vector_Addr]
		assume ds:nothing

ktlop:					; ...
		cmp	[word ptr si], 0
		jz	short notlead
		pop	ax
		push	ax
		cmp	al, [si]
		jb	short notlead
		inc	si
		cmp	al, [si]
		jbe	short islead
		inc	si
		jmp	short ktlop
; ---------------------------------------------------------------------------

notlead:				; ...
		xor	ax, ax
		jmp	short ktret
; ---------------------------------------------------------------------------

islead:					; ...
		xor	ax, ax
		inc	ax

ktret:					; ...
		pop	ax
		pop	si
		pop	ds
		retn
endp		testkanj


; =============== S U B	R O U T	I N E =======================================


proc		UPCONV near		; ...
		cmp	al, 80h		; see if char is > ascii 128
		jb	short oth_fucase ; no -	upper case math
		sub	al, 80h		; only upper 128 chars in table
		push	ds
		push	bx
		mov	ds, [ds:RESSEG]
		lds	bx, [dword ptr ds:FUCase_Addr+1] ; get table address
		add	bx, 2		; skip over first word
		xlat
		pop	bx
		pop	ds
		jmp	short upconv_end
; ---------------------------------------------------------------------------

oth_fucase:				; ...
		cmp	al, 61h	; 'a'
		jb	short upconv_end
		cmp	al, 7Ah	; 'z'
		ja	short upconv_end
		sub	al, 20h	; ' '   ; Change lower-case to upper

upconv_end:				; ...
		retn
endp		UPCONV


; =============== S U B	R O U T	I N E =======================================


proc		store_char near		; ...
		push	cx
		push	bx
		push	es
		push	ds
		mov	ds, [ds:RESSEG]
		mov	es, [ds:EnvirSeg]
		pop	ds
		call	GETENVSIZ
		mov	bx, cx
		sub	bx, 2
		cmp	di, bx
		jb	short store1
		push	ax
		push	cx
		push	bx
		call	FREE_TPA
		pop	bx
		add	bx, 2
		cmp	bx, 8000h
		jb	short envsiz_ok

bad_env_size:				; ...
		stc
		jmp	short envnoset
; ---------------------------------------------------------------------------

envsiz_ok:				; ...
		mov	cl, 4
		shr	bx, cl
		inc	bx
		mov	cx, es
		add	cx, bx
		add	cx, 20h	; ' '
		mov	ax, cs
		cmp	cx, ax
		jnb	short bad_env_size
		mov	ah, 4Ah
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs

envnoset:				; ...
		pushf
		push	es
		mov	es, [ds:RESSEG]
		call	ALLOC_TPA
		pop	es
		popf
		pop	cx
		pop	ax
		jnb	short store1
		pop	es
		mov	dx, offset ENVERR_PTR
		jmp	cerror
; ---------------------------------------------------------------------------

store1:					; ...
		stosb
		mov	[word ptr es:di], 0
		pop	es
		pop	bx
		pop	cx
		retn
endp		store_char


; =============== S U B	R O U T	I N E =======================================


proc		GETENVSIZ near		; ...
		push	es
		push	ax
		mov	ax, es
		dec	ax
		mov	es, ax
		assume es:nothing
		mov	ax, [es:3]	; [es:ARENA.size]
		mov	cl, 4
		shl	ax, cl		; Convert to bytes
		mov	cx, ax
		pop	ax
		pop	es
		assume es:nothing

getenvsiz_retn:				; ...
		retn
endp		GETENVSIZ


; =============== S U B	R O U T	I N E =======================================


proc		RestUDir1 near		; ...
		push	ds
		mov	ds, [ds:RESSEG]
		cmp	[ds:RestDir], 0	; byte
		pop	ds
		jz	short getenvsiz_retn

RestUDir:				; ...
		mov	dx, offset USERDIR1
		mov	ah, 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		xor	al, al		; 0
		call	SETREST
		retn
endp		RestUDir1


; =============== S U B	R O U T	I N E =======================================


proc		_$CHDIR	near		; ...
		mov	si, 81h
		mov	di, offset PARSE_CHDIR
		xor	cx, cx
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0FFFFh
		jz	short bwdj
		cmp	ax, 0
		jnz	short ChDirErr
		cmp	[ds:PARSE1_OUTPUT], 6 ;	byte [PARSE1_TYPE],result_drive
		jnz	short REALCD
		mov	di, offset PARSE_CHDIR
		xor	dx, dx
		call	parse_check_eol
		jnz	short ChDirErr

bwdj:					; ...
		call	build_dir_for_chdir
		call	CRLF2

chdir_retn:				; ...
		retn
; ---------------------------------------------------------------------------

REALCD:					; ...
		push	si
		lds	si, [ds:PARSE1_ADDR]
		call	Move_To_SrcBuf
		pop	si
		mov	di, offset PARSE_CHDIR
		xor	dx, dx
		call	parse_check_eol
		jnz	short ChDirErr
		call	SETPATH
		test	[ds:DestInfo], 2
		jnz	short BadChDir
		mov	ah, 3Bh		; CHDir
		call	int_21h_indirect
		jnb	short chdir_retn
		call	get_ext_error_number
		cmp	ax, 3		; ERROR_PATH_NOT_FOUND
		jz	short BadChDir
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		jz	short BadChDir
		call	set_ext_error_subst
		jmp	short ChDirErr
; ---------------------------------------------------------------------------

BadChDir:				; ...
		mov	dx, offset badcd_ptr

ChDirErr:				; ...
		call	std_eprintf

mkdir_retn:				; ...
		retn
endp		_$CHDIR


; =============== S U B	R O U T	I N E =======================================


proc		_$MKDIR	near		; ...
		call	SETRMMK
		jb	short MkDirErr
		mov	ah, 39h		; MKDIR
		call	int_21h_indirect
		jnb	short mkdir_retn
		call	get_ext_error_number
		cmp	ax, 3		; ERROR_PATH_NOT_FOUND
		jz	short MD_other_err
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		jz	short badmderr
		call	set_ext_error_subst
		jmp	short MkDirErr
; ---------------------------------------------------------------------------

badmderr:				; ...
		mov	dx, offset SRCXNAME
		mov	ah, 1Ah		; Set_DMA
		call	int_21h_indirect
		mov	ah, 4Eh	; 'N'   ; Find_First
		mov	cx, 10h		; ATTR_DIRECTORY
		call	int_21h_indirect
		jb	short MD_other_err
		mov	dl, [ds:SRCXNAME+15h] ;	[SRCXNAME+FIND_BUF.ATTR] ; [SRCXNAME+21]
		test	dl, 10h		; ATTR_DIRECTORY
		jz	short MD_other_err
		mov	dx, offset MD_EXISTS_PTR
		jmp	short MkDirErr
; ---------------------------------------------------------------------------

MD_other_err:				; ...
		mov	dx, offset badmkd_ptr

MkDirErr:				; ...
		call	std_eprintf

rmdir_retn:				; ...
		retn
endp		_$MKDIR


; =============== S U B	R O U T	I N E =======================================


proc		SETRMMK	near		; ...
		mov	si, 81h
		mov	di, offset PARSE_MRDIR
		xor	cx, cx
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0
		jnz	short noargerr
		mov	di, offset SRCXNAME
		push	di
		push	si
		lds	si, [ds:PARSE1_ADDR]

mrdir_move_filename:			; ...
		lodsb
		stosb
		cmp	al, 0
		jnz	short mrdir_move_filename
		pop	si
		mov	di, offset PARSE_MRDIR
		call	parse_check_eol
		pop	dx
		jz	short rmdir_retn

noargerr:				; ...
		mov	dx, offset extend_buf_ptr
		xor	ax, ax
		stc

setrmmk_retn:				; ...
		retn
endp		SETRMMK


; =============== S U B	R O U T	I N E =======================================


proc		_$RMDIR	near		; ...
		call	SETRMMK
		jb	short RmDirErr
		jnz	short badrderr
		mov	ah, 3Ah		; RMDIR
		call	int_21h_indirect
		jnb	short setrmmk_retn
		call	get_ext_error_number
		cmp	ax, 3		; ERROR_PATH_NOT_FOUND
		jz	short badrderr
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		jz	short badrderr
		call	set_ext_error_subst
		jmp	short RmDirErr
; ---------------------------------------------------------------------------

badrderr:				; ...
		mov	dx, offset badrmd_ptr

RmDirErr:				; ...
		call	std_eprintf

savudir_err_retn:			; ...
		retn
endp		_$RMDIR


; =============== S U B	R O U T	I N E =======================================


proc		set_ext_error_subst near ; ...
		mov	[ds:msg_disp_class], 1 ; ext_msg_class
		mov	[ds:string_ptr_2], dx
		mov	[ds:extend_buf_sub], 1 ; one_subst
		mov	dx, offset extend_buf_ptr
		mov	[ds:extend_buf_ptr], ax
		retn
endp		set_ext_error_subst


; =============== S U B	R O U T	I N E =======================================


proc		SAVUDIR	near		; ...
		mov	di, offset USERDIR1

SAVUDIR1:				; ...
		mov	al, dl
		add	al, 40h	; '@'
		cmp	al, 40h	; '@'
		jnz	short GOTUDRV
		add	al, [ds:CURDRV]
		inc	al		; A = 1

GOTUDRV:				; ...
		stosb
		mov	ah, [ds:DIRCHAR]
		mov	al, 3Ah	; ':'
		stosw
		push	es
		pop	ds
		mov	si, di
		mov	ah, 47h		; CURRENT_DIR
		call	int_21h_indirect
		jb	short savudir_err_retn
		push	cs
		pop	ds
		assume ds:TRANGROUP
		retn
endp		SAVUDIR


; =============== S U B	R O U T	I N E =======================================


proc		CRLF2 near		; ...
		push	dx
		mov	dx, offset acrlf_ptr
		push	ds
		push	cs
		pop	ds
		call	std_printf
		pop	ds
		assume ds:nothing
		pop	dx
		retn
endp		CRLF2


; =============== S U B	R O U T	I N E =======================================


proc		scanoff	near		; ...
		lodsb
		call	DELIM
		jz	short scanoff
		dec	si

scanoff_retn:				; ...
		retn
endp		scanoff


; =============== S U B	R O U T	I N E =======================================


proc		DELIM near		; ...
		cmp	al, 20h	; ' '
		jz	short scanoff_retn
		cmp	al, 3Dh	; '='
		jz	short scanoff_retn
		cmp	al, 2Ch	; ','
		jz	short scanoff_retn
		cmp	al, 3Bh	; ';'
		jz	short scanoff_retn
		cmp	al, 9
		jz	short scanoff_retn
		cmp	al, 0Ah
		retn
endp		DELIM


; =============== S U B	R O U T	I N E =======================================


proc		FCB_TO_ASCZ near	; ...
		mov	cx, 8

MAINNAME:				; ...
		lodsb
		cmp	al, 20h	; ' '
		jz	short SKIPSPC
		stosb

SKIPSPC:				; ...
		loop	MAINNAME
		lodsb
		cmp	al, 20h	; ' '
		jz	short GOTNAME
		mov	ah, al
		mov	al, 2Eh	; '.'
		stosb
		xchg	al, ah
		stosb
		mov	cl, 2

EXTNAME:				; ...
		lodsb
		cmp	al, 20h	; ' '
		jz	short GOTNAME
		stosb
		loop	EXTNAME

GOTNAME:				; ...
		xor	al, al
		stosb

STRCOMP_RETN:				; ...
		retn
endp		FCB_TO_ASCZ


; =============== S U B	R O U T	I N E =======================================


proc		STRCOMP	near		; ...
		cmpsb
		jnz	short STRCOMP_RETN ; Strings not equal
		cmp	[byte ptr si-1], 0 ; Hit NUL terminator?
		jz	short STRCOMP_RETN ; Yes, strings equal
		jmp	short STRCOMP
endp		STRCOMP


; =============== S U B	R O U T	I N E =======================================


proc		CRPRINT	near		; ...
		push	ax
		mov	al, 0Dh		; 13
		push	cx
		push	di
		mov	di, dx
		mov	cx, 0FFFFh	; 65535
		push	es
		push	ds
		pop	es
		repne scasb
		mov	[byte ptr di-1], 0 ; nul terminate the string
		pop	es
		mov	[ds:string_ptr_2], dx
		mov	dx, offset string_buf_ptr
		call	std_printf
		mov	[byte ptr di-1], 0Dh ; put the CR back
		jb	short error_output
		pop	di
		pop	cx
		pop	ax
		retn
; ---------------------------------------------------------------------------

error_output:				; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	es, [RESSEG]
		assume es:RESGROUP
		mov	dx, offset NOSPACE_PTR
		cmp	[es:PipeFlag], 0 ; byte
		jz	short go_to_error
		call	PipeOff
		mov	dx, offset PIPEEMES_PTR

go_to_error:				; ...
		jmp	cerror
endp		CRPRINT


; =============== S U B	R O U T	I N E =======================================


proc		pathchrcmp near		; ...
		push	ax
		mov	ah, 2Fh	; '/'
		cmp	[SWITCHAR], ah
		jz	short noslasht
		cmp	al, 2Fh	; '/'
		jz	short pccont

noslasht:				; ...
		cmp	al, 5Ch	; '\'

pccont:					; ...
		pop	ax
		retn
endp		pathchrcmp


; =============== S U B	R O U T	I N E =======================================


proc		PathCrunch near		; ...
		mov	[Msg_Numb], 0
		mov	dl, [5Ch]	; [FCB]
		call	SAVUDIR
		jb	short pcrunch_cderrj
		call	SETPATH
		test	[DestInfo], 2	; test if wildcards (? or *) seen
		jnz	short trypeel	; wildcard seen, peel filename
		mov	ah, 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		jnb	short chdir_worked
		call	get_ext_error_number
		cmp	ax, 3		; ERROR_PATH_NOT_FOUND
		jz	short trypeel
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		jz	short trypeel
		mov	[Msg_Numb], ax
		jmp	peelfail
; ---------------------------------------------------------------------------

chdir_worked:				; ...
		call	SetRest1
		mov	al, '?'
		mov	di, 5Dh		; FCB+1
		mov	cx, 11
		rep stosb
		xor	al, al
		retn
; ---------------------------------------------------------------------------

pcrunch_cderrj:				; ...
		jmp	pcrunch_cderr
; ---------------------------------------------------------------------------

trypeel:				; ...
		mov	si, [PathPos]
		dec	si
		mov	al, [si-1]
		cmp	[KPARSE], 0
		jnz	short delstrt
		call	pathchrcmp
		jz	short peelfail

delstrt:				; ...
		mov	cx, si
		mov	si, dx
		push	dx

delloop:				; ...
		cmp	si, cx
		jz	short gotdele
		lodsb
		call	testkanj
		jz	short notkanj8
		inc	si
		jmp	short delloop
; ---------------------------------------------------------------------------

notkanj8:				; ...
		call	pathchrcmp
		jnz	short delloop
		mov	dx, si
		dec	dx
		jmp	short delloop
; ---------------------------------------------------------------------------

gotdele:				; ...
		mov	si, dx
		pop	dx
		cmp	si, dx
		jz	short badret
		mov	cx, si
		mov	si, dx

delloop2:				; ...
		cmp	si, cx
		jz	short trycd
		mov	[KPARSE], 0	; byte
		lodsb
		call	testkanj
		jz	short delloop2
		inc	si
		inc	[KPARSE]	; byte
		jmp	short delloop2
; ---------------------------------------------------------------------------

trycd:					; ...
		push	ax
		mov	al, 2Eh	; '.'
		cmp	[si+1],	al
		jnz	short trycd1
		cmp	[si+2],	al
		jz	short trycd1
		cmp	[byte ptr si+2], 0

trycd1:					; ...
		pop	ax
		jz	short peelfail
		mov	al, [si-1]
		cmp	al, 3Ah	; ':'
		jz	short badret
		cmp	[KPARSE], 0	; byte
		jnz	short notdoublesl
		call	pathchrcmp
		jnz	short notdoublesl

peelfail:				; ...
		stc
		retn
; ---------------------------------------------------------------------------

notdoublesl:				; ...
		mov	[byte ptr si], 0
		mov	ah, 3Bh
		call	int_21h_indirect
		jnb	short cdsucc

pcrunch_cderr:				; ...
		call	get_ext_error_number
		mov	[Msg_Numb], ax
		or	si, si
		stc

pcrunch_retn:				; ...
		retn
; ---------------------------------------------------------------------------

badret:					; ...
		mov	al, [si]
		call	pathchrcmp
		stc
		jnz	short pcrunch_retn
		xor	bl, bl
		xchg	bl, [si+1]
		mov	ah, 3Bh	; ';'
		call	int_21h_indirect
		jb	short pcrunch_cderr
		mov	[si+1],	bl

cdsucc:					; ...
		call	SetRest1
		inc	si
		mov	[DestTail], si
		pushf
		cmp	[DirFlag], 0FFh	; -1
		jz	short pcrunch_end
		mov	di, 5Ch		; FCB
		mov	ax, 2902h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing

pcrunch_end:				; ...
		popf
		retn
endp		PathCrunch

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR SWITCH

RETSW:					; ...
		xchg	ax, bx
		retn
; END OF FUNCTION CHUNK	FOR SWITCH

; =============== S U B	R O U T	I N E =======================================


proc		SWITCH near		; ...

; FUNCTION CHUNK AT 2C49 SIZE 00000002 BYTES

		xor	bx, bx

SWLOOP:					; ...
		call	scanoff
		cmp	al, [SWITCHAR]
		jnz	short RETSW
		or	bx, 8000h	; FSWITCH
		inc	si
		call	scanoff
		cmp	al, 0Dh
		jz	short RETSW
		inc	si
		call	UPCONV
		mov	di, offset switch_list ; "-Y?VBAPW"
		mov	cx, 8
		repne scasb
		jnz	short BADSW
		mov	ax, 1
		shl	ax, cl
		or	bx, ax
		jmp	short SWLOOP
; ---------------------------------------------------------------------------

BADSW:					; ...
		jmp	short SWLOOP
endp		SWITCH

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR PROMPTBAT

DRVBAD:					; ...
		mov	dx, offset baddrv_ptr
		jmp	cerror
; END OF FUNCTION CHUNK	FOR PROMPTBAT
; ---------------------------------------------------------------------------

EXTERNALJ:				; ...
		jmp	EXTERNAL
; ---------------------------------------------------------------------------

FNDCOM:					; ...
		or	al, al
		jz	short EXTERNALJ
		call	test_append
		jz	short CONTCOM

APPEND_INTERNAL:			; ...
		mov	cl, [IDLEN]
		mov	ch, 0
		mov	[PathPos], cx
		inc	[append_exec]	; byte
		call	IOSET
		mov	si, offset IDLEN
		mov	dx, 0FFFFh
		mov	di, offset append_parse
		mov	ax, 0AE01h
		int	2Fh		; - Multiplex -	DOS 3.3+ internal - INSTALLABLE	COMMAND	- EXECUTE
					; DX = FFFFh, DS:SI -> buffer
					; Return: buffer at DS:SI filled with a	length byte followed by	the uppercase
					; internal command to execute (if length not 0)
		cmp	[IDLEN], 0
		jnz	short CONTCOM
		jmp	CMD_DONE
; ---------------------------------------------------------------------------

CONTCOM:				; ...
		mov	di, offset COMTAB ; "\x03DIR"
		xor	cx, cx

FINDCOM:				; ...
		mov	si, offset ID
		mov	cl, [di]
		inc	di
		jcxz	short EXTERNALJ
		cmp	cl, [IDLEN]
		jnz	short ABCD
		mov	[PathPos], cx
		repe cmpsb

ABCD:					; ...
		lahf
		add	di, cx
		mov	al, [di]
		mov	[CHKDRV], al
		inc	di
		mov	bx, [di]
		inc	di
		inc	di
		mov	dx, [di]
		inc	di
		inc	di
		sahf
		jnz	short FINDCOM
		cmp	[append_exec], 0 ; byte
		jnz	short DONT_SET_IO
		call	IOSET

DONT_SET_IO:				; ...
		mov	ax, [COMSW]
		or	ax, [ARGTS]	; [AllSwitch]
		and	ax, 20h		; SwitchQues
		jz	short DRIVE_CHECK
		test	[CHKDRV], 4	; byte [CHKDRV],fLimitHelp
		jz	short DO_HELP
		cmp	[ARG_ARGVCNT], 2 ; [ARG+ARG_UNIT.argvcnt]
		jnz	short DRIVE_CHECK

DO_HELP:				; ...
		mov	si, dx
		mov	ax, 0
		push	ax

NEXT_HELP_MSG:				; ...
		lodsw
		or	ax, ax
		jz	short HELP_DONE
		push	ax
		mov	dx, sp
		call	std_printf
		pop	ax
		jmp	short NEXT_HELP_MSG
; ---------------------------------------------------------------------------

HELP_DONE:				; ...
		pop	ax
		jmp	TCOMMAND
; ---------------------------------------------------------------------------

DRIVE_CHECK:				; ...
		test	[CHKDRV], 1	; byte [CHKDRV],FCHECKDRIVE
		jz	short NOCHECK
		mov	al, [PARM1]
		or	al, [PARM2]
		cmp	al, 0FFh	; -1
		jnz	short NOCHECK
		jmp	DRVBAD
; ---------------------------------------------------------------------------

NOCHECK:				; ...
		call	cmd_copy
		test	[CHKDRV], 2	; byte [CHKDRV],fSwitchAllowed
		jnz	short REALWORK
		call	noswit
		jnz	short REALWORK
		mov	[msg_disp_class], 2 ; parse_msg_class
		mov	dx, offset extend_buf_ptr
		mov	[extend_buf_ptr], 3 ; BadSwt_Ptr
		jmp	cerror
; ---------------------------------------------------------------------------

REALWORK:				; ...
		call	bx

CMD_DONE:				; ...
		push	cs
		pop	ds
		push	ds
		mov	ds, [RESSEG]
		assume ds:RESGROUP
		cmp	[Call_Flag], 1	; call_in_progress
		mov	[Call_Flag], 0
		pop	ds
		assume ds:nothing
		jz	short INCALL
		jmp	TCOMMAND
; ---------------------------------------------------------------------------

INCALL:					; ...
		jmp	DOCOM0

; =============== S U B	R O U T	I N E =======================================


proc		noswit near		; ...
		push	di
		mov	di, 81h
		mov	si, 80h
		lodsb
		mov	cl, al
		xor	ch, ch
		mov	al, [cs:SWITCHAR]
		cmp	al, 0
		repne scasb
		pop	di
		retn
endp		noswit

; ---------------------------------------------------------------------------

EXTERNAL:				; ...
		call	test_append
		jz	short NOT_BARRYF
		jmp	APPEND_INTERNAL
; ---------------------------------------------------------------------------

NOT_BARRYF:				; ...
		mov	[cs:IFNOTFLAG],	0 ; byte [cs:FILTYP],0
		mov	dl, [cs:SPECDRV]
		mov	[cs:IDLEN], dl
		mov	[cs:ROM_CALL], 0 ; byte
		push	dx
		mov	dx, offset IDLEN
		call	ROM_SCAN
		pop	dx
		jnb	short DO_SCAN
		inc	[cs:ROM_CALL]	; byte
		jmp	short $+2

DO_SCAN:				; ...
		mov	di, offset EXECPATH
		mov	[byte ptr di], 0
		cmp	[cs:ROM_CALL], 0 ; byte
		jnz	short NEOEXECUTE
		call	path_search
		or	ax, ax
		jz	short BADCOMJ45
		cmp	ax, 4
		jge	short NEOEXECUTE ; jge short EXECUTE
					; ... .BAT file	...
		mov	dx, offset EXECPATH
		mov	ax, 3D00h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jb	short BATCOMJ
		and	[word ptr ds:TPBUF], 0 ; clear 1st two bytes of	the buffer
		mov	dx, offset TPBUF
		mov	cx, 2
		mov	bx, ax
		mov	ah, 3Fh
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		cmp	[word ptr ds:TPBUF], 2A2Fh ; '/*' (NASM syntax)
		jnz	short BATCOMJ
		mov	ax, offset REXX_EXE ; "REXX.EXE"
		mov	[ds:ARG_ARGV], ax ; [ARG+ARGV_ELE.argpointer]
		mov	[ds:ARGV0_ARG_FLAGS], 0	; [ARG+ARGV_ELE.argflags]
		mov	[ds:ARGV0_ARGSTARTEL], ax ; [ARG+ARGV_ELE.argstartel]
		mov	[ds:ARGV0_ARGLEN], 8 ; [ARG+ARGV_ELE.arglen]
		mov	[ds:ARGV0_ARGSW_WORD], 0 ; [ARG+ARGV_ELE.argsw_word]
		mov	[ds:ARGV0_OCOMPTR], ax ; [ARG+ARGV_ELE.arg_ocomptr]
					; pointer into original	command	string
		call	path_search
		test	ax, ax
		jz	short rexx_nf_err
		mov	si, (offset COMBUF+1)
		mov	di, 80h		; PSP command tail (arguments)
		mov	cx, di		; 128
		rep movsb
		jmp	short NEOEXECUTE
; ---------------------------------------------------------------------------

rexx_nf_err:				; ...
		mov	dx, offset REXXNOTF_PTR	; MSG_1012 ; REXX.EXE not found
		jmp	short cerror
; ---------------------------------------------------------------------------

BATCOMJ:				; ...
		jmp	BATCOM
; ---------------------------------------------------------------------------

BADCOMJ45:				; ...
		jmp	short BADCOM
; ---------------------------------------------------------------------------

NEOEXECUTE:				; ...
		call	IOSET		; offset EXECUTE = offset NEOEXECUTE
; START	OF FUNCTION CHUNK FOR LoadHigh

LH_EXECUTE:				; ...
		mov	es, [ds:TRAN_TPA]
		assume es:nothing
		mov	ah, 49h		; DEALLOC
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	es, [ds:RESSEG]
		inc	[es:ExtCom]	; byte
		mov	[es:RestDir], 0	; byte
		mov	si, offset EXECPATH ; TRANGROUP:EXECPATH
		mov	di, offset MsgBuffer ; RESGROUP:SafePathBuffer
		mov	cx, 80
		cld
		rep movsb
		mov	di, 5Ch		; FCB
		mov	si, di
		mov	cx, 82
		rep movsw
		mov	dx, offset MsgBuffer ; SafePathBuffer
		push	es
		pop	ds
		mov	bx, offset EnvirSeg ; Exec_Block = offset EnvirSeg
		mov	ax, 4B00h	; EXEC*256
		test	[cs:ROM_CALL], 0FFh ; byte
		jz	short OK_EXEC
		jmp	ROM_EXEC
; ---------------------------------------------------------------------------

OK_EXEC:				; ...
		mov	cx, es
		mov	ss, cx
		mov	sp, offset RStack
		jmp	[cs:EXEC_ADDR]	; jmp far [cs:EXEC_ADDR]
; END OF FUNCTION CHUNK	FOR LoadHigh
; ---------------------------------------------------------------------------

BADCOM:					; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	dx, offset BADNAM_PTR
; START	OF FUNCTION CHUNK FOR TESTDOREIN

cerror:					; ...
		call	std_eprintf
		jmp	TCOMMAND
; END OF FUNCTION CHUNK	FOR TESTDOREIN

; =============== S U B	R O U T	I N E =======================================


proc		PRESCAN	near		; ...
		xor	cx, cx
		mov	es, [RESSEG]
		assume es:RESGROUP
		mov	si, (offset COMBUF+2)
		mov	di, si

COUNTQUOTES:				; ...
		lodsb
		cmp	al, 22h	; '"'
		jnz	short COUNTEND
		inc	ch
		jmp	short COUNTQUOTES
; ---------------------------------------------------------------------------

COUNTEND:				; ...
		cmp	al, 0Dh
		jnz	short COUNTQUOTES
		push	cx
		mov	si, di

KanjiScan:				; ...
		lodsb
		call	testkanj
		jz	short KanjiQuote
		mov	ah, al
		lodsb
		cmp	ax, 2020h	; DB_SPACE
		jnz	short KanjiScan
		mov	[word ptr si-2], 2020h
		jmp	short KanjiScan
; ---------------------------------------------------------------------------

KanjiQuote:				; ...
		cmp	al, 22h	; '"'
		jnz	short KanjiEnd
		dec	ch
		jz	short KanjiScan

KanjiQuoteLoop:				; ...
		lodsb
		cmp	al, 22h	; '"'
		jnz	short KanjiQuoteLoop
		dec	ch
		jmp	short KanjiScan
; ---------------------------------------------------------------------------

KanjiEnd:				; ...
		cmp	al, 0Dh
		jnz	short KanjiScan
		pop	cx
		mov	si, di

PRESCANLP:				; ...
		lodsb
		call	testkanj
		jz	short NOTKANJ6
		mov	[di], al
		inc	di
		lodsb
		mov	[di], al
		inc	di
		inc	cl
		inc	cl
		jmp	short PRESCANLP
; ---------------------------------------------------------------------------

NOTKANJ6:				; ...
		cmp	al, 22h	; '"'
		jnz	short TRYGREATER
		dec	ch
		jz	short TRYGREATER

QLOOP:					; ...
		mov	[di], al
		inc	di
		inc	cl
		lodsb
		cmp	al, 22h	; '"'
		jnz	short QLOOP
		dec	ch

TRYGREATER:				; ...
		cmp	al, 3Eh	; '>'   ; rabracket
		jnz	short NOOUT
		cmp	[si], al
		jnz	short NOAPPND
		lodsb
		inc	[es:Re_Out_App]	; byte ; Flag >>

NOAPPND:				; ...
		call	scanoff
		cmp	al, 3Ch	; '<'   ; labracket
		jz	short REOUT_ERRSET
		cmp	al, 0Dh
		jnz	short GOTREOFIL

REOUT_ERRSET:				; ...
		mov	[byte ptr di], 0Dh
		mov	[word ptr es:Re_OutStr], 9 ; word
		jmp	PRESCANEND
; ---------------------------------------------------------------------------

GOTREOFIL:				; ...
		push	di
		mov	di, offset Re_OutStr
		mov	bx, di
		push	es

SETREOUTSTR:				; ...
		push	cx
		mov	cx, 77		; 64+13	; CX = max string length

SETREOUTSTR_LOOP:			; ...
		lodsb
		cmp	al, 0Dh
		jz	short GOTRESTR_J
		call	DELIM
		jz	short GOTRESTR_J
		cmp	al, [SWITCHAR]
		jz	short GOTRESTR_J
		cmp	al, 22h	; '"'
		jz	short PIPEERRSYNJ5_J
		cmp	al, 3Ch	; '<'
		jz	short ABRACKET_TERM
		cmp	al, 3Eh	; '>'
		jnz	short NO_ABRACKET

ABRACKET_TERM:				; ...
		dec	si
		mov	al, 20h	; ' '

GOTRESTR_J:				; ...
		pop	cx
		jmp	short GOTRESTR
; ---------------------------------------------------------------------------

NO_ABRACKET:				; ...
		stosb
		call	testkanj
		jz	short NO_ABRACKET_@
		jcxz	short GOTRESTR_J
		lodsb
		cmp	al, 0Dh
		jz	short GOTRESTR_J
		stosb
		dec	cx

NO_ABRACKET_@:				; ...
		loop	SETREOUTSTR_LOOP
		jmp	short GOTRESTR_J
; ---------------------------------------------------------------------------

PIPEERRSYNJ5_J:				; ...
		pop	cx
		jmp	short PIPEERRSYNJ5
; ---------------------------------------------------------------------------

NOOUT:					; ...
		cmp	al, 3Ch	; '<'
		jnz	short CHKPIPE
		mov	bx, si
		call	scanoff
		cmp	al, 3Eh	; '>'
		jz	short REIN_ERRSET
		cmp	al, 0Dh
		jnz	short GOTREIFIL

REIN_ERRSET:				; ...
		mov	[byte ptr di], 0Dh
		mov	[word ptr RE_INSTR], 9
		jmp	short PRESCANEND
; ---------------------------------------------------------------------------

GOTREIFIL:				; ...
		push	di
		mov	di, offset RE_INSTR
		mov	bx, di
		push	es
		push	cs
		pop	es
		assume es:TRANGROUP
		jmp	short SETREOUTSTR
; ---------------------------------------------------------------------------

CHKPIPE:				; ...
		mov	ah, al
		cmp	ah, 7Ch	; '|'   ; ALTPIPECHR
		jz	short ISPIPE3
		cmp	ah, 7Ch	; '|'   ; VBAR
		jnz	short CONTPRESCAN

ISPIPE3:				; ...
		cmp	[es:PipeFlag], 0
		jnz	short NOECHOPUSH
		shl	[es:EchoFlag], 1

NOECHOPUSH:				; ...
		inc	[es:PipeFlag]	; byte
		call	scanoff
		cmp	al, 0Dh
		jz	short PIPEERRSYNJ5
		cmp	al, 7Ch	; '|'   ; ALTPIPECHR
		jz	short PIPEERRSYNJ5
		cmp	al, 7Ch	; '|'   ; VBAR
		jnz	short CONTPRESCAN

PIPEERRSYNJ5:				; ...
		push	es
		pop	ds
		jmp	PIPEERRSYN
; ---------------------------------------------------------------------------

GOTRESTR:				; ...
		xchg	ah, al
		mov	al, 3Ah	; ':'
		sub	bx, di
		cmp	bx, 0FFFFh	; -1
		jz	short NOTRAILCOL
		cmp	[es:di-1], al
		jnz	short NOTRAILCOL
		dec	di

NOTRAILCOL:				; ...
		xor	al, al		; 0
		stosb
		pop	es
		assume es:nothing
		pop	di

CONTPRESCAN:				; ...
		mov	[di], ah
		inc	di
		cmp	ah, 0Dh
		jz	short PRESCANEND
		inc	cl
		jmp	PRESCANLP
; ---------------------------------------------------------------------------

PRESCANEND:				; ...
		cmp	[es:PipeFlag], 0
		jz	short ISNOPIPE
		mov	di, 4BEh	; PipeStr ; RESGROUP:EndInit+160
					; ENDINIT is at	offset 41Eh
		mov	[es:4BCh], di	; mov [es:PipePtr],di
					; (RESGROUP:EndInit+158)
		mov	si, (offset COMBUF+2)
		call	scanoff

PIPESETLP:				; ...
		lodsb
		stosb
		cmp	al, 0Dh
		jnz	short PIPESETLP

ISNOPIPE:				; ...
		mov	[COMBUF+1], cl
		cmp	[es:PipeFlag], 0 ; [es::41Ch]
		push	cs
		pop	es
		assume es:TRANGROUP
		retn
endp		PRESCAN


; =============== S U B	R O U T	I N E =======================================


proc		cmd_copy near		; ...
		mov	si, (offset COMBUF+2)
		call	scanoff
		add	si, [PathPos]
		mov	di, 81h
		xor	cx, cx

cmdcopy:				; ...
		lodsb
		stosb
		cmp	al, 0Dh
		jz	short copy_done
		inc	cx
		jmp	short cmdcopy
; ---------------------------------------------------------------------------

copy_done:				; ...
		mov	[80h], cl
		retn
endp		cmd_copy


; =============== S U B	R O U T	I N E =======================================


proc		test_append near	; ...
		mov	bx, offset COMBUF
		mov	si, offset IDLEN
		mov	dx, 0FFFFh
		mov	ax, 0AE00h
		int	2Fh		; - Multiplex -	DOS 3.3+ internal - INSTALLABLE	COMMAND	- INSTALL CHECK
					; DX = FFFFh, DS:BX -> command line
					; Return: AL = FFh if this command is a	TSR extension to COMMAND.COM
					; AL = 00h if the command should be executed as	usual
		cmp	al, 0
		retn
endp		test_append


; =============== S U B	R O U T	I N E =======================================


proc		SETPATH	near		; ...
		mov	ax, [PathCnt]
		mov	si, [PathPos]
		mov	[DestInfo], 0	; byte
		mov	[DestIsDir], 0	; byte
		mov	si, [PathPos]
		mov	cx, [PathCnt]
		mov	dx, si
		jcxz	short PATHDONE
		push	cx
		push	si
		call	SWITCH
		mov	[PathSw], ax
		pop	bx
		sub	bx, si
		pop	cx
		add	cx, bx
		mov	dx, si

SKIPPATH:				; ...
		mov	[KPARSE], 0	; byte

SKIPPATH2:				; ...
		jcxz	short PATHDONE
		dec	cx
		lodsb
		call	testkanj
		jz	short TESTPPSEP
		dec	cx
		inc	si
		inc	[KPARSE]	; byte
		jmp	short SKIPPATH2
; ---------------------------------------------------------------------------

TESTPPSEP:				; ...
		call	pathchrcmp
		jnz	short TESTPMETA
		inc	[DestIsDir]	; byte

TESTPMETA:				; ...
		cmp	al, 3Fh	; '?'
		jnz	short TESTPSTAR
		or	[DestInfo], 2	; byte

TESTPSTAR:				; ...
		cmp	al, 2Ah	; '*'
		jnz	short TESTPDELIM
		or	[DestInfo], 2

TESTPDELIM:				; ...
		call	DELIM
		jz	short PATHDONEDEC
		cmp	al, [SWITCHAR]
		jnz	short SKIPPATH

PATHDONEDEC:				; ...
		dec	si

PATHDONE:				; ...
		xor	al, al
		xchg	al, [si]
		inc	si
		cmp	al, 0Dh
		jnz	short NOPSTORE
		mov	[si], al

NOPSTORE:				; ...
		mov	[PathPos], si
		mov	[PathCnt], cx

SETPATH_RETN:				; ...
		retn
endp		SETPATH


; =============== S U B	R O U T	I N E =======================================


proc		PGETARG	near		; ...
		mov	si, 80h
		lodsb
		or	al, al
		jz	short SETPATH_RETN
		call	PSCANOFF
		cmp	al, 0Dh
		retn
endp		PGETARG


; =============== S U B	R O U T	I N E =======================================


proc		PSCANOFF near		; ...
		lodsb
		call	DELIM
		jnz	short PSCANOFFD
		cmp	al, 3Bh	; ';'
		jnz	short PSCANOFF

PSCANOFFD:				; ...
		dec	si
		retn
endp		PSCANOFF


; =============== S U B	R O U T	I N E =======================================


proc		IOSET near		; ...
		push	ds
		push	dx
		push	ax
		push	bx
		push	cx
		mov	ds, [cs:RESSEG]
		assume ds:nothing
		cmp	[ds:PipeFlag], 0 ; byte
		jnz	short NOREDIR
		test	[ds:IfFlag], 0FFh
		jnz	short NOREDIR
		call	TESTDOREIN
		call	TESTDOREOUT

NOREDIR:				; ...
		pop	cx
		pop	bx
		pop	ax
		pop	dx
		pop	ds

IOSET_RETN:				; ...
		retn
endp		IOSET


; =============== S U B	R O U T	I N E =======================================


proc		TESTDOREIN near		; ...

; FUNCTION CHUNK AT 2E87 SIZE 00000006 BYTES

		cmp	[cs:RE_INSTR], 0
		jz	short IOSET_RETN
		push	ds
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	dx, offset RE_INSTR
		mov	ax, 3D40h	; mov ax,(OPEN*256)+SHARING_DENY_NONE
		mov	bx, ax
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read, 1 -	write, 2 - read	& write
		pop	ds
		assume ds:nothing
		jb	short REDIRERR
		mov	bx, ax
		mov	al, 0FFh
		xchg	al, [bx+18h]	; [bx+PDB.JFN_TABLE]
		mov	[ds:18h], al	; [PDB.JFN_TABLE]
		retn
; ---------------------------------------------------------------------------

REDIRERR:				; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		call	TriageError
		cmp	ax, 65		; network access denied
		jz	short _CERRORJ
		cmp	bh, 3Dh		; OPEN
		jz	short OpenError
		mov	dx, offset FULLDIR_PTR

_CERRORJ:				; ...
		jmp	cerror
; ---------------------------------------------------------------------------

OpenError:				; ...
		mov	[cs:msg_disp_class], 1
		mov	dx, offset extend_buf_ptr
		mov	[cs:extend_buf_ptr], ax
		jmp	cerror
endp		TESTDOREIN


; =============== S U B	R O U T	I N E =======================================


proc		TESTDOREOUT near	; ...
		cmp	[ds:Re_OutStr],	0 ; byte
		jnz	short REOUTEXISTS
		jmp	NOREOUT
; ---------------------------------------------------------------------------

REOUTEXISTS:				; ...
		cmp	[ds:Re_Out_App], 0 ; byte
		jz	short REOUTCRT
		mov	dx, offset Re_OutStr
		mov	ax, 3D02h	; (OPEN	SHL 8) OR 2
		push	ax
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 2 - read & write
		pop	bx
		jb	short OpenWriteError
		mov	bx, ax
		mov	ax, 4400h	; IOCTL<<8
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		test	dl, 80h
		jnz	short SET_REOUT
		mov	ax, 4202h	; (LSEEK SHL 8)	OR 2
		mov	cx, 0FFFFh
		mov	dx, cx
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from end of file
		push	cs
		pop	ds
		mov	ax, 3F00h	; (READ	SHL 8)
		mov	cx, 1
		mov	dx, offset One_Char_Val
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		jb	short OpenWriteError
		cmp	ax, cx
		jnz	short reout_0_length
		cmp	[One_Char_Val],	1Ah ; Was char an eof mark?
		mov	ds, [RESSEG]
		assume ds:RESGROUP
		jnz	short SET_REOUT	; No, just continue
		mov	ax, 4201h	; (LSEEK<<8)|1
		mov	cx, 0FFFFh	; -1 ; LSEEK back one byte
		mov	dx, cx
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from present location
		jmp	short SET_REOUT
; ---------------------------------------------------------------------------

reout_0_length:				; ...
		mov	ds, [cs:RESSEG]
		mov	ax, 4200h	; (LSEEK SHL 8)
		xor	cx, cx		; Offset is 0 ;	Move to	beginning of file
		mov	dx, cx
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		jmp	short SET_REOUT
; ---------------------------------------------------------------------------

OpenWriteError:				; ...
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		stc
		jnz	short REOUTCRT
		jmp	REDIRERR
; ---------------------------------------------------------------------------

REOUTCRT:				; ...
		mov	dx, offset Re_OutStr
		xor	cx, cx
		mov	ah, 3Ch		; CREAT
		push	ax
		int	21h		; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
					; CX = attributes for file
					; DS:DX	-> ASCIZ filename (may include drive and path)
		pop	bx
		jnb	short NOREDIRERR
		jmp	REDIRERR
; ---------------------------------------------------------------------------

NOREDIRERR:				; ...
		mov	bx, ax

SET_REOUT:				; ...
		mov	al, 0FFh
		xchg	al, [bx+18h]	; [bx+PDB.JFN_TABLE]
		mov	[ds:19h], al	; [PDB.JFN_TABLE+1]

NOREOUT:				; ...
		retn
endp		TESTDOREOUT


; =============== S U B	R O U T	I N E =======================================


proc		dstrlen	near		; ...
		push	ax
		xor	cx, cx
		cld

dloop:					; ...
		lodsb
		inc	cx
		or	al, al
		jnz	short dloop
		sub	si, cx
		pop	ax

TRIAGEERR_RETN:				; ...
		retn
endp		dstrlen


; =============== S U B	R O U T	I N E =======================================


proc		TriageError near	; ...
		jnb	short TRIAGEERR_RETN ; GET_EXT_ERR_NUMBER
		pushf
		push	bx
		push	cx
		push	si
		push	di
		push	bp
		push	es
		push	ds
		push	ax
		push	dx
		mov	ah, 59h
		int	21h		; DOS -	3+ - GET EXTENDED ERROR	CODE
					; BX = version code (0000h for DOS 3.x)
		pop	cx
		pop	bx
		mov	dx, offset ACCDEN_PTR
		cmp	ax, 65		; network access denied?
		jz	short NoMove	; Yes, return it.
		mov	ax, bx
		mov	dx, cx

NoMove:					; ...
		pop	ds
		assume ds:nothing
		pop	es
		assume es:nothing
		pop	bp
		pop	di
		pop	si
		pop	cx
		pop	bx
		popf
		retn
endp		TriageError

; ---------------------------------------------------------------------------

Triage_Init:				; ...
		call	TriageError
		retf

; =============== S U B	R O U T	I N E =======================================


proc		Move_To_SrcBuf near	; ...
		push	si
		push	di
		push	cx
		mov	di, offset SrcBuf
		xor	cx, cx
		mov	ax, cx
		push	di
		lodsb

mts_get_chars:				; ...
		cmp	al, 0
		jz	short mts_end_string
		stosb
		inc	cx
		lodsb
		jmp	short mts_get_chars
; ---------------------------------------------------------------------------

mts_end_string:				; ...
		mov	al, 0Dh		; END_OF_LINE_IN
		stosb
		pop	di
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	[PathCnt], cx
		mov	[PathPos], di
		pop	cx
		pop	di
		pop	si
		retn
endp		Move_To_SrcBuf


; =============== S U B	R O U T	I N E =======================================


proc		SINGLETEST near		; ...
		push	ds
		mov	ds, [cs:RESSEG]
		assume ds:RESGROUP
		cmp	[SingleCom], 0	; word
		jz	short TESTDONE
		cmp	[SingleCom], 0EFFFh

TESTDONE:				; ...
		pop	ds
		assume ds:nothing
		retn
endp		SINGLETEST


; =============== S U B	R O U T	I N E =======================================


proc		SetRest1 near		; ...
		mov	al, 1
endp		SetRest1


; =============== S U B	R O U T	I N E =======================================


proc		SETREST	near		; ...
		push	ds
		mov	ds, [ds:RESSEG]
		mov	[ds:RestDir], al
		pop	ds
		retn
endp		SETREST


; =============== S U B	R O U T	I N E =======================================


proc		PIPEDEL	near		; ...
		push	ds
		push	dx
		mov	ds, [cs:RESSEG]
		assume ds:RESGROUP
		mov	dx, 41Eh	; Pipe1	= offset RESGROUP:EndInit
		mov	ah, 41h		; Unlink
		call	int_21h_indirect
		mov	dx, 46Dh	; Pipe2	= offset RESGROUP:EndInit+79
		mov	ah, 41h		; Unlink
		call	int_21h_indirect
		pop	dx
		call	PipeOff
		mov	[PipeFiles], 0	; byte
		pop	ds
		assume ds:nothing
		retn
endp		PIPEDEL

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR PROMPTBAT

PIPEERRSYN:				; ...
		mov	dx, offset SYNTMES_PTR ; MSG_1030
		call	PIPEDEL
		push	cs
		pop	ds
		assume ds:TRANGROUP
		jmp	cerror
; ---------------------------------------------------------------------------

PIPERR:					; ...
		pushf
		call	TriageError
		push	ax
		push	dx
		mov	dx, offset PIPEEMES_PTR
		call	PIPEDEL
		push	cs
		pop	ds
		call	std_eprintf
		pop	dx
		pop	ax
		popf
		cmp	ax, 65		; network access denied
		jnz	short TCOMMANDJ
		jmp	cerror
; ---------------------------------------------------------------------------

TCOMMANDJ:				; ...
		jmp	TCOMMAND
; ---------------------------------------------------------------------------

PIPEPROCSTRT:				; ...
		mov	ds, [RESSEG]
		assume ds:RESGROUP
		inc	[PipeFiles]	; byte
		push	es
		push	di
		push	ds
		push	si
		push	ds
		push	es
		pop	ds
		assume ds:nothing
		mov	si, offset TempVarName ; "TEMP="
		call	find_name_in_environment
		pop	ds
		jb	short no_temp_path
		push	ds
		push	es
		pop	ds
		pop	es
		mov	si, di
		call	skip_white	; skip white space chars
		call	copy_pipe_path
		push	es
		pop	ds
		mov	dx, offset EndInit ; 41Eh
		mov	ax, 4300h	; (CHMOD shl 8)	or 0
		call	int_21h_indirect
		jb	short no_temp_path
		test	cx, 10h		; is it	a directory?
		jnz	short no_temp_path ; yes, continue
		stc			; no, indicate fail

no_temp_path:				; ...
		pop	si
		pop	ds
		pop	di
		pop	es
		jnb	short crt_temp
		mov	ah, 2Eh	; '.'
		mov	[ds:41Eh], ah	; mov [Pipe1],ah
		mov	[ds:46Dh], ah	; mov [Pipe2],ah
		xor	ah, ah
		mov	[ds:41Fh], ah	; mov [Pipe1+1],ah
		mov	[ds:46Eh], ah	; mov [Pipe2+1],ah

crt_temp:				; ...
		mov	dx, 41Eh	; mov dx,Pipe1
		xor	cx, cx
		mov	ah, 5Ah		; CREATETEMPFILE
		call	int_21h_indirect
		jnb	short pps0
		jmp	short PIPERR
; ---------------------------------------------------------------------------

pps0:					; ...
		mov	bx, ax
		mov	ah, 3Eh		; CLOSE
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		mov	dx, 46Dh	; mov dx,Pipe2
		mov	ah, 5Ah		; CREATETEMPFILE
		call	int_21h_indirect
		jnb	short pps1
		jmp	PIPERR
; ---------------------------------------------------------------------------

pps1:					; ...
		mov	bx, ax
		mov	ah, 3Eh		; CLOSE
		call	int_21h_indirect
		call	TESTDOREIN
		mov	si, [ds:4BCh]	; [PipePtr] ; offset RESGROUP:EndInit+158
		cmp	[ds:SingleCom],	0FFFFh ; -1
		jnz	short NOSINGP
		mov	[ds:SingleCom],	0F000h ; Flag single command pipe

NOSINGP:				; ...
		jmp	short FIRSTPIPE
; ---------------------------------------------------------------------------

PIPEPROC:				; ...
		and	[ds:EchoFlag], 0FEh
		mov	si, [ds:4BCh]	; [PipePtr] ; offset RESGROUP:EndInit+158
		lodsb
		cmp	al, 7Ch	; '|'   ; ALTPIPECHR
		jz	short ISPIPE1
		cmp	al, 7Ch	; '|'   ; VBAR
		jz	short ISPIPE1
		jmp	PIPEEND
; ---------------------------------------------------------------------------

ISPIPE1:				; ...
		mov	dx, [ds:InPipePtr]
		mov	ax, 3D00h	; OPEN*256
		call	int_21h_indirect

PIPEERRJ:				; ...
		jnb	short NO_PIPEERR
		jmp	PIPERR
; ---------------------------------------------------------------------------

NO_PIPEERR:				; ...
		mov	bx, ax
		mov	al, 0FFh
		xchg	al, [bx+18h]	; [bx+PDB.JFN_TABLE]
		mov	[ds:18h], al	; [PDB.JFN_TABLE]

FIRSTPIPE:				; ...
		mov	di, (offset COMBUF+2)
		xor	cx, cx
		cmp	[byte ptr si], 0Dh ; ; '|<CR>'
		jnz	short PIPEOK1

PIPEERRSYNJ:				; ...
		jmp	PIPEERRSYN
; ---------------------------------------------------------------------------

PIPEOK1:				; ...
		mov	al, 7Ch	; '|'   ; VBAR
		cmp	[si], al	; '||' ?
		jz	short PIPEERRSYNJ ; error
		cmp	[byte ptr si], 7Ch ; '|' ; ALTPIPECHR
		jz	short PIPEERRSYNJ

PIPECOMLP:				; ...
		lodsb
		stosb
		call	testkanj
		jz	short NOTKANJ5
		movsb
		inc	cx
		inc	cx
		jmp	short PIPECOMLP
; ---------------------------------------------------------------------------

NOTKANJ5:				; ...
		cmp	al, 0Dh
		jz	short LASTPIPE
		inc	cx
		cmp	al, 7Ch	; '|'   ; ALTPIPECHR
		jz	short ISPIPE2
		cmp	al, 7Ch	; '|'   ; VBAR
		jnz	short PIPECOMLP

ISPIPE2:				; ...
		mov	[byte ptr es:di-1], 0Dh
		dec	cx
		mov	[es:COMBUF+1], cl
		dec	si
		mov	[ds:4BCh], si	; ; [PipePtr] =	[EndInit+158]
		mov	dx, [ds:OutPipePtr]
		push	cx
		xor	cx, cx
		mov	ax, 3C00h	; CREAT*256
		call	int_21h_indirect
		pop	cx
		jb	short PIPEERRJ
		mov	bx, ax
		mov	al, 0FFh
		xchg	al, [bx+18h]	; [bx+PDB.JFN_TABLE]
		mov	[ds:19h], al	; [PDB.JFN_TABLE+1]
		xchg	dx, [ds:InPipePtr]
		mov	[ds:OutPipePtr], dx
		jmp	short PIPECOM
; ---------------------------------------------------------------------------

LASTPIPE:				; ...
		mov	[es:COMBUF+1], cl
		dec	si
		mov	[ds:4BCh], si	; mov [PipePtr],si
		call	TESTDOREOUT

PIPECOM:				; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		jmp	NOPIPEPROC
; ---------------------------------------------------------------------------

PIPEEND:				; ...
		call	PIPEDEL
		cmp	[ds:SingleCom],	0F000h
		jnz	short NOSINGP2
		mov	[ds:SingleCom],	0FFFFh ; -1

NOSINGP2:				; ...
		jmp	TCOMMAND
; END OF FUNCTION CHUNK	FOR PROMPTBAT

; =============== S U B	R O U T	I N E =======================================


proc		DATINIT	far		; ...
		mov	[cs:RESSEG], ds
		push	es
		push	ds
		mov	ax, cs
		mov	es, ax
		assume es:TRANGROUP
		mov	ds, ax
		call	TSYSLOADMSG	; preload messages
		mov	dx, offset STACK ; INTERNATVARS
		mov	ax, 3800h	; INTERNATIONAL*256
		call	int_21h_indirect
		mov	word ptr ds:81h, 0Dh
		mov	[COMBUF], 128
		mov	[word ptr COMBUF+1], 0D01h
		call	DATE
		call	CTIME
		pop	ds
		assume ds:nothing
		pop	es
		assume es:nothing
		retf
endp		DATINIT


; =============== S U B	R O U T	I N E =======================================


proc		DATE near		; ...
		mov	si, 81h
		mov	di, offset PARSE_DATE
		xor	cx, cx
		xor	dx, dx
		call	cmd_parse
		cmp	ax, 0FFFFh
		jz	short PRMTDAT
		cmp	ax, 0
		jnz	short DATERR
		jmp	short COMDAT
; ---------------------------------------------------------------------------

PRMTDAT:				; ...
		call	GetDate
		xchg	dh, dl
		mov	[ds:CurDat_yr],	cx
		mov	[ds:CurDat_mo_day], dx
		mov	dx, offset CurDat_Ptr
		call	std_printf

GET_NEW_DATE:				; ...
		call	GETDAT
		cmp	ax, 0FFFFh	; -1
		jz	short date_end
		cmp	ax, 0
		jnz	short DATERR

COMDAT:					; ...
		mov	cx, [ds:DATE_YEAR]
		mov	dh, [ds:DATE_MONTH]
		mov	dl, [ds:DATE_DAY]
		push	cx
		push	dx
		mov	cx, 1		; set 1	positional entered
		xor	dx, dx
		call	cmd_parse
		cmp	al, 0FFh
		pop	dx
		pop	cx
		jnz	short DATERR
		mov	ah, 2Bh		; SET_DATE
		call	int_21h_indirect
		or	al, al
		jnz	short DATERR

date_end:				; ...
		retn
; ---------------------------------------------------------------------------

DATERR:					; ...
		call	CRLF2
		mov	dx, offset BADDAT_PTR
		call	std_printf
		jmp	short GET_NEW_DATE
endp		DATE


; =============== S U B	R O U T	I N E =======================================


proc		CTIME near		; ...
		mov	si, 81h
		mov	di, offset PARSE_TIME
		xor	cx, cx
		xor	dx, dx
		call	cmd_parse
		cmp	ax, 0FFFFh
		jz	short PRMTTIM
		cmp	ax, 0
		jnz	short TIMERR
		jmp	short COMTIM
; ---------------------------------------------------------------------------

PRMTTIM:				; ...
		mov	ah, 2Ch		; Get_Time
		call	int_21h_indirect
		xchg	ch, cl
		xchg	dh, dl
		mov	[ds:CurTim_hr_min], cx
		mov	[ds:CurTim_Sec_hn], dx
		mov	dx, offset CurTim_Ptr
		call	std_printf

GET_NEW_TIME:				; ...
		call	GETTIM
		cmp	ax, 0FFFFh
		jz	short time_end
		cmp	ax, 0
		jnz	short TIMERR

COMTIM:					; ...
		mov	ch, [ds:TIME_HOUR]
		mov	cl, [ds:TIME_MINUTES]
		mov	dh, [ds:TIME_SECONDS]
		mov	dl, [ds:TIME_FRACTION]
		push	cx
		push	dx
		mov	cx, 1
		xor	dx, dx
		call	cmd_parse
		cmp	al, 0FFh
		pop	dx
		pop	cx
		jnz	short TIMERR
		mov	ah, 2Dh		; SET_TIME
		call	int_21h_indirect
		or	al, al
		jnz	short TIMERR

time_end:				; ...
		retn
; ---------------------------------------------------------------------------

TIMERR:					; ...
		call	CRLF2
		mov	dx, offset BadTim_Ptr
		call	std_printf
		jmp	short GET_NEW_TIME
endp		CTIME


; =============== S U B	R O U T	I N E =======================================


proc		SetInitFlag near	; ...
		mov	ds, [ds:RESSEG]
		and	[ds:InitFlag], 0FDh
		or	[ds:InitFlag], cl
		push	cs
		pop	ds
		assume ds:TRANGROUP
		retn
endp		SetInitFlag


; =============== S U B	R O U T	I N E =======================================


proc		PipeOff	near		; ...
		push	ds
		push	ax
		mov	ds, [cs:RESSEG]
		assume ds:nothing
		xor	al, al
		xchg	al, [ds:PipeFlag]
		or	al, al
		jz	short PipeOffDone
		shr	[ds:EchoFlag], 1

PipeOffDone:				; ...
		pop	ax
		pop	ds
		retn
endp		PipeOff

; ---------------------------------------------------------------------------

PRINT_TIME:				; ...
		mov	ah, 2Ch
		call	int_21h_indirect
		push	es
		push	cs
		pop	es
		assume es:TRANGROUP
		xchg	ch, cl
		xchg	dh, dl
		mov	[cs:PromTim_hr_min], cx
		mov	[cs:PromTim_Sec_hn], dx
		mov	dx, offset promtim_ptr
		call	std_printf
		pop	es
		assume es:nothing
		retn

; =============== S U B	R O U T	I N E =======================================


proc		GETDAT near		; ...
		mov	ax, 3800h	; (International SHL 8)
		mov	dx, 5Ch	; '\'
		call	int_21h_indirect
		mov	si, dx
		lodsw
		mov	dx, [cs:usadat_ptr]
		dec	ax
		js	short printformat
		mov	dx, [cs:eurdat_ptr]
		jz	short printformat
		mov	dx, [cs:japdat_ptr]

printformat:				; ...
		mov	ax, dx
		mov	dh, 0FFh	; util_msg_class
		call	TSYSGETMSG
		mov	[cs:NewDat_Format], si
		mov	dx, offset NewDat_Ptr
		call	std_printf
		mov	[cs:NewDat_Format], 0
		mov	ah, 0Ah		; Std_Con_String_Input
		mov	dx, offset COMBUF
		mov	cx, 2		; INITSPECIAL
		call	SetInitFlag
		call	int_21h_indirect
		xor	cx, cx
		call	SetInitFlag
		call	CRLF2
		mov	si, (offset COMBUF+2)
		mov	di, offset PARSE_DATE
		xor	cx, cx
		xor	dx, dx
		call	cmd_parse
		retn
endp		GETDAT


; =============== S U B	R O U T	I N E =======================================


proc		GETTIM near		; ...
		xor	cx, cx
		mov	dx, offset NewTim_Ptr
		call	std_printf
		mov	ah, 0Ah		; Std_Con_String_Input
		mov	dx, offset COMBUF
		mov	cx, 2
		call	SetInitFlag
		call	int_21h_indirect
		xor	cx, cx
		call	SetInitFlag
		call	CRLF2
		mov	si, (offset COMBUF+2)
		mov	di, offset PARSE_TIME
		xor	cx, cx
		xor	dx, dx
		call	cmd_parse
		retn
endp		GETTIM


; =============== S U B	R O U T	I N E =======================================


proc		skip_white near		; ...
		cld

skw_lp:					; ...
		lodsb
		cmp	al, 20h	; ' '
		jz	short skw_lp
		cmp	al, 9
		jz	short skw_lp
		dec	si
		retn
endp		skip_white


; =============== S U B	R O U T	I N E =======================================


proc		copy_pipe_path near	; ...
		mov	cx, 0FFFFh
		xor	al, al
		mov	di, si
		push	es
		push	ds
		pop	es
		cld
		push	di
		repne scasb
		pop	di
		pop	es
		not	cx
		mov	di, 41Eh	; Pipe1	; (offset RESGROUP:EndInit)
		push	di
		push	cx
		rep movsb
		pop	cx
		pop	di
		push	ds
		push	es
		pop	ds
		mov	si, di
		mov	di, 46Dh	; Pipe2	; (offset RESGROUP:EndInit+79)
		rep movsb
		pop	ds
		retn
endp		copy_pipe_path


; =============== S U B	R O U T	I N E =======================================


proc		PARSELINE near		; ...
		push	ax
		push	bx
		push	cx
		push	dx
		push	di
		push	si
		pushf
		mov	[ds:cpyflag], 0
		mov	[ds:LASTARG], 0FFFFh
		xor	ax, ax
		mov	cx, 1092	; ARG_UNIT.SIZE
		mov	di, offset ARG_ARGV ; offset ARG
		rep stosb
		mov	[ds:ARGBUF_PTR], offset	ARG_ARGBUF ; ARG+ARG_UNIT.argbuf
		mov	[ds:ARG_ARGSWINFO], 0 ;	[ARG+ARG_UNIT.argswinfo]
		mov	[ds:ARG_ARGVCNT], 0 ; [ARG+ARG_UNIT.argvcnt]
		mov	si, (offset COMBUF+2)
		push	ds
		mov	ds, [ds:RESSEG]
		cmp	[ds:ForFlag], 0
		pop	ds
		jnz	short PCONT
		mov	di, offset ARG_ARGFORCOMBUF ; ARG+ARG_UNIT.argforcombuf
		xor	ch, ch
		mov	cl, [ds:COMBUF+1]
		inc	cl
		rep movsb
		mov	si, offset ARG_ARGFORCOMBUF ; ARG+ARG_UNIT.argforcombuf

PCONT:					; ...
		mov	di, offset TPBUF ; destination is temporary token buffer
		mov	bl, 20h	; ' '

PARSELOOP:				; ...
		mov	[ds:COMPTR], si	; save ptr into	original command buffer
		xor	bp, bp
		mov	[ds:expand_star], 0 ; byte ; don't expand *'s to ?'s
		call	scanoff		; skip leading blanks
		call	cparse		; byte off a token (args in SI,	DI, BL)
		jnb	short MORE_PRSE
		or	bp, bp
		jz	short PARSEDONE
		call	newarg
		jmp	short PARSEDONE
; ---------------------------------------------------------------------------

MORE_PRSE:				; ...
		mov	[ds:cpyflag], 2	; tell CPARSE that 1st token is	done
		call	newarg		; add to argv array (CX	has char count)
		jnb	short PARSELOOP
		jmp	short PARSE_ERROR
; ---------------------------------------------------------------------------

PARSEDONE:				; ...
		popf
		clc
		jmp	short PARSE_EXIT
; ---------------------------------------------------------------------------

PARSE_ERROR:				; ...
		popf
		stc

PARSE_EXIT:				; ...
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn
endp		PARSELINE


; =============== S U B	R O U T	I N E =======================================


proc		newarg near		; ...
		push	bx
		push	cx
		push	dx
		push	di
		push	si
		pushf
		call	arg_switch
		cmp	[ds:ARG_ARGVCNT], 64 ; [ARG+ARG_UNIT.argvcnt],ARGMAX
		jge	short to_many_args
		mov	dh, bh
		mov	bx, [ds:ARG_ARGVCNT]
		inc	[ds:ARG_ARGVCNT] ; inc word [ARG+ARG_UNIT.argvcnt]
		mov	ax, offset ARG_ARGV ; ARG+ARG_UNIT.argv
		call	argv_calc
		mov	[word ptr bx+7], 0 ; [bx+ARGV_ELE.argsw_word]
		mov	[bx+5],	cx	; [bx+ARGV_ELE.arglen]
		mov	[bx+2],	dh	; [bx+ARGV_ELE.argflags]
		mov	si, [ds:ARGBUF_PTR]
		mov	[bx], si	; [bx+ARGV_ELE.argpointer]
		add	si, [ds:STARTEL]
		sub	si, di
		mov	[bx+3],	si	; [bx+ARGV_ELE.argstartel]
		mov	si, [ds:COMPTR]
		mov	[bx+9],	si	; [bx+ARGV_ELE.arg_ocomptr]
		mov	si, di
		mov	di, [ds:ARGBUF_PTR]
		add	di, cx
		cmp	di, (offset ARG_ARGBUF+7Fh) ; ARG+ARG_UNIT.argbuf+ARGBLEN-1
		jge	short buf_oflow
		sub	di, cx

newarg_@:				; ...
		cld
		rep movsb
		mov	al, 0
		stosb
		mov	[ds:ARGBUF_PTR], di
		popf
		clc
		jmp	short newarg_exit
; ---------------------------------------------------------------------------

buf_oflow:				; ...
		sub	di, cx
		mov	cx, (offset ARG_ARGBUF+7Fh) ; ARG+ARG_UNIT.argbuf+ARGBLEN-1
		sub	cx, di
		jmp	short newarg_@
; ---------------------------------------------------------------------------

to_many_args:				; ...
		mov	ax, 1
		popf
		stc

newarg_exit:				; ...
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		retn
endp		newarg


; =============== S U B	R O U T	I N E =======================================


proc		arg_switch near		; ...
		push	ax
		push	bx
		push	cx
		push	di
		pushf
		test	bh, 1		; sw_flag
		jz	short no_switch0
		cmp	[ds:LASTARG], 0FFFFh ; -1
		jz	short arg_no_switch1
		mov	bx, [ds:LASTARG]
		mov	ax, offset ARG_ARGV ; ARG+ARG_UNIT.argv	; ARG+0
		call	argv_calc
		or	[bx+7],	bp	; or [bx+ARGV_ELE.argsw_word],bp
		or	[ds:ARG_ARGSWINFO], bp ; or [ARG+ARG_UNIT.argswinfo],bp
		popf
		stc
		jmp	short arg_switch_exit
; ---------------------------------------------------------------------------

no_switch0:				; ...
		mov	ax, [ds:ARG_ARGVCNT] ; [ARG+ARG_UNIT.argvcnt]
		mov	[ds:LASTARG], ax

arg_no_switch1:				; ...
		popf
		clc

arg_switch_exit:			; ...
		pop	di
		pop	cx
		pop	bx
		pop	ax
		retn
endp		arg_switch


; =============== S U B	R O U T	I N E =======================================


proc		argv_calc near		; ...
		push	ax
		mov	al, bl
		mov	bl, 11		; ARGV_ELE.SIZE
		mul	bl
		pop	bx
		add	ax, bx
		xchg	ax, bx
		retn
endp		argv_calc


; =============== S U B	R O U T	I N E =======================================


proc		path_search near	; ...
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		push	bp
		pushf
		test	[ds:ARGV0_ARG_FLAGS], 3	; [ARG+ARGV_ELE.argflags],3 ; wildcard+sw_flag
		jz	short path_search_ok

path_failure_jmp:			; ...
		jmp	path_failure
; ---------------------------------------------------------------------------

path_search_ok:				; ...
		call	STORE_PCHAR	; figure out the pathname separator
		mov	dx, offset FBUF
		mov	ax, 1A00h
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		push	es
		call	find_path	; get a	handle (ES:DI) on user path
		mov	[ds:pathinfo], es
		mov	[ds:pathinfo+2], di ; "old" pathstring pointer
		mov	[ds:pathinfo+4], di ; "new" pathstring pointer
		pop	es
		mov	bx, 256		; PBUFLEN
					; copy/format argv[0] into temp	buffer
		mov	si, offset EXECPATH
		call	STRIP
		jb	short path_failure_jmp
		mov	dx, si
		mov	[ds:search_error], offset baddrv_ptr
		call	PSEARCH
		or	ax, ax
		jz	short path_noinit
		mov	bp, ax
		mov	di, offset EXECPATH
		mov	si, [ds:ARG_ARGV] ; [ARG+ARGV_ELE.argpointer]
					; mov si,ds:arg.argv[0].argpointer
		mov	cx, [ds:ARGV0_ARGSTARTEL] ; [ARG+ARGV_ELE.argstartel]
					; mov cx,ds:arg.argv[0].argstartel
		sub	cx, si		; compute prefix bytes to copy
		mov	ah, ':'
		cmp	cx, 2		; room for drive letter?
		jb	short adddrive	; no, stick it in
		cmp	[si+1],	ah	; colon	present?
		jz	short movedrive	; yes, just move it

adddrive:				; ...
		mov	al, [ds:CURDRV]	; get current drive
		add	al, 41h	; 'A'   ; convert to uppercase letter
		stosw			; store	d:
		jmp	short checkpath
; ---------------------------------------------------------------------------

movedrive:				; ...
		lodsw
		stosw
		sub	cx, 2		; 2 bytes less to move

checkpath:				; ...
		or	al, 20h
		mov	dl, al
		sub	dl, 60h		; 'a'-1
		mov	al, [ds:psep_char]
		stosb
		cmp	cx, 1		; is there room	for path char?
		jb	short addpath	; no, go add path
		lodsb
		dec	cx
		cmp	al, [ds:psep_char] ; is	there a	path separator?
		jz	short movepath	; yes, go move remainder of path
		inc	cx
		dec	si		; undo the lodsb

addpath:				; ...
		push	si
		mov	si, di		; remainder of buffer
		mov	ax, 4700h
		int	21h		; DOS -	2+ - GET CURRENT DIRECTORY
					; DL = drive (0=default, 1=A, etc.)
					; DS:SI	points to 64-byte buffer area
		mov	di, si
		pop	si
		mov	al, [ds:psep_char]
		cmp	[byte ptr di], 0 ; root	(empty dir string)?
		jz	short movepath	; yes, no need for path	char

scanend:				; ...
		cmp	[byte ptr di], 0
		jz	short foundend
		inc	di
		jmp	short scanend
; ---------------------------------------------------------------------------

foundend:				; ...
		stosb

movepath:				; ...
		cmp	[si], al	; first	char a path char?
		jnz	short copypath	; no
		inc	si		; move past leading char
		dec	cx		; drop from count

copypath:				; ...
		jcxz	short _copydone	; no chars to move!
		rep movsb

_copydone:				; ...
		jmp	path_success
; ---------------------------------------------------------------------------

path_noinit:				; ...
		test	[ds:ARGV0_ARG_FLAGS], 4	; [ARG+ARGV_ELE.argflags],4 ; path_sep
					; test ds:arg.argv[0].argflags,	MASK path_sep
		jnz	short path_failure
		mov	bh, ';'         ; PATH_SEP_CHAR
		mov	dx, [ds:ARGV0_ARGSTARTEL] ; [ARG+ARGV_ELE.argstartel]
					; mov dx,ds:arg.argv[0].argstartel
		sub	dx, [ds:ARG_ARGV]
		add	dx, offset EXECPATH

path_loop:				; ...
		call	path_crunch	; pcrunch (EXECPATH, pathinfo)
		mov	bp, ax		; save filetype	code
		lahf
		or	bp, bp		; did path_crunch find anything?
		jnz	short path_found
		sahf
		jnb	short path_loop	; is there anything left to the	path?

path_failure:				; ...
		xor	ax, ax
		jmp	path_exit
; ---------------------------------------------------------------------------

path_found:				; ...
		mov	di, offset EXECPATH
		mov	cx, [ds:pathinfo+4] ; "new" pointer -- end of string
		mov	si, [ds:pathinfo+2] ; "old" pointer -- beginning of string
		push	es
		push	[ds:pathinfo]	; push word [pathinfo+0]
		pop	es
		cmp	[byte ptr es:si+2], '.' ; Look for Current dir at start of path
		jnz	short path_cpy
		cmp	[byte ptr es:si+1], ':' ; does path have drive letter?
		jnz	short path_cpy	; no, copy the path string
		push	cx		; Save pointer to end of string
		mov	al, [es:si]	; Copy drive letter, :,	and root char to EXECPATH
		mov	[di], al
		mov	al, [es:si+1]
		mov	[di+1],	al
		mov	al, [ds:psep_char]
		mov	[di+2],	al
		push	si
		mov	dl, [es:si]	; Convert device letter	for cur	dir
		or	dl, 20h
		sub	dl, 60h		; 'a'-1
		mov	si, di
		add	si, 3		; Don't wipe out drive and root info
		mov	ax, 4700h
		int	21h		; DOS -	2+ - GET CURRENT DIRECTORY
					; DL = drive (0=default, 1=A, etc.)
					; DS:SI	points to 64-byte buffer area
		call	dstrlen
		add	si, cx		; Don't copy over drive and root info
		dec	si
		mov	di, si
		pop	si		; Restore pointer to begining of string
		add	si, 3		; Point	past drive letter, :, .
		pop	cx		; Restore pointer to end of string

path_cpy:				; ...
		pop	es
		sub	cx, si
		push	ds
		push	[ds:pathinfo]	; push word [pathinfo+0]
		pop	ds
		cld

kloop:					; ...
		lodsb
		stosb
		call	testkanj
		jz	short _notkanj1
		dec	cx
		jcxz	short popdone
		movsb
		dec	cx
		cmp	cx, 1
		ja	short kloop

popdone:				; ...
		pop	ds
		mov	al, [ds:psep_char]
		jmp	short path_store
; ---------------------------------------------------------------------------

_notkanj1:				; ...
		loop	kloop
		pop	ds
		dec	di		; overwrite terminator
		mov	al, [ds:psep_char] ; with a pathname separator
		cmp	al, [di-1]
		jz	short path_success

path_store:				; ...
		stosb

path_success:				; ...
		mov	si, offset search_best_buf
		xor	cx, cx

path_succ_loop:				; ...
		lodsb			; append winning filename to path
		stosb			; (including terminating null)
		or	al, al
		jnz	short path_succ_loop
		mov	ax, bp

path_exit:				; ...
		popf
		pop	bp
		pop	di
		pop	si
		pop	dx
		pop	cx
		pop	bx
		retn
endp		path_search


; =============== S U B	R O U T	I N E =======================================


proc		STORE_PCHAR near	; ...
		push	ax
		mov	al, 2Fh	; '/'
		call	pathchrcmp
		jz	short STORE_SLASH
		mov	al, 5Ch	; '\'
		mov	[ds:psep_char],	al
		pop	ax
		retn
; ---------------------------------------------------------------------------

STORE_SLASH:				; ...
		mov	[ds:psep_char],	al
		pop	ax
		retn
endp		STORE_PCHAR


; =============== S U B	R O U T	I N E =======================================


proc		path_crunch near	; ...
		push	bx		; BH = additional terminator character
		push	cx
		push	dx		; pointer to stripped filename
		push	di
		push	si		; pointer into pathstring to be	dissected
		pushf
		call	STORE_PCHAR	; figure out pathname separator
		mov	di, offset TPBUF ; destination of concatenated string
		mov	si, [ds:pathinfo+4] ; "new" pointer to start with
		mov	[ds:pathinfo+2], si ; becomes "old" pointer
		push	ds		; save old segment pointer
		push	[ds:pathinfo]	; push word [pathinfo+0]
		pop	ds		; replace with pointer to userpath's segment
		xor	cl, cl		; clear	flag for later use

path_cr_copy:				; ...
		lodsb			; get a	pathname byte
		or	al, al
		jz	short path_seg	; null terminates segment & pathstring
		cmp	al, bh
		jz	short path_seg	; BH terminates	a pathstring segment
		call	testkanj
		jz	short _notkanj2
		stosb
		movsb
		mov	cl, 1		; CL=1 means latest stored char	is DBCS
		jmp	short path_cr_copy
; ---------------------------------------------------------------------------

_notkanj2:				; ...
		xor	cl, cl		; CL=0 means latest stored char	is SBCS
		stosb
		jmp	short path_cr_copy
; ---------------------------------------------------------------------------

path_seg:				; ...
		pop	ds
		mov	[ds:pathinfo+4], si ; save "new" pointer for next time
		mov	bl, al
		xor	ax, ax
		cmp	di, offset TPBUF ; was there really anything in	pathstr?
		jz	short path_cr_leave
		mov	al, [ds:psep_char]
		or	cl, cl
		jnz	short path_cr_store ; this is a	trailing byte of ECS code
		cmp	al, [di-1]	; add pathname separator for suffix
		jz	short path_cr_l1

path_cr_store:				; ...
		stosb

path_cr_l1:				; ...
		mov	si, dx

path_cr_l2:				; ...
		lodsb			; tack the stripped filename onto
					; the end of the path, up to and
		stosb
		or	al, al		; including the	terminating null
		jnz	short path_cr_l2
		mov	dx, offset TPBUF ; and look for	an appropriate file
		mov	[ds:search_error], offset BADPMES_PTR
		call	PSEARCH		; results are in AX & search_best_buf

path_cr_leave:				; ...
		or	bl, bl
		jz	short path_cr_empty ; null in BL means all gone
		popf
		clc
		jmp	short path_cr_exit
; ---------------------------------------------------------------------------

path_cr_empty:				; ...
		popf
		stc

path_cr_exit:				; ...
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		retn			; AX = non-zero	(file type), zero (nothing found)
endp		path_crunch


; =============== S U B	R O U T	I N E =======================================


proc		PSEARCH	near		; ...
		push	cx
		push	dx
		push	di
		push	si
		pushf
		push	dx
		mov	di, dx
		mov	si, offset search_curdir_buf
		xor	dx, dx
		cmp	[byte ptr di+1], ':' ; is there a drive spec?
		jnz	short SEARCH_DIR_CHECK ; no
		mov	dl, [di]
		and	dl, 0DFh	; uppercase the	drive letter
		sub	dl, 40h	; '@'   ; and convert to drive number

SEARCH_DIR_CHECK:			; ...
		mov	ax, 4700h
		int	21h		; DOS -	2+ - GET CURRENT DIRECTORY
					; DL = drive (0=default, 1=A, etc.)
					; DS:SI	points to 64-byte buffer area
		pop	dx
		jb	short SEARCH_INVALID_DRIVE
		mov	cx, 13h
		mov	ax, 4E00h
		int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
					; CX = search attributes
					; DS:DX	-> ASCIZ filespec
					; (drive, path,	and wildcards allowed)
		jb	short SEARCH_NO_FILE
		mov	[ds:search_best], 0 ; SEARCH_FILE_NOT_FOUND ; 0
		mov	[ds:search_best_buf], 0

SEARCH_LOOP:				; ...
		call	SEARCH_FTYPE	; determine if .com, &c...
		cmp	al, [ds:search_best] ; better than what	we've found so far?
		jle	short SEARCH_NEXT
		mov	[ds:search_best], al
		mov	si, (offset FBUF+1Eh) ;	FBUF+FIND_BUF.PNAME ; FBUF+30
		mov	di, offset search_best_buf
		mov	cx, 13		; FNAME_MAX_LEN
		cld
		rep movsb		; save complete	pathname representation
		cmp	al, 8		; SEARCH_COM ; have we found the best of all?
		jz	short SEARCH_DONE ; yes

SEARCH_NEXT:				; ...
		mov	cx, 13h		; search_attr
		mov	ax, 4F00h
		int	21h		; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
					; [DTA]	= data block from
					; last AH = 4Eh/4Fh call
		jnb	short SEARCH_LOOP

SEARCH_DONE:				; ...
		mov	al, [ds:search_best] ; pick best to return with
		cmp	[ds:ext_entered], 1 ; byte ; Did user request a	specific ext?
		jz	short SEARCH_EXIT ; no - exit
		mov	al, [ds:ext_entered] ; yes - get the real file type back
		mov	[ds:search_best], al ; save the	real file type
		jmp	short SEARCH_EXIT
; ---------------------------------------------------------------------------

SEARCH_INVALID_DRIVE:			; ...
		mov	dx, [ds:search_error]
		call	std_printf

SEARCH_NO_FILE:				; ...
		mov	ax, 0		; SEARCH_FILE_NOT_FOUND	; = 0

SEARCH_EXIT:				; ...
		popf
		pop	si
		pop	di
		pop	dx
		pop	cx
		retn
endp		PSEARCH


; =============== S U B	R O U T	I N E =======================================


proc		SEARCH_FTYPE near	; ...
		push	di
		push	si
		mov	ax, 0
		mov	di, (offset FBUF+1Eh) ;	FBUF+FIND_BUF.PNAME ; FBUF+30
		mov	cx, 13
		cld
		repne scasb		; search for the terminating null
		jnz	short FTYPE_EXIT ; weird... no null byte at end
		sub	di, 5		; . + E	+ X + T	+ NULL
		mov	si, offset comext ; ".COM"
		mov	ax, di
		cmpsw
		jnz	short FTYPE_EXE
		cmpsw
		jnz	short FTYPE_EXE
		mov	ax, 8		; SEARCH_COM ; success!
		jmp	short FTYPE_EXIT
; ---------------------------------------------------------------------------

FTYPE_EXE:				; ...
		mov	di, ax
		mov	si, offset exeext ; ".EXE"
		cmpsw
		jnz	short FTYPE_BAT
		cmpsw
		jnz	short FTYPE_BAT
		mov	ax, 4		; SEARCH_EXE ; success!
		jmp	short FTYPE_EXIT
; ---------------------------------------------------------------------------

FTYPE_BAT:				; ...
		mov	di, ax
		mov	si, offset batext ; ".BAT"
		cmpsw
		jnz	short FTYPE_FAIL
		cmpsw
		jnz	short FTYPE_FAIL
		mov	ax, 2		; SEARCH_BAT ; success!
		jmp	short FTYPE_EXIT
; ---------------------------------------------------------------------------

FTYPE_FAIL:				; ...
		mov	ax, 0		; ANULL

FTYPE_EXIT:				; ...
		cmp	[ds:ext_entered], 1
		jz	short FTYPE_DONE
		cmp	ax, 0		; ANULL
		jz	short FTYPE_DONE
		mov	[ds:ext_entered], al
		mov	ax, 8

FTYPE_DONE:				; ...
		pop	si
		pop	di
		retn
endp		SEARCH_FTYPE


; =============== S U B	R O U T	I N E =======================================


proc		STRIP near		; ...
		push	ax
		push	bx
		push	cx
		push	dx
		push	di
		push	si
		pushf
		mov	[ds:ext_entered], 1
		mov	dx, [ds:ARG_ARGV] ; [ARG+ARGV_ELE.argpointer]
		mov	di, [ds:ARGV0_ARGSTARTEL] ; [ARG+ARGV_ELE.argstartel]
		cmp	[byte ptr di], 0
		jz	short STRIP_ERROR
		mov	cx, dx
		add	cx, [ds:ARGV0_ARGLEN] ;	[ARG+ARGV_ELE.arglen]
		sub	cx, di
		inc	cx
		mov	al, 2Eh	; '.'
		cld
		repne scasb
		jcxz	short PROCESS_EXT
		mov	[ds:ext_entered], 0
		mov	al, 0
		repne scasb

PROCESS_EXT:				; ...
		mov	cx, di
		sub	cx, dx
		sub	bx, 4
		cmp	cx, bx
		jg	short STRIP_ERROR
		mov	di, si
		mov	si, dx
		cld
		rep movsb
		cmp	[ds:ext_entered], 1
		jnz	short SKIP_WILDS
		dec	di
		stosb
		mov	al, 3Fh	; '?'   ; WILDCHAR
		stosb
		stosb
		stosb
		mov	al, 0		; ANULL
		stosb

SKIP_WILDS:				; ...
		popf
		clc
		jmp	short STRIP_EXIT
; ---------------------------------------------------------------------------

STRIP_ERROR:				; ...
		popf
		stc

STRIP_EXIT:				; ...
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn
endp		STRIP


; =============== S U B	R O U T	I N E =======================================


proc		SAVE_ARGS near		; ...
		push	bx
		push	cx
		push	dx
		push	di
		push	si
		push	bp
		pushf
		add	bx, 1107	; ARG_UNIT.SIZE+15 ; 1092+15 = 1107
		mov	cl, 4
		shr	bx, cl
		mov	ax, 4800h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short SAVE_ERROR
		mov	bp, ax
		push	es
		mov	es, ax
		assume es:nothing
		mov	cx, 1092
		xor	di, di
		mov	si, offset ARG_ARGV ; ARG
		rep movsb
		mov	cx, [ds:ARG_ARGVCNT] ; [ARG+ARG_UNIT.argvcnt]
		xor	ax, ax
		mov	si, offset ARG_ARGV ; ARG

SAVE_PTR_LOOP:				; ...
		dec	cx
		jl	short SAVE_DONE
		mov	bx, cx
		call	argv_calc
		mov	dx, [ds:ARG_ARGV+bx] ; [ARG+ARGV_ELE.argpointer+bx]
		sub	dx, si
		mov	[es:bx], dx
		mov	dx, [ds:ARGV0_ARGSTARTEL+bx] ; [ARG+ARGV_ELE.argstartel+bx]
		sub	dx, si
		mov	[es:bx+3], dx	; [es:bx+ARGV_ELE.argstartel]
		mov	dx, [ds:ARGV0_OCOMPTR+bx] ; [ARG+ARGV_ELE.arg_ocomptr+bx]
		sub	dx, si
		mov	[es:bx+9], dx	; [es:bx+ARGV_ELE.arg_ocomptr]
		jmp	short SAVE_PTR_LOOP
; ---------------------------------------------------------------------------

SAVE_DONE:				; ...
		pop	es
		assume es:nothing
		mov	ax, bp
		jmp	short SAVE_OK
; ---------------------------------------------------------------------------

SAVE_ERROR:				; ...
		popf
		stc
		jmp	short SAVE_EXIT
; ---------------------------------------------------------------------------

SAVE_OK:				; ...
		popf
		clc

SAVE_EXIT:				; ...
		pop	bp
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		retn
endp		SAVE_ARGS

; ---------------------------------------------------------------------------

notest2:				; ...
		mov	cx, 11
		mov	si, 5Dh		; FCB+1

ambspec:				; ...
		lodsb
		cmp	al, 3Fh	; '?'
		jnz	short allfil
		loop	ambspec

allfil:					; ...
		cmp	cx, 0
		jnz	short noprmpt

askagn:					; ...
		mov	dx, offset SureMes_Ptr
		call	std_printf
		mov	si, 80h
		mov	dx, si
		mov	[word ptr si], 120
		mov	ax, 0C0Ah
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		lodsw
		or	ah, ah
		jz	short askagn
		call	scanoff
		call	char_in_xlat
		jnb	short check_yn

answ_no:				; ...
		retn
; ---------------------------------------------------------------------------

check_yn:				; ...
		cmp	al, 0
		jz	short answ_no
		cmp	al, 1
		pushf
		call	CRLF2
		popf
		jnz	short askagn

noprmpt:				; ...
		mov	ah, 13h		; FCB_Delete
		mov	dx, 5Ch		; FCB
		int	21h		; DOS -	DELETE FILE via	FCB
					; DS:DX	-> FCB with filename field filled with
					; template for	deletion ('?' wildcard allowed, but not '*')
					; Return: AL = 00h file	found, FFh file	not found
		inc	al
		jz	short eraerr
		call	RestUDir
		retn
; ---------------------------------------------------------------------------

eraerr:					; ...
		call	Set_Ext_Error_Msg
		push	dx
		call	RestUDir
		pop	dx
		cmp	[ds:extend_buf_ptr], 18	; ERROR_NO_MORE_FILES
		jnz	short cerrorj2
		mov	[ds:extend_buf_ptr], 2 ; ERROR_FILE_NOT_FOUND

cerrorj2:				; ...
		jmp	cerror
; ---------------------------------------------------------------------------

slashp_erase:				; ...
		call	build_dir_string
		mov	ah, 1Ah		; Set_DMA
		mov	dx, offset DESTDIR
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		mov	ah, 11h		; Dir_Search_First
		mov	dx, 5Ch		; FCB
		int	21h		; DOS -	SEARCH FIRST USING FCB
					; DS:DX	-> FCB
		inc	al
		jz	short eraerr

delete_prompt_loop:			; ...
		mov	si, (offset DESTDIR+1)
		mov	di, offset DEST
		mov	al, [ds:DIRCHAR]
		stosb
		call	FCB_TO_ASCZ

slashp_askagn:				; ...
		call	CRLF2
		mov	dx, offset BWDBUF
		mov	bx, dx
		cmp	[byte ptr bx+3], 0 ; END_OF_LINE_OUT
		jnz	short not_del_root
		mov	[byte ptr bx+2], 0

not_del_root:				; ...
		mov	[ds:string_ptr_2], dx
		mov	dx, offset string_buf_ptr
		call	std_printf
		mov	dx, offset DEST
		mov	[ds:string_ptr_2], dx
		mov	dx, offset string_buf_ptr
		call	std_printf
		mov	dx, offset Del_Y_N_Ptr
		call	std_printf
		mov	ax, 0C01h	; (STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		call	char_in_xlat
		jnb	short slashp_check_yn
		retn
; ---------------------------------------------------------------------------

slashp_check_yn:			; ...
		cmp	al, 0
		jz	short next_del_file
		cmp	al, 1
		jz	short delete_this_file
		jmp	short slashp_askagn
; ---------------------------------------------------------------------------

delete_this_file:			; ...
		mov	ah, 13h		; FCB_Delete
		mov	dx, offset DESTDIR
		int	21h		; DOS -	DELETE FILE via	FCB
					; DS:DX	-> FCB with filename field filled with
					; template for	deletion ('?' wildcard allowed, but not '*')
					; Return: AL = 00h file	found, FFh file	not found
		inc	al
		jnz	short next_del_file
		call	get_ext_error_number
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		jnz	short stop_del
		call	CRLF2
		call	Set_Ext_Error_Msg
		call	std_eprintf
		jmp	short next_del_file
; ---------------------------------------------------------------------------

stop_del:				; ...
		jmp	eraerr
; ---------------------------------------------------------------------------

next_del_file:				; ...
		mov	ah, 1Ah
		mov	dx, offset DESTDIR
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		mov	ah, 12h
		mov	dx, 5Ch
		int	21h		; DOS -	SEARCH NEXT USING FCB
					; DS:DX	-> FCB
					; Return: AL = status
		inc	al
		jz	short slash_p_exit
		jmp	delete_prompt_loop
; ---------------------------------------------------------------------------

slash_p_exit:				; ...
		call	get_ext_error_number
		cmp	ax, 18		; ERROR_NO_MORE_FILES
		jz	short good_erase_exit
		jmp	extend_setup
; ---------------------------------------------------------------------------

good_erase_exit:			; ...
		call	RestUDir
		call	CRLF2
		retn
; ---------------------------------------------------------------------------

_ECHO:					; ...
		call	ON_OFF
		jb	short DOEMES
		mov	ds, [ds:RESSEG]
		jnz	short ECH_OFF
		or	[ds:EchoFlag], 1
		retn
; ---------------------------------------------------------------------------

ECH_OFF:				; ...
		and	[ds:EchoFlag], 0FEh
		retn
; ---------------------------------------------------------------------------

CERRORJ:				; ...
		jmp	cerror
; ---------------------------------------------------------------------------

DOEMES:					; ...
		cmp	cl, 0
		jz	short PECHO
		mov	dx, 82h
		call	CRPRINT
		jmp	CRLF2
; ---------------------------------------------------------------------------

PECHO:					; ...
		mov	ds, [ds:RESSEG]
		mov	bl, [ds:EchoFlag]
		push	cs
		pop	ds
		assume ds:TRANGROUP
		and	bl, 1
		mov	dx, offset EchoMes_Ptr
		jmp	short PYN
; ---------------------------------------------------------------------------

CNTRLC:					; ...
		call	ON_OFF
		mov	ax, 3301h	; (Set_CTRL_C_Trapping<<8)|1
		jb	short PCNTRLC
		jnz	short CNTRLC_OFF
		mov	dl, 1
		int	21h		; DOS -	EXTENDED CONTROL-BREAK CHECKING
					; AL = 00h get state / 01h set state / 02h set AND get
					; DL = 00h for OFF or 01h for ON
		retn
; ---------------------------------------------------------------------------

CNTRLC_OFF:				; ...
		xor	dl, dl
		int	21h		; DOS -
		retn
; ---------------------------------------------------------------------------

PCNTRLC:				; ...
		cmp	cl, 0
		jnz	short CERRORJ
		xor	al, al
		int	21h		; DOS -
		mov	bl, dl
		mov	dx, offset CtrlcMes_Ptr

PYN:					; ...
		mov	si, offset ONMES_PTR
		or	bl, bl
		jnz	short PRINTVAL
		mov	si, offset OFFMES_PTR

PRINTVAL:				; ...
		push	dx
		mov	bx, dx
		lodsw
		mov	dh, 0FFh	; util_msg_class
		call	TSYSGETMSG
		add	bx, 5		; Ptr_off_pos
		mov	[bx], si
		pop	dx
		call	std_printf
		mov	[word ptr bx], 0
		retn
; ---------------------------------------------------------------------------

VERIFY:					; ...
		call	ON_OFF
		mov	ax, 2E01h	; (SET_VERIFY_ON_WRITE<<8)|1
		jb	short PVERIFY
		jnz	short VER_OFF
		int	21h		; DOS -	SET VERIFY FLAG
					; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off
		retn
; ---------------------------------------------------------------------------

VER_OFF:				; ...
		dec	al
		int	21h		; DOS -
		retn
; ---------------------------------------------------------------------------

PVERIFY:				; ...
		cmp	cl, 0
		jnz	short CERRORJ
		mov	ah, 54h
		int	21h		; DOS -	2+ - GET VERIFY	FLAG
					; Return: AL = 00h if flag OFF
					; AL = 01h if flag ON
		mov	bl, al
		mov	dx, offset VeriMes_Ptr
		jmp	short PYN

; =============== S U B	R O U T	I N E =======================================


proc		ON_OFF near		; ...
		mov	si, 81h

scan_on_off:				; ...
		lodsb
		cmp	al, 20h	; ' '
		jz	short scan_on_off
		cmp	al, 9
		jz	short scan_on_off
		cmp	al, 3Dh	; '='
		jz	short parse_on_off
		dec	si

parse_on_off:				; ...
		mov	di, offset PARSE_BREAK
		xor	cx, cx
		xor	dx, dx
		call	cmd_parse
		cmp	ax, 0FFFFh	; END_OF_LINE
		jz	short BADONF
		cmp	ax, 0
		jz	short on_off_there
		mov	cx, ax
		jmp	short BADONF
; ---------------------------------------------------------------------------

on_off_there:				; ...
		cmp	[PARSE1_CODE], 0FFh
		jnz	short good_on_off
		mov	cx, 0Ah		; BadParm_Ptr
		jmp	short BADONF
; ---------------------------------------------------------------------------

good_on_off:				; ...
		xor	ax, ax
		or	al, [PARSE1_CODE]
		pushf
		mov	di, offset PARSE_BREAK
		xor	dx, dx
		call	cmd_parse
		cmp	ax, 0FFFFh	; END_OF_LINE
		jnz	short BADONF_flags
		popf
		clc
		jmp	short on_off_end
; ---------------------------------------------------------------------------

BADONF_flags:				; ...
		mov	cx, ax
		popf

BADONF:					; ...
		mov	dx, offset bad_on_off_ptr
		stc

on_off_end:				; ...
		retn
endp		ON_OFF

; ---------------------------------------------------------------------------

PRINT_DATE:				; ...
		push	es
		push	di
		push	cs
		pop	es
		assume es:TRANGROUP
		call	GetDate
		xchg	dh, dl
		mov	[promptDat_yr],	cx
		mov	[promptDat_moday], dx
		mov	dx, offset promptdat_ptr
		call	std_printf
		pop	di
		pop	es
		assume es:nothing
		retn

; =============== S U B	R O U T	I N E =======================================


proc		GetDate	near		; ...
		mov	di, offset TPBUF ; Arg_Buf
		mov	ah, 2Ah
		int	21h		; DOS -	GET CURRENT DATE
					; Return: DL = day, DH = month,	CX = year
					; AL = day of the week (0=Sunday, 1=Monday, etc.)
		cbw
		push	cx
		push	dx
		mov	si, ax
		shl	si, 1
		add	si, ax
		mov	cx, si
		mov	ax, [WeekTab]
		mov	dh, 0FFh	; util_msg_class
		push	di
		call	TSYSGETMSG
		pop	di
		add	si, cx
		rep movsb
		mov	al, 0		; END_OF_LINE_OUT
		stosb
		pop	dx
		pop	cx
		retn
endp		GetDate


; =============== S U B	R O U T	I N E =======================================


proc		char_in_xlat near	; ...
		mov	dl, al
		xor	dh, dh
		mov	ax, 6523h	; (GetExtCntry<<8)+23h
		int	21h		; DOS -	4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
					; AL = function	-
		retn
endp		char_in_xlat

; ---------------------------------------------------------------------------

COPY:					; ...
		xor	ax, ax		; 0
		mov	[Copy_num], ax
		mov	[SRCPT], ax
		mov	[SrcTail], ax
		mov	[CFLAG], al
		mov	[NXTADD], ax
		mov	[DestSwitch], ax
		mov	[STARTEL], ax
		mov	[DestTail], ax
		mov	[SPECDRV], al	; DestClosed
		mov	[DestSiz], al
		mov	[SrcSiz], al
		mov	[DestInfo], al
		mov	[SrcInfo], al
		mov	[INEXACT], al
		mov	[DestIsDir], al	; DestVars
		mov	[SrcIsDir], al	; SrcVars
		mov	[USERDIR1], al
		mov	[NOWRITE], al
		mov	[IFNOTFLAG], al	; RDEOF
		mov	[SRCHAND], ax
		mov	[CPDATE], ax
		mov	[CPTIME], ax
		mov	[SRCISDEV], al
		mov	[zflag], al	; OCtrlZ
		mov	[OFilePtr_Lo], ax
		mov	[OFilePtr_Hi], ax
		mov	[TERMREAD], al
		mov	[comma], al
		mov	[plus_comma], al
		mov	[msg_flag], al
		mov	[ARGTS], ax	; AllSwitch
		mov	[PARM2], al	; ArgC
		mov	[PLUS],	al
		mov	[BINARY], al
		mov	[ASCII], al
		mov	[FileCnt], ax
		mov	[WRITTEN], ax
		mov	[PARM1], al	; Concat
		mov	[MELCOPY], al
		mov	[MELSTART], ax
		mov	[cox_dest_file], al
		mov	[cox_src_file],	al
		mov	[word ptr ScanBuf], ax
		mov	[word ptr DestBuf], ax
		mov	[word ptr SrcBuf], ax
		mov	[word ptr SDIRBUF], ax
		mov	[word ptr BWDBUF], ax ;	DIRBUF
		mov	[word ptr DESTDIR], ax ; DestFcb
		mov	[objcnt], al
		dec	ax
		mov	[EndDestBuf], ax ; DESTHAND
		mov	[FRSTSRCH], al
		mov	[FIRSTDEST], al
		mov	[DestIsDir], al
		call	init_copycmd_option
		mov	si, 81h
		mov	bl, 2Bh	; '+'   ; PLUS_CHR
		inc	[expand_star]	; byte ; CParse	'expand * to ?s' = true
		mov	[cpyflag], 1	; CParse 'called from COPY' = true

DESTSCAN:				; ...
		xor	bp, bp
		mov	di, offset ScanBuf
		mov	[parse_last], si
		call	cparse
		pushf			;  (*) ; save CParse flags
		inc	[objcnt]	; byte
		test	bh, 80h
		jz	short NOCOPY	; no "+" delimiter
		mov	[PLUS],	1	; "+" delimiter	occurred

NOCOPY:					; ...
		test	bh, 1
		jnz	short CHK_CP_SWITCH
		jmp	TESTP2
; ---------------------------------------------------------------------------

CHK_CP_SWITCH:				; ...
		test	bp, 10h		; Verify requested?
		jz	short NOT_SLASHV ; No
		test	[ARGTS], 10h	; test word [AllSwitch],10h
		jz	short NOT_SLASHV
		or	bp, 4000h	; FBadSwitch

NOT_SLASHV:				; ...
		test	bp, 40h		; negative Y (-Y) switch flag
		jz	short CHK_SLASHY0
		test	[ARGTS], 40h	; [AllSwitch] ;	negative (-Y) flag
		jnz	short NOT_SLASHY1
		test	[ARGTS], 80h	; [AllSwitch] ;	SwitchY	(Y) flag
		jz	short NOT_SLASHY2

NOT_SLASHY1:				; ...
		or	bp, 4000h	; FBadSwitch (Repetitive)

NOT_SLASHY2:				; ...
		mov	[cox_y_override], 0 ; cox_y setting will be used

CHK_SLASHY0:				; ...
		test	bp, 80h
		jz	short CHK_SLASHY4
		mov	al, [si]
		cmp	al, 'y'
		jz	short CHK_SLASHY1
		cmp	al, 'Y'
		jz	short CHK_SLASHY1
		or	bp, 4000h	; FBadSwitch
		jmp	short CHK_SLASHY4
; ---------------------------------------------------------------------------

CHK_SLASHY1:				; ...
		mov	[byte ptr si], 20h ; ' '
		inc	si
		test	[ARGTS], 40h	; [AllSwitch] ;	negative (-Y) flag
		jnz	short CHK_SLASHY2 ; N flag
		test	[ARGTS], 80h	; [AllSwitch] ;	SwitchY	(Y) flag
		jz	short CHK_SLASHY3

CHK_SLASHY2:				; ...
		or	bp, 4000h	; FBadSwitch (Repetitive)

CHK_SLASHY3:				; ...
		mov	[cox_y_override], 1

CHK_SLASHY4:				; ...
		or	[DestSwitch], bp ; set [DestSwitch] SwitchY flag to 1
		or	[ARGTS], bp	; set [AllSwitch] SwitchY flag to 1
		test	bp, 7F23h	; ~SwitchCopy  ; Bad switch?
		jz	short NOT_BAD_SWITCH
		popf			; (*) ;	fix up stack
		mov	ax, 3		; BadSwt_Ptr
					; get "Invalid switch" message number
		call	setup_parse_error_msg
		jmp	cerror
; ---------------------------------------------------------------------------

NOT_BAD_SWITCH:				; ...
		popf
		jb	short CHECKDONE
		jmp	DESTSCAN
; ---------------------------------------------------------------------------

TESTP2:					; ...
		popf			; (*) ;	restore	CParse flags
		jb	short CHECKDONE
		test	bh, 80h
		jnz	short GOTPLUS	; found	a "+pathname" argument
		inc	[PARM2]		; inc byte [ArgC]

GOTPLUS:				; ...
		push	si
		mov	ax, [STARTEL]
		mov	si, offset ScanBuf
		sub	ax, si
		mov	di, offset DestBuf
		add	ax, di
		mov	[DestTail], ax
		mov	[DestSiz], cl
		inc	cx
		rep movsb
		mov	[DestInfo], bh
		mov	[DestSwitch], 0	; word
		pop	si
		jmp	DESTSCAN
; ---------------------------------------------------------------------------

CHECKDONE:				; ...
		cmp	[PLUS],	1	; "+" with
		jnz	short CDCONT
		cmp	[PARM2], 1	; cmp byte [ArgC],1 ; one arg,
		jnz	short CDCONT
		cmp	[objcnt], 2	; two objects..
		jnz	short CDCONT
		mov	dx, offset OVERWR_PTR
		jmp	COPYERR
; ---------------------------------------------------------------------------

CDCONT:					; ...
		mov	al, [PLUS]
		mov	[PARM1], al	; mov [Concat],al
					; if "+" occurred, we're concatenating
		shl	al, 1
		shl	al, 1
		mov	[INEXACT], al	; therefore making an inexact copy
		mov	al, [PARM2]	; [ArgC] ; AL =	# independent arguments
		or	al, al
		jnz	short TRY_TOO_MANY
		mov	dx, offset extend_buf_ptr
		mov	[extend_buf_ptr], 2 ; LessArgs_Ptr ; set msg # "param missing"
		jmp	short CERROR_PARSEJ
; ---------------------------------------------------------------------------

TRY_TOO_MANY:				; ...
		cmp	al, 2
		jbe	short ACOUNTOK	; <= 2 arguments - ok
		mov	dx, offset extend_buf_ptr
		mov	[extend_buf_ptr], 1 ; MoreArgs_Ptr ; set msg # "too many params"

CERROR_PARSEJ:				; ...
		mov	[msg_disp_class], 2 ; parse_msg_class ;	parse error message

CERROR4J:				; ...
		jmp	cerror
; ---------------------------------------------------------------------------

ACOUNTOK:				; ...
		mov	bp, offset DestIsDir ; DestVars	; BP = base of dest variables
		cmp	al, 1
		jnz	short GOT2ARGS
		mov	al, [CURDRV]
		add	al, 'A'
		mov	ah, ':'
		mov	[byte ptr bp+1], 2 ; [bp+VARSTRUC.SIZ],2 ; pathname length = 2
		mov	di, offset DestBuf
		stosw
		mov	[DestSwitch], 0	; word
		mov	[byte ptr bp+4], 2 ; [bp+VARSTRUC.INFO]	; 'wildcard present'
		mov	[byte ptr bp+0], 0 ; [bp+VARSTRUC.ISDIR] ; 'not a directory'
		call	SETSTARS

GOT2ARGS:				; ...
		cmp	[byte ptr bp+1], 2 ; [bp+VARSTRUC.SIZ],2
		jnz	short NOTSHORTDEST ; not two chars, can't be "d:"
		mov	al, ':'
		cmp	[DestBuf+1], al
		jnz	short NOTSHORTDEST ; it's just a 2-character filename
		or	[byte ptr bp+4], 2 ; [bp+VARSTRUC.INFO]	; 'wildcard present'
		mov	di, (offset DestBuf+2) ; ES:DI = ptr after "d:"
		mov	[byte ptr bp+0], 0 ; [bp+VARSTRUC.ISDIR] ; 'not a directory'
		call	SETSTARS	; add wildcards

NOTSHORTDEST:				; ...
		mov	di, [bp+2]	; [bp+VARSTRUC.TTAIL]
		cmp	[byte ptr di], 0
		jnz	short CHKSWTCHES ; not a null, so last char not	"\"
		mov	dx, offset badcd_ptr
		mov	al, ':'
		cmp	[di-2],	al
		jnz	short CERROR4J	; it's not "d:\", exit with error msg
		mov	[byte ptr bp+0], 2 ; [bp+VARSTRUC.ISDIR],2
					; destination 'is a directory'
		or	[byte ptr bp+4], 6 ; [bp+VARSTRUC.INFO],6
					; destination wildcarded and contains path character
		call	SETSTARS

CHKSWTCHES:				; ...
		mov	ax, [ARGTS]	; [AllSwitch]  ; AX = all switch flags
		test	ax, 10h		; SwitchV
		jz	short NOVERIF	; no /v, no verify
		mov	ah, 54h		; Get_Verify_On_Write
		int	21h		; DOS -	2+ - GET VERIFY	FLAG
					; Return: AL = 00h if flag OFF
					; AL = 01h if flag ON
		push	ds
		mov	ds, [RESSEG]
		assume ds:RESGROUP
		xor	ah, ah
		mov	[VerVal], ax	; save current verify flag
		pop	ds
		assume ds:nothing
		mov	ax, 2E01h	; (SET_VERIFY_ON_WRITE<<8)|1
		int	21h		; DOS -	SET VERIFY FLAG
					; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off

NOVERIF:				; ...
		xor	bp, bp		; BP = switch flags accumulator
		mov	si, 81h		; SI = ptr into	command	line
		mov	bl, 2Bh	; '+'   ; BL = special CParse delimiter = "+"

SCANFSRC:				; ...
		mov	di, offset ScanBuf ; DI	= ptr to pathname buf
		call	cparse		; parse	first source pathname
		test	bh, 1		; switch?
		jnz	short SCANFSRC	; yes, try again
		or	[ds:DestSwitch], bp ; include copy-wide	switches on dest
		test	bp, 8		; SWITCHB
		jnz	short NOSETCASC	; /b - explicit	binary copy
		cmp	[ds:PARM1], 0	; cmp byte [Concat],0
		jz	short NOSETCASC	; we're not concatenating
		mov	[ds:ASCII], 4	; SWITCHA ; set	ascii copy

NOSETCASC:				; ...
		call	SOURCE_SET	; set source variables
		call	FRSTSRC		; set up first source copy
		jmp	FIRSTENT	; jump into the	copy loop
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR DOCOPY

ENDCOPY:				; ...
		call	CLOSEDEST	; Close	destination

ENDCOPY2:				; ...
		mov	dx, offset copied_ptr ;	display	# (destination)	files copied
		mov	si, [ds:FileCnt]
		mov	[ds:Copy_num], si
		call	std_printf
		jmp	TCOMMAND	; stack	could be messed	up
; END OF FUNCTION CHUNK	FOR DOCOPY
; ---------------------------------------------------------------------------

SRCNONEXIST:				; ...
		cmp	[ds:PARM1], 0	; cmp byte [Concat],0
		jnz	short NEXTSRC	; concatenating	- go on	to next	source
		mov	[ds:msg_disp_class], 1 ; ext_msg_class ; extended error	msg
		mov	dx, offset extend_buf_ptr
		mov	[ds:extend_buf_ptr], 2 ; ERROR_FILE_NOT_FOUND
		mov	[ds:string_ptr_2], offset SrcBuf ; point at bad	pathname
		mov	[ds:extend_buf_sub], 1 ; one_subst ; 1 substitution
		jmp	COPYERR		; print	msg and	clean up

; =============== S U B	R O U T	I N E =======================================


proc		SOURCEPROC near		; ...
		call	SOURCE_SET
		cmp	[ds:PARM1], 0	; cmp byte [Concat],0
		jnz	short LEAVECFLAG
endp		SOURCEPROC


; =============== S U B	R O U T	I N E =======================================


proc		FRSTSRC	near		; ...
		xor	ax, ax		; 0
		mov	[ds:CFLAG], al
		mov	[ds:NXTADD], ax
		mov	[ds:SPECDRV], al

LEAVECFLAG:				; ...
		mov	[ds:SRCPT], si
		mov	di, offset USERDIR1
		mov	bp, offset SrcIsDir ; SrcVars
		mov	bx, 40h		; deny_none|read_open_mode
		call	BUILDPATH
		mov	si, [ds:SrcTail]
		retn
endp		FRSTSRC

; ---------------------------------------------------------------------------

NEXTSRC:				; ...
		cmp	[ds:PLUS], 0	; byte
		jnz	short MORECP

ENDCOPYJ2:				; ...
		jmp	short ENDCOPY
; ---------------------------------------------------------------------------

MORECP:					; ...
		xor	bp, bp
		mov	si, [ds:SRCPT]
		mov	bl, 2Bh	; '+'   ; PLUS_CHR

SCANSRC:				; ...
		mov	di, offset ScanBuf
		call	cparse
		jb	short ENDCOPYJ2
		test	bh, 80h
		jz	short ENDCOPYJ2	; no "+" delimiter - we're done
		test	bh, 1
		jnz	short SCANSRC	; switch found - keep looking
		call	SOURCEPROC
		cmp	[ds:comma], 1	; was +,, found	last time?
		jnz	short NOSTAMP	; no - try for a file
		mov	[ds:plus_comma], 1 ; yes - set flag
		jmp	SRCNONEXIST	; we know we won't find it
; ---------------------------------------------------------------------------

NOSTAMP:				; ...
		mov	[ds:plus_comma], 0 ; reset +,, flag

FIRSTENT:				; ...
		mov	di, 5Ch		; FCB
		mov	ax, 2900h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		cmp	[byte ptr si], 0 ; did we parse	the whole thing?
		jnz	short SRCHDONE	; no, error, simulate 'not found'
		mov	ax, [word ptr ds:SrcBuf]
		cmp	ah, ':'
		jz	short DRVSPEC1
		mov	al, 40h	; '@'   ; AL = drive 'letter' for current drive

DRVSPEC1:				; ...
		or	al, 20h		; AL = lowercase drive letter
		sub	al, 60h
		mov	[ds:5Ch], al	; mov [FCB],al ; AL = drive id (0=current,1=A,..)
		mov	ah, 11h		; Dir_Search_First
					; AH = 'Find First File'
		call	SEARCH

SRCHDONE:				; ...
		pushf
		call	RestUDir1	; restore users	current	directory
		popf
		jz	short NEXTAMBIG0
		jmp	SRCNONEXIST
; ---------------------------------------------------------------------------

NEXTAMBIG0:				; ...
		xor	al, al
		xchg	al, [ds:FRSTSRCH]
		or	al, al
		jz	short NEXTAMBIG

SETNMEL:				; ...
		mov	cx, 12
		mov	di, offset SDIRBUF
		mov	si, offset BWDBUF ; DIRBUF
		rep movsb

NEXTAMBIG:				; ...
		xor	al, al
		mov	[ds:NOWRITE], al
		mov	di, [ds:SrcTail]
		mov	si, (offset BWDBUF+1) ;	offset DIRBUF+1
		call	FCB_TO_ASCZ

MELDO0:					; ...
		cmp	[ds:cox_y_override], 0 ; /Y switch override (question) enabled ?
		jz	short MELDO	; no
		call	BUILDDEST
		mov	si, offset SrcBuf
		mov	di, offset SRCXNAME
		mov	ax, 6000h
		int	21h		; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
					; DS:SI	-> ASCIZ relative path string or directory name
					; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
		call	COMPNAME
		jnz	short MELDO1	; different file names
		cmp	[ds:PARM1], 0	; cmp byte [Concat],0
		jnz	short MELDO1	; concatenating
		mov	dx, offset file_name_ptr
		call	std_printf
		call	CRLF2
		mov	dx, offset OVERWR_PTR ;	"File cannot be	copied onto itself"
		jmp	COPYERR
; ---------------------------------------------------------------------------

MELDO1:					; ...
		cmp	[ds:CFLAG], 0	; destination file created flag
		jnz	short MELDO	; yes, new (created) file
		call	get_answer_YNA
		jb	short MELDO2	; answer is no
		cmp	[ds:PARM1], 0	; cmp byte [Concat],0
		jnz	short MELDO
		cmp	[ds:cox_dest_file], 0 ;	is there a (valid) target file ?
		jnz	short DOREAD	; yes
		jmp	short MELDO	; no, destination/target file does not exist
; ---------------------------------------------------------------------------

MELDO2:					; ...
		cmp	[ds:MELCOPY], 0	; is 'Mel Hallerman copy' false ?
		jnz	short MELDO3	; no (,	it is true)
		cmp	[ds:PARM1], 0	; cmp byte [Concat],0
		jz	short MELDO4

MELDO3:					; ...
		mov	[ds:SPECDRV], 1	; mov byte [DestClosed],1
		jmp	ENDCOPY
; ---------------------------------------------------------------------------

MELDO4:					; ...
		call	SEARCHNEXT
		jz	short NEXTAMBIG
		cmp	[ds:cox_src_file], 0
		jz	short MELDO5
		jmp	NEXTSRC
; ---------------------------------------------------------------------------

MELDO5:					; ...
		mov	[ds:SPECDRV], 1	; mov byte [DestClosed],1
		jmp	NEXTSRC
; ---------------------------------------------------------------------------

MELDO:					; ...
		cmp	[ds:PARM1], 0	; cmp byte [Concat],0
		jnz	short SHOWCPNAM	; concatenating	- show name
		test	[ds:SrcInfo], 2	; wildcard - show name
		jz	short DOREAD

SHOWCPNAM:				; ...
		mov	dx, offset file_name_ptr
		call	std_printf
		call	CRLF2

DOREAD:					; ...
		call	DOCOPY
		cmp	[ds:PARM1], 0	; cmp byte [Concat],0
		jnz	short NODCLOSE
		call	CLOSEDEST
		jb	short NODCLOSE
		mov	[ds:CFLAG], 0

NODCLOSE:				; ...
		cmp	[ds:PARM1], 0	; cmp byte [Concat],0
		jz	short NOFLUSH
		call	FlshFil
		test	[ds:MELCOPY], 0FFh
		jnz	short DOMELCOPY

NOFLUSH:				; ...
		call	SEARCHNEXT
		jnz	short NEXTSRCJ
		mov	[ds:SPECDRV], 0	; mov byte [DestClosed],0
		jmp	NEXTAMBIG
; ---------------------------------------------------------------------------

DOMELCOPY:				; ...
		cmp	[ds:MELCOPY], 0FFh
		jz	short CONTMEL
		mov	si, [ds:SRCPT]
		mov	[ds:MELSTART], si
		mov	[ds:MELCOPY], 0FFh

CONTMEL:				; ...
		xor	bp, bp
		mov	si, [ds:SRCPT]
		mov	bl, 2Bh	; '+'   ; PLUS_CHR

SCANSRC2:				; ...
		mov	di, offset ScanBuf
		call	cparse
		test	bh, 80h
		jz	short NEXTMEL
		test	bh, 1
		jnz	short SCANSRC2
		call	SOURCEPROC
		call	RestUDir1
		mov	di, offset IDLEN ; DESTFCB2
		mov	ax, 2900h	; Parse_File_Descriptor*256
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		mov	bx, (offset SDIRBUF+1)
		mov	si, offset ID	; DESTFCB2+1
		mov	di, [ds:SrcTail]
		call	BUILDNAME
		cmp	[ds:PARM1], 0	; cmp byte [Concat],0
		jz	short MELDOJ
		mov	[ds:NOWRITE], 0

MELDOJ:					; ...
		jmp	MELDO0
; ---------------------------------------------------------------------------

NEXTSRCJ:				; ...
		jmp	NEXTSRC
; ---------------------------------------------------------------------------

NEXTMEL:				; ...
		call	CLOSEDEST
		xor	ax, ax		; 0
		mov	[ds:CFLAG], al
		mov	[ds:NXTADD], ax
		mov	[ds:SPECDRV], al
		mov	si, [ds:MELSTART]
		mov	[ds:SRCPT], si
		call	SEARCHNEXT
		jz	short SETNMELJ
		jmp	ENDCOPY2
; ---------------------------------------------------------------------------

SETNMELJ:				; ...
		jmp	SETNMEL

; =============== S U B	R O U T	I N E =======================================


proc		SEARCHNEXT near		; ...
		mov	ah, 12h		; Dir_Search_Next
		test	[ds:SrcInfo], 2
		jnz	short SEARCH	; do search-next if ambig
		or	ah, ah		; reset	zero flag
		retn
endp		SEARCHNEXT


; =============== S U B	R O U T	I N E =======================================


proc		SEARCH near		; ...
		push	ax
		mov	ah, 1Ah		; Set_DMA
		mov	dx, offset BWDBUF ; offset DIRBUF
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		pop	ax
		mov	dx, 5Ch		; FCB
		int	21h		; Do the search
		or	al, al
		retn
endp		SEARCH


; =============== S U B	R O U T	I N E =======================================


proc		DOCOPY near		; ...

; FUNCTION CHUNK AT 3FA4 SIZE 00000014 BYTES

		mov	si, offset SrcBuf
		mov	di, offset SRCXNAME
		mov	ax, 6000h	; xNameTrans*256
		int	21h		; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
					; DS:SI	-> ASCIZ relative path string or directory name
					; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
		mov	[ds:IFNOTFLAG],	0 ; mov	byte [RDEOF],0
		mov	ax, 6C00h	; ExtOpen shl 8
		mov	bx, 40h		; deny_none|read_open_mode
		xor	cx, cx
		mov	dx, 101h	; read_open_flag
		int	21h		; DOS -	4.0 - EXTENDED OPEN/CREATE
					; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
					; BH = flags, CX = create attribute, DL	= action if file exists/does not exists
					; DH = 00h (reserved), DS:SI ->	ASCIZ file name
		jb	short Error_On_Source
		mov	bx, ax
		mov	[ds:SRCHAND], bx
		mov	ax, 5700h	; File_Times*256
		int	21h		; DOS -	2+ - GET FILE'S DATE/TIME
					; BX = file handle
		jb	short Error_On_Source
		mov	[ds:CPDATE], dx
		mov	[ds:CPTIME], cx
		jmp	short No_Copy_Xa
; ---------------------------------------------------------------------------

Error_On_Source:			; ...
		call	Set_Ext_Error_Msg
		mov	[ds:string_ptr_2], offset SrcBuf
		mov	[ds:extend_buf_sub], 1 ; one_subst
		call	std_eprintf
		cmp	[ds:SRCHAND], 0	; did we open the file?
		jz	short No_Close_Src ; no	- don't close
		call	CLOSESRC

No_Close_Src:				; ...
		cmp	[ds:CFLAG], 0	; was destination created?
		jz	short EndCopyJ3	; no - just cleanup and	exit
		jmp	ENDCOPY		; clean	up concatenation and exit
; ---------------------------------------------------------------------------

EndCopyJ3:				; ...
		jmp	ENDCOPY2
; ---------------------------------------------------------------------------

No_Copy_Xa:				; ...
		mov	bx, [ds:SRCHAND]
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		and	dl, 80h		; devid_ISDEV
		mov	[ds:SRCISDEV], dl
		jz	short COPYLP	; source not a device
		cmp	[ds:BINARY], 0
		jz	short COPYLP	; ascii	device ok
		mov	dx, offset INBDEV_PTR ;	cannot do binary input
		jmp	COPYERR
; ---------------------------------------------------------------------------

COPYLP:					; ...
		mov	bx, [ds:SRCHAND]
		mov	cx, [ds:BYTCNT]
		mov	dx, [ds:NXTADD]
		sub	cx, dx		; compute available space
		jnz	short GOTROOM
		call	FlshFil
		cmp	[ds:TERMREAD], 0
		jnz	short CLOSESRC
		mov	cx, [ds:BYTCNT]

GOTROOM:				; ...
		push	ds
		mov	ds, [ds:TPA]
		mov	ah, 3Fh
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		pop	ds
		jb	short Error_On_Source
		mov	cx, ax		; get count
		jcxz	short CLOSESRC	; no more to read
		cmp	[ds:SRCISDEV], 0
		jnz	short NOTESTA	; is a device, ascii mode
		cmp	[ds:ASCII], 0
		jz	short BINREAD

NOTESTA:				; ...
		mov	dx, cx
		mov	di, [ds:NXTADD]
		mov	al, 1Ah
		push	es
		mov	es, [ds:TPA]	; scan for EOF
		repne scasb
		pop	es
		jnz	short USEALL
		inc	[ds:IFNOTFLAG]	; inc byte [RDEOF]
		inc	cx

USEALL:					; ...
		sub	dx, cx
		mov	cx, dx

BINREAD:				; ...
		add	cx, [ds:NXTADD]
		mov	[ds:NXTADD], cx
		cmp	cx, [ds:BYTCNT]
		jb	short TESTDEV
		call	FlshFil
		cmp	[ds:TERMREAD], 0
		jnz	short CLOSESRC
		jmp	short COPYLP
; ---------------------------------------------------------------------------

TESTDEV:				; ...
		cmp	[ds:SRCISDEV], 0 ; if file then	EOF
		jz	short CLOSESRC
		cmp	[ds:IFNOTFLAG],	0 ; cmp	byte [RDEOF],0
		jz	short COPYLP	; on device, go	till ^Z
endp		DOCOPY


; =============== S U B	R O U T	I N E =======================================


proc		CLOSESRC near		; ...
		mov	bx, [ds:SRCHAND]
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle

CLOSESRCDEST_RETN:			; ...
		retn
endp		CLOSESRC


; =============== S U B	R O U T	I N E =======================================


proc		CLOSEDEST near		; ...

; FUNCTION CHUNK AT 43C4 SIZE 00000012 BYTES

		cmp	[ds:SPECDRV], 0	; cmp byte [DestClosed],0
		jnz	short CLOSESRCDEST_RETN
		mov	al, [byte ptr ds:DestSwitch]
		call	SETASC		; check	for b or a switch on destination
		jz	short BINCLOS
		mov	bx, [ds:NXTADD]
		call	TRYFLUSH
		jz	short NOCONC

CONCHNG:				; ...
		stc
		retn
; ---------------------------------------------------------------------------

NOCONC:					; ...
		xor	bx, bx
		push	ds
		mov	ds, [ds:TPA]
		mov	[word ptr bx], 1Ah ; add EOF mark (ctrl-Z)
		pop	ds
		inc	[ds:NXTADD]	; inc word [NXTADD] ; make sure	our ^z gets written
		mov	[ds:NOWRITE], 0	; byte
		mov	ax, [ds:WRITTEN]
		add	ax, [ds:NXTADD]
		jb	short BINCLOS	; > 1
		cmp	ax, 1
		jz	short FORGETITJ	; Written = 0 NxtAdd = 1 (the ^Z)

BINCLOS:				; ...
		call	TRYFLUSH
		jnz	short CONCHNG
		cmp	[ds:WRITTEN], 0

FORGETITJ:				; ...
		jnz	short NO_FORGET	; wrote	something
		jmp	FORGETIT	; never	wrote nothing
; ---------------------------------------------------------------------------

NO_FORGET:				; ...
		mov	bx, [ds:EndDestBuf] ; [DESTHAND]
		mov	cx, [ds:CPTIME]
		mov	dx, [ds:CPDATE]
		cmp	[ds:INEXACT], 0	; copy not exact?
		jz	short DODCLOSE	; if no, copy date & time
		mov	ah, 2Ch
		int	21h		; DOS -	GET CURRENT TIME
					; Return: CH = hours, CL = minutes, DH = seconds
					; DL = hundredths of seconds
		shl	cl, 1
		shl	cl, 1		; left justify min in cl
		shl	cx, 1
		shl	cx, 1
		shl	cx, 1		; hours	to high	5 bits,	min to 5-10
		shr	dh, 1		; divide seconds by 2 (now 5 bits)
		or	cl, dh		; and stick into low 5 bits of cx
		push	cx
		mov	ah, 2Ah
		int	21h		; DOS -	GET CURRENT DATE
					; Return: DL = day, DH = month,	CX = year
					; AL = day of the week (0=Sunday, 1=Monday, etc.)
		sub	cx, 1980
		xchg	ch, cl
		shl	cx, 1		; year to high 7 bits
		shl	dh, 1		; month	to high	3 bits
		shl	dh, 1
		shl	dh, 1
		shl	dh, 1
		shl	dh, 1		; most sig bit of month	in carry
		adc	ch, 0		; put that bit next to year
		or	dl, dh		; or low three of month	into day
		mov	dh, ch		; get year and high bit	of month
		pop	cx
endp		CLOSEDEST


; =============== S U B	R O U T	I N E =======================================


proc		DODCLOSE near		; ...
		cmp	bx, 0
		jle	short CLOSEDONE
		mov	ax, 5701h
		int	21h		; DOS -	2+ - SET FILE'S DATE/TIME
					; BX = file handle, CX = time to be set
					; DX = date to be set
		jb	short Cleanup_Err
		mov	ax, 4202h	; (LSEEK<<8)+2 ; seek to EOF
		xor	dx, dx		; 0
		mov	cx, dx
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from end of file
		or	dx, ax		; DX:AX	is file	size
		pushf
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		push	dx
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		pop	dx
		jnb	short Close_Cont
		popf

Cleanup_Err:				; ...
		call	CleanUpErr
		call	DestDelete
		jmp	short FILECLOSED
; ---------------------------------------------------------------------------

Close_Cont:				; ...
		popf
		jnz	short CLOSEDONE
		test	dx, 80h		; is the destination a device?
		jnz	short CLOSEDONE	; yes, copy succeeded
		call	DestDelete
		jmp	short FILECLOSED
; ---------------------------------------------------------------------------

CLOSEDONE:				; ...
		inc	[ds:FileCnt]	; inc word [FileCnt]

FILECLOSED:				; ...
		inc	[ds:SPECDRV]	; inc byte [DestClosed]

RET50:					; ...
		clc
		retn
endp		DODCLOSE

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR CLOSEDEST

FORGETIT:				; ...
		mov	bx, [ds:EndDestBuf] ; [DESTHAND]
		call	DODCLOSE	; close	the dest
		call	DestDelete
		mov	[ds:FileCnt], 0	; no files transferred
		jmp	short RET50
; END OF FUNCTION CHUNK	FOR CLOSEDEST

; =============== S U B	R O U T	I N E =======================================


proc		DestDelete near		; ...
		cmp	[ds:notzerofile], 1 ; destination file size > 0
		jz	short RET50	; yes, do not delete
		mov	dx, offset DestBuf
		mov	ah, 41h		; Unlink
		int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
					; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
		retn
endp		DestDelete


; =============== S U B	R O U T	I N E =======================================


proc		SOURCE_SET near		; ...
		push	si
		mov	ax, [ds:STARTEL]
		mov	si, offset ScanBuf ; adjust to copy
		sub	ax, si
		mov	di, offset SrcBuf
		add	ax, di
		mov	[ds:SrcTail], ax
		mov	[ds:SrcSiz], cl
		inc	cx
		rep movsb
		mov	[ds:SrcInfo], bh
		pop	si
		mov	ax, bp
		call	SETASC		; set a,b switches accordingly
		call	SWITCH		; get any more switches	on this	arg
		call	SETASC
		retn
endp		SOURCE_SET


; =============== S U B	R O U T	I N E =======================================


proc		CleanUpErr near		; ...
		cmp	[ds:msg_flag], 0 ; have	we already issued a message?
		jnz	short CleanupErr_Cont ;	yes - don't issue duplicate error
		call	Set_Ext_Error_Msg
		mov	[ds:string_ptr_2], offset DestBuf
		mov	[ds:extend_buf_sub], 1 ; one_subst
		call	std_eprintf

CleanupErr_Cont:			; ...
		retn
endp		CleanUpErr


; =============== S U B	R O U T	I N E =======================================


proc		get_answer_YNA near	; ...
		mov	[ds:cox_dest_file], 0
		mov	ax, 4300h
		mov	dx, offset DestBuf
		int	21h		; DOS -	2+ - GET FILE ATTRIBUTES
					; DS:DX	-> ASCIZ file name or directory
					; name without trailing	slash
		jnb	short getansw_1
		jmp	getansw_5
; ---------------------------------------------------------------------------

getansw_1:				; ...
		inc	[ds:cox_dest_file] ; byte ; valid destination file
		lea	si, [cox_sublist_buff]
		mov	[word ptr si], 11 ; sublist size, 11 bytes
		mov	[word ptr si+2], offset	DestBuf	; sublist value	(pointer)
		mov	[word ptr si+4], ds ; sublist segment
		mov	[byte ptr si+6], 1 ; sub id (N of %N)
		mov	[byte ptr si+7], 10h ; data type flags ; ASCII
		mov	[byte ptr si+8], 0 ; maximum length (chars)
		mov	[byte ptr si+9], 0 ; minimum length (chars)
		mov	[byte ptr si+0Ah], 0 ; pad field character (0)
		lea	si, [cox_sublist_buff]
		mov	ax, 1103	; message number
					; 'Overwrite %1 (Yes/No/All)?'
		mov	bx, 2		; std error (file handle = 2)
		mov	cx, 1		; byte count
		mov	dh, 0FFh	; message class	(utility)
		xor	dl, dl		; control flag = 0
		call	SYSDISPMSG
		xor	bx, bx

getansw_2:				; ...
		mov	ax, 0C08h
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		cmp	al, 0
		jz	short getansw_2
		cmp	al, 0Dh
		jz	short getansw_4
		mov	bl, al
		mov	dl, al
		mov	ax, 6520h
		int	21h		; DOS -	4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
					; AL = function	-
		cmp	dl, [ds:_Y_es]	; 'Y'
		jz	short getansw_3
		cmp	dl, [ds:_N_o]	; 'N'
		jz	short getansw_3
		cmp	dl, [ds:_A_ll]	; 'A'
		jnz	short getansw_2

getansw_3:				; ...
		mov	bh, bl
		push	bx
		mov	[ds:MSG_1104], bl
		mov	ah, 40h
		mov	bx, 2		; std error (file handle = 2)
		mov	cx, 1		; byte count
		mov	dx, offset MSG_1104
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		mov	ah, 40h
		mov	[ds:MSG_1104], 8
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		pop	bx
		jmp	short getansw_2
; ---------------------------------------------------------------------------

getansw_4:				; ...
		cmp	bh, 0
		jz	short getansw_2
		mov	dl, bh
		mov	ax, 6520h
		int	21h		; DOS -	4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
					; AL = function	-
		push	dx
		mov	ax, 1070	; message number
		mov	bx, 2		; std error (file handle = 2)
		xor	cx, cx
		mov	dh, 0FFh	; message class	(utility)
		xor	dl, dl
		call	SYSDISPMSG
		pop	dx
		cmp	dl, [ds:_Y_es]
		jz	short getansw_5
		cmp	dl, [ds:_N_o]
		jz	short getansw_6
		mov	[ds:cox_y_override], 0

getansw_5:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

getansw_6:				; ...
		stc
		retn
endp		get_answer_YNA


; =============== S U B	R O U T	I N E =======================================


proc		init_copycmd_option near ; ...
		mov	[ds:cox_y_override], 1 ; suppress copy overwrite confirmation
		push	es
		mov	es, [ds:RESSEG]
		cmp	[byte ptr es:cox_location], 'c' ; "cox"
		jnz	short icpcmd_1
		mov	es, [es:EnvirSeg]
		lea	si, [copycmd]	; "COPYCMD="
		mov	cx, 8
		call	getenv_copycmd
		jb	short icpcmd_3
		call	get_copycmd_option ; copycmd=/Y	or copycmd=/-Y
		jb	short icpcmd_2
		inc	di		; skip '/'
		mov	al, [es:di]
		and	al, 0DFh	; convert to uppercase
		cmp	al, 'Y'
		jnz	short icpcmd_2

icpcmd_1:				; ...
		mov	[ds:cox_y_override], 0 ; clear copy overwrite question/confirmation
					; (don't suppress)

icpcmd_2:				; ...
		pop	es
		retn
; ---------------------------------------------------------------------------

icpcmd_3:				; ...
		mov	es, [ds:RESSEG]
		cmp	[es:cox_Y_option], 0 ; default (/Y) switch option (1 = enabled)
		jz	short icpcmd_2
		jmp	short icpcmd_1
endp		init_copycmd_option


; =============== S U B	R O U T	I N E =======================================


proc		get_copycmd_option near	; ...
		cmp	[byte ptr es:di], 0
		jz	short gcpcmdo_2
		cmp	[byte ptr es:di], 2Fh ;	'/'
		jz	short gcpcmdo_1
		inc	di
		jmp	short get_copycmd_option
; ---------------------------------------------------------------------------

gcpcmdo_1:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

gcpcmdo_2:				; ...
		stc
		retn
endp		get_copycmd_option


; =============== S U B	R O U T	I N E =======================================


proc		getenv_copycmd near	; ...
		xor	di, di
		xor	al, al

gecpcmd_1:				; ...
		cmp	[byte ptr es:di], 0
		jz	short gecpcmd_3
		push	cx
		push	si
		repe cmpsb
		pop	si
		pop	cx
		jz	short gecpcmd_2	; cf = 0
		push	cx
		mov	cx, 32768
		repne scasb		; al = 0
		pop	cx
		jmp	short gecpcmd_1
; ---------------------------------------------------------------------------

gecpcmd_2:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

gecpcmd_3:				; ...
		stc
		retn
endp		getenv_copycmd


; =============== S U B	R O U T	I N E =======================================


proc		TRYFLUSH near		; ...
		mov	al, [ds:PARM1]	; mov al,[Concat]
		push	ax
		call	FlshFil
		pop	ax
		cmp	al, [ds:PARM1]	; cmp al,[Concat]
		retn
endp		TRYFLUSH


; =============== S U B	R O U T	I N E =======================================


proc		FlshFil	near		; ...
		mov	[ds:TERMREAD], 0
		cmp	[ds:CFLAG], 0
		jz	short NotExists
		jmp	Exists
; ---------------------------------------------------------------------------

NotExists:				; ...
		call	BUILDDEST	; find out all about the destination
		call	COMPNAME	; source and dest. the same?
		jnz	short ProcDest	; if not, go ahead
		cmp	[ds:SRCISDEV], 0
		jnz	short ProcDest	; same name on device ok
		cmp	[ds:PARM1], 0	; cmp byte [Concat],0
		mov	dx, offset OVERWR_PTR
		jnz	short No_Concat_Err
		jmp	COPYERR		; not concatenating - overwrite	error
; ---------------------------------------------------------------------------

No_Concat_Err:				; ...
		mov	[ds:NOWRITE], 1	; flag not writing (just seeking)

ProcDest:				; ...
		mov	ax, 6C00h
		mov	si, offset DestBuf
		mov	bx, 21h		; get open mode	for copy
		xor	cx, cx
		mov	dx, 101h	; write_open_flag
		cmp	[ds:NOWRITE], 0
		jnz	short DoDestOpen ; don't actually create if nowrite set
		mov	dx, 112h	; creat_open_flag

DoDestOpen:				; ...
		int	21h		; DOS -	4.0 - EXTENDED OPEN/CREATE
					; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
					; BH = flags, CX = create attribute, DL	= action if file exists/does not exists
					; DH = 00h (reserved), DS:SI ->	ASCIZ file name
		jnb	short Dest_Open_Okay

Xa_Set_Error:				; ...
		call	Set_Ext_Error_Msg
		mov	[ds:string_ptr_2], offset DestBuf
		mov	[ds:extend_buf_sub], 1 ; one_subst
		jmp	COPYERR
; ---------------------------------------------------------------------------

Dest_Open_Okay:				; ...
		mov	[ds:EndDestBuf], ax ; mov [DESTHAND],ax	; save handle
		mov	[ds:CFLAG], 1	; destination now exists
		mov	bx, ax
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		mov	[ds:DESTISDEV],	dl ; set dest info
		test	dl, 80h
		jz	short Exists	; Dest not a device
		mov	al, [byte ptr ds:DestSwitch]
		and	al, 0Ch		; SWITCHA+SWITCHB ; 4+8
		jnz	short TestBoth
		mov	al, [ds:ASCII]	; neither set, use current setting
		or	al, [ds:BINARY]
		jz	short ExSetA	; neither set, default to ascii

TestBoth:				; ...
		jp	short Exists	; jpe ;	both are set, ignore
		test	al, 8
		jz	short Exists
		mov	ax, 4401h	; (IOCTL<<8)|1
		xor	dh, dh
		or	dl, 20h		; devid_RAW
		mov	[ds:DESTISDEV],	dl
		int	21h		; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
					; BX = device handle, DH = 0
					; DL = device information to set (bits 0-7 from	function 0)
		jmp	short Exists
; ---------------------------------------------------------------------------

ExSetA:					; ...
		mov	[ds:ASCII], 4	; SWITCHA ; set	ascii mode
		or	[ds:INEXACT], 4	; ascii	-> inexact

Exists:					; ...
		cmp	[ds:NOWRITE], 0
		jnz	short NoChecking ; if nowrite don't bother with name check
		cmp	[ds:plus_comma], 1 ; don't check if just doing +,,
		jz	short NoChecking
		call	COMPNAME	; source and dest. the same?
		jnz	short NoChecking ; if not, go ahead
		cmp	[ds:SRCISDEV], 0
		jnz	short NoChecking ; same	name on	device ok
		mov	dx, offset LOSTERR_PTR ; tell him he's not going to get it
		call	std_eprintf
		mov	[ds:NXTADD], 0	; word
		inc	[ds:TERMREAD]	; byte

Ret60:					; ...
		retn
; ---------------------------------------------------------------------------

NoChecking:				; ...
		mov	bx, [ds:EndDestBuf] ; [DESTHAND]
		xor	cx, cx		; 0
		xchg	cx, [ds:NXTADD]
		jcxz	short Ret60	; if nothing to	write, forget it
		inc	[ds:WRITTEN]	; word ; flag that we wrote something
		cmp	[ds:NOWRITE], 0	; if nowrite set, just seek cx bytes
		jnz	short SeekEnd
		xor	dx, dx
		push	ds
		mov	ds, [ds:TPA]
		mov	ah, 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		pop	ds
		mov	dx, offset NOSPACE_PTR
		jnb	short NoChecking2

Xa_Set_Error_Jmp:			; ...
		jmp	Xa_Set_Error	; failure
; ---------------------------------------------------------------------------

NoChecking2:				; ...
		sub	cx, ax
		jz	short Ret60
		test	[ds:DESTISDEV],	80h ; devid_ISDEV
		jz	short COPYERR	; is a file, error
		test	[ds:DESTISDEV],	20h ; devid_RAW
		jnz	short DevWrtErr	; is a raw device, error
		cmp	[ds:INEXACT], 0
		jnz	short Ret60	; inexact so ok
		dec	cx
		jz	short Ret60	; wrote	one byte less (the ^z)

DevWrtErr:				; ...
		mov	dx, offset DEVWMES_PTR
		jmp	short COPYERR
; ---------------------------------------------------------------------------

SeekEnd:				; ...
		xor	dx, dx
		xchg	dx, cx		; cx = 0
					; cx:dx	= (signed) offset from origin of new file position
		mov	ax, 4201h	; (LSEEK<<8)|1
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from present location
		mov	[ds:notzerofile], 1 ; (existing) destination file size is not zero
		test	ax, ax
		jnz	short SeekEnd_@
		test	dx, dx
		jnz	short SeekEnd_@
		mov	[ds:notzerofile], 0 ; (existing) destination file size is zero

SeekEnd_@:				; ...
		mov	[ds:OFilePtr_Lo], ax
		mov	[ds:OFilePtr_Hi], dx
		cmp	[ds:IFNOTFLAG],	0 ; cmp	byte [RDEOF],0
		jz	short Ret60
		mov	ah, 40h		; cx = 0 ; file	is truncated to	the current position
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		jb	short Xa_Set_Error_Jmp
		mov	[ds:zflag], 1Ah	; mov byte [OCtrlZ],1Ah
		retn
; ---------------------------------------------------------------------------

COPYERR:				; ...
		call	std_eprintf
		inc	[ds:SPECDRV]	; inc byte [DestClosed]
		cmp	[ds:CFLAG], 0
		jz	short EndCopyJ	; never	actually got it	open
		mov	bx, [ds:EndDestBuf] ; [DESTHAND]
		cmp	bx, 0
		jle	short NoClose
		mov	cx, [ds:OFilePtr_Hi] ; CX = hi word of original	file ptr
		mov	dx, [ds:OFilePtr_Lo] ; DX = lo word of original	file ptr
		mov	ax, cx
		or	ax, dx
		jz	short ceClose	; null file ptr	means nothing to save
		mov	ax, 4200h
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		xor	cx, cx		; 0
		mov	ah, 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		cmp	[ds:zflag], 0	; cmp byte [OCtrlZ],0
		jz	short ceClose0
		inc	cx		; 1
		mov	dx, offset zflag ; offset OCtrlZ
		mov	ah, 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer

ceClose0:				; ...
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		jmp	short EndCopyJ
; ---------------------------------------------------------------------------

ceClose:				; ...
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle

NoClose:				; ...
		mov	dx, offset DestBuf
		mov	ah, 41h
		int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
					; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
		mov	[ds:CFLAG], 0

EndCopyJ:				; ...
		jmp	ENDCOPY
endp		FlshFil


; =============== S U B	R O U T	I N E =======================================


proc		SETASC near		; ...
		and	al, 0Ch		; SWITCHA+SWITCHB ; AL = /a, /b	flags
		jp	short LOADSW	; jpe ;	even parity - both or neither
		push	ax
		and	al, 8		; SWITCHB
		mov	[ds:BINARY], al
		pop	ax
		and	al, 4		; SWITCHA
		mov	[ds:ASCII], al
		or	[ds:INEXACT], al

LOADSW:					; ...
		mov	al, [ds:ASCII]
		or	al, al
		retn
endp		SETASC


; =============== S U B	R O U T	I N E =======================================


proc		BUILDDEST near		; ...
		cmp	[ds:DestIsDir],	0FFh ; -1
		jnz	short KNOWABOUTDEST
		mov	di, offset USERDIR1
		mov	bp, offset DestIsDir ; offset DestVars
		mov	bx, 41h		; deny_none|write_open_mode
		call	BUILDPATH
		call	RestUDir1

KNOWABOUTDEST:				; ...
		xor	al, al
		xchg	al, [ds:FIRSTDEST]
		or	al, al
		jnz	short FIRSTDST
		jmp	NOFIRSTDEST
; ---------------------------------------------------------------------------

FIRSTDST:				; ...
		mov	si, [ds:DestTail]
		mov	di, offset DESTDIR ; offset DestFcb
		mov	ax, 2900h	; Parse_File_Descriptor*256
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		cmp	[byte ptr si], 0
		jz	short GOODPARSE
		mov	dx, offset FULLDIR_PTR ; issue "file creation error"
		jmp	COPYERR
; ---------------------------------------------------------------------------

GOODPARSE:				; ...
		mov	ax, [word ptr ds:DestBuf] ; AX = possible "d:"
		cmp	ah, ':'
		jz	short DRVSPEC4
		mov	al, 40h	; '@'

DRVSPEC4:				; ...
		mov	cl, [ds:ASCII]	; CL = saved Ascii flag
		or	al, 20h
		sub	al, 60h
		mov	[ds:DESTDIR], al ; [DestFcb] ; store drive # in	FCB
		mov	al, [ds:DestInfo] ; AL = destination CParse flags
		mov	ah, [ds:SrcInfo] ; AH =	source CParse flags
		and	ax, 202h
		or	al, al
		jz	short NOTMELCOPY
		cmp	al, ah
		jnz	short NOTMELCOPY
		cmp	[ds:PLUS], 0	; Destination is wildcarded.
		jz	short NOTMELCOPY ; no +'s in source
		inc	[ds:MELCOPY]	; byte ; 'Mel copy' = true
		xor	al, al
		jmp	short SETCONC
; ---------------------------------------------------------------------------

NOTMELCOPY:				; ...
		xor	al, 2		; AL=0 -> ambiguous destination, 2 otherwise
		and	al, ah
		shr	al, 1		; AL=1 -> ambiguous source, unambiguous	dest
					; (implies concatenation)

SETCONC:				; ...
		or	al, [ds:PLUS]	; "+" always infers concatenation
		mov	[ds:PARM1], al	; mov [Concat],al ; AL = 1 if concatenating, 0 if not.
		shl	al, 1
		shl	al, 1
		mov	[ds:INEXACT], al ; concatenation -> inexact copy
		cmp	[ds:BINARY], 0
		jnz	short NOFIRSTDEST ; explicit binary copy
		mov	[ds:ASCII], al
		or	cl, cl
		jnz	short NOFIRSTDEST ; Ascii flag set before, data	read correctly
		or	al, al
		jz	short NOFIRSTDEST ; Ascii flag did not change state
		mov	cx, [ds:NXTADD]
		jcxz	short NOFIRSTDEST ; no data, everything	ok
		mov	al, 1Ah
		push	es
		xor	di, di
		mov	es, [ds:TPA]
		repne scasb		; scan for EOF
		pop	es
		jnz	short NOFIRSTDEST ; no ^z in buffer, everything	ok
		dec	di		; point	at ^z
		mov	[ds:NXTADD], di	; new buffer length

NOFIRSTDEST:				; ...
		mov	bx, (offset BWDBUF+1) ;	offset DIRBUF+1
		cmp	[ds:PARM1], 0	; cmp byte [Concat],0
		jz	short GOTCHRSRC	; Not a	concat
		mov	bx, (offset SDIRBUF+1) ; Source	of replacement chars

GOTCHRSRC:				; ...
		mov	si, (offset DESTDIR+1) ; offset	DestFcb+1
		mov	di, [ds:DestTail]
endp		BUILDDEST


; =============== S U B	R O U T	I N E =======================================


proc		BUILDNAME near		; ...
		mov	cx, 8

BUILDMAIN:				; ...
		lodsb
		cmp	al, 3Fh	; '?'
		jnz	short NOTAMBIG
		mov	al, [bx]

NOTAMBIG:				; ...
		cmp	al, 20h	; ' '
		jz	short NOSTORE
		stosb

NOSTORE:				; ...
		inc	bx
		loop	BUILDMAIN
		mov	cl, 3
		mov	al, 20h	; ' '
		cmp	[si], al
		jz	short ENDDEST	; No extension
		mov	al, 2Eh	; '.'
		stosb

BUILDEXT:				; ...
		lodsb
		cmp	al, 3Fh	; '?'
		jnz	short NOTAMBIGE
		mov	al, [bx]

NOTAMBIGE:				; ...
		cmp	al, 20h	; ' '
		jz	short NOSTOREE
		stosb

NOSTOREE:				; ...
		inc	bx
		loop	BUILDEXT

ENDDEST:				; ...
		xor	al, al
		stosb			; NUL terminate
		retn
endp		BUILDNAME


; =============== S U B	R O U T	I N E =======================================


proc		BUILDPATH near		; ...

; FUNCTION CHUNK AT 1E50 SIZE 00000011 BYTES

		test	[byte ptr bp+4], 2 ; [bp+VARSTRUC.INFO]
		jnz	short NOTPFILE
		mov	dx, bp
		add	dx, 5		; VARSTRUC.BUF
		push	di
		mov	ax, 6C00h	; (ExtOpen<<8)
		xor	cx, cx
		mov	si, dx
		mov	dx, 101h
		int	21h		; DOS -	4.0 - EXTENDED OPEN/CREATE
					; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
					; BH = flags, CX = create attribute, DL	= action if file exists/does not exists
					; DH = 00h (reserved), DS:SI ->	ASCIZ file name
		pop	di
		jnb	short PURE_FILE
		call	get_ext_error_number
		cmp	ax, 2		; ERROR_FILE_NOT_FOUND
		jz	short NOTPFILE
		cmp	ax, 3		; ERROR_PATH_NOT_FOUND
		jz	short NOTPFILE
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		jz	short NOTPFILE
		jmp	extend_setup
; ---------------------------------------------------------------------------

PURE_FILE:				; ...
		mov	bx, ax
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		test	dl, 80h		; devid_ISDEV
		jnz	short ISADEV
		test	[byte ptr bp+4], 4 ; [bp+VARSTRUC.INFO]
		jz	short ISADEV

NOTPFILE:				; ...
		mov	dx, [bp+5]	; [bp+VARSTRUC.BUF]
		cmp	dl, 0		; If no	drive specified, get default drive dir
		jz	short SET_DRIVE_SPEC
		cmp	dh, ':'
		jz	short DRVSPEC5

SET_DRIVE_SPEC:				; ...
		mov	dl, 40h	; '@'

DRVSPEC5:				; ...
		or	dl, 20h
		sub	dl, 60h
		call	SAVUDIR1
		jnb	short CURDIR_OK
		call	get_ext_error_number
		jmp	extend_setup
; ---------------------------------------------------------------------------

CURDIR_OK:				; ...
		mov	dx, bp
		add	dx, 5		; VARSTRUC.BUF ; Set DX	for upcomming CHDIRs
		mov	bh, [bp+4]	; [bp+VARSTRUC.INFO]
		and	bh, 6
		cmp	bh, 6		; Ambig	and path ?
		jnz	short CHECKAMB	; jmp if no
		mov	si, [bp+2]	; [bp+VARSTRUC.TTAIL]
		mov	bl, ':'
		cmp	[si-2],	bl
		jnz	short KNOWNOTSPEC
		mov	[byte ptr bp+0], 2 ; [bp+VARSTRUC.ISDIR],2 ; Know is d:/file
		jmp	short DOPCDJ
; ---------------------------------------------------------------------------

KNOWNOTSPEC:				; ...
		mov	[byte ptr bp+0], 1 ; [bp+VARSTRUC.ISDIR],1 ; Know is path/file
		dec	si

DOPCDJ:					; ...
		jmp	DOPCD
; ---------------------------------------------------------------------------

CHECKAMB:				; ...
		cmp	bh, 2
		jnz	short CHECKCD

ISADEV:					; ...
		mov	[byte ptr bp+0], 0 ; [bp+VARSTRUC.ISDIR]
		retn
; ---------------------------------------------------------------------------

CHECKCD:				; ...
		call	SetRest1
		mov	ah, 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		jb	short NOTPDIR
		mov	di, dx
		xor	ax, ax
		mov	cx, ax
		dec	cx

Kloop:					; ...
		mov	al, [es:di]
		inc	di
		or	al, al
		jz	short DONE
		xor	ah, ah
		call	testkanj
		jz	short Kloop
		inc	di
		inc	ah
		jmp	short Kloop
; ---------------------------------------------------------------------------

DONE:					; ...
		dec	di
		mov	al, [ds:DIRCHAR]
		mov	[byte ptr bp+0], 2 ; [bp+VARSTRUC.ISDIR],2 ; assume d:/file
		or	ah, ah
		jnz	short _STORE_PCHAR ; his is the	trailing byte of ECS code
		cmp	al, [di-1]
		jz	short GOTSRCSLSH

_STORE_PCHAR:				; ...
		stosb
		mov	[byte ptr bp+0], 1 ; [bp+VARSTRUC.ISDIR],1 ; know path/file

GOTSRCSLSH:				; ...
		or	[byte ptr bp+4], 6 ; [bp+VARSTRUC.INFO]
		call	SETSTARS

NOTPDIR_RETN:				; ...
		retn
; ---------------------------------------------------------------------------

NOTPDIR:				; ...
		call	get_ext_error_number
		cmp	ax, 3		; ERROR_PATH_NOT_FOUND
		jz	short NOTPDIR_TRY
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		jnz	short EXTEND_SETUPJ

NOTPDIR_TRY:				; ...
		mov	[byte ptr bp+0], 0 ; [bp+VARSTRUC.ISDIR]
		mov	bh, [bp+4]	; [bp+VARSTRUC.INFO]
		test	bh, 4
		jz	short NOTPDIR_RETN ; Know pure file, no	path seps
		mov	[byte ptr bp+0], 2 ; [bp+VARSTRUC.ISDIR],2 ; assume d:/file
		mov	si, [bp+2]	; [bp+VARSTRUC.TTAIL]
		cmp	[byte ptr si], 0
		jz	short BADCDERRJ2 ; Trailing '/'
		mov	bl, 2Eh	; '.'
		cmp	[si], bl
		jz	short BADCDERRJ2 ; If .	or .. pure cd should have worked
		mov	bl, 3Ah	; ':'
		cmp	[si-2],	bl
		jz	short DOPCD	; Know d:/file
		mov	[byte ptr bp+0], 1 ; [bp+VARSTRUC.ISDIR],1 ; Know path/file
		dec	si		; Point	at last	'/'

DOPCD:					; ...
		xor	bl, bl
		xchg	bl, [si]	; Stick	in a NUL
		call	SetRest1
		cmp	dx, si
		jnb	short LookBack
		push	si
		push	cx
		mov	cx, si
		mov	si, dx

Kloop2:					; ...
		lodsb
		call	testkanj
		jz	short NotKanj4
		lodsb
		cmp	si, cx
		jb	short Kloop2
		pop	cx
		pop	si
		jmp	short DoCdr	; Last char is ECS code,
					; don't check for trailing path sep
; ---------------------------------------------------------------------------

NotKanj4:				; ...
		cmp	si, cx
		jb	short Kloop2
		pop	cx
		pop	si

LookBack:				; ...
		cmp	bl, [si-1]	; if double slash, then	complain
		jz	short BADCDERRJ2

DoCdr:					; ...
		mov	ah, 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		xchg	bl, [si]
		jnb	short NOTPDIR_RETN
		call	get_ext_error_number

EXTEND_SETUPJ:				; ...
		jmp	extend_setup
; ---------------------------------------------------------------------------

BADCDERRJ2:				; ...
		jmp	badpath_err
endp		BUILDPATH


; =============== S U B	R O U T	I N E =======================================


proc		SETSTARS near		; ...
		mov	[bp+2],	di	; [bp+VARSTRUC.TTAIL]
		add	[byte ptr bp+1], 12 ; [bp+VARSTRUC.SIZ]
		mov	ax, 2E3Fh	; DOT_QMARK ; '?.' (NASM syntax)
		mov	cx, 8
		rep stosb
		xchg	al, ah
		stosb
		xchg	al, ah
		mov	cl, 3
		rep stosb
		xor	al, al
		stosb
		retn
endp		SETSTARS


; =============== S U B	R O U T	I N E =======================================


proc		COMPNAME near		; ...
		mov	si, offset DestBuf
		mov	di, offset TRGXNAME
		mov	ax, 6000h	; (xNameTrans*256)
		int	21h		; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
					; DS:SI	-> ASCIZ relative path string or directory name
					; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
		mov	si, offset SRCXNAME
		mov	di, offset TRGXNAME
		call	STRCOMP
		retn
endp		COMPNAME


; =============== S U B	R O U T	I N E =======================================


proc		cparse near		; ...
		xor	ax, ax		; DS:SI	  Points input buffer
					; ES:DI	  Points to the	token buffer
					; BL  Special delimiter	for this call
		mov	[ds:STARTEL], di ; No path element
		mov	[ds:ELPOS], al	; Start	in 8 char prefix
		mov	[ds:SKPDEL], al	; No skip delimiter yet
		mov	bh, al		; Init nothing
		pushf
		push	di
		xor	cx, cx
		mov	[ds:comma], cl	; reset	comma flag

moredelim:				; ...
		lodsb
		call	DELIM
		jnz	short SCANCDONE
		cmp	al, 20h	; ' '
		jz	short moredelim
		cmp	al, 9
		jz	short moredelim
		xchg	al, [ds:SKPDEL]
		or	al, al
		jz	short moredelim	; One non space/tab delimiter allowed
		test	bh, 80h		; has a	special	char been found?
		jz	short no_comma	; no - just exit
		mov	[ds:comma], 1	; set comma flag

no_comma:				; ...
		jmp	x_done
; ---------------------------------------------------------------------------

SCANCDONE:				; ...
		cmp	al, bl		; Special delimiter?
		jnz	short nospec
		or	bh, 80h
		jmp	short moredelim
; ---------------------------------------------------------------------------

nospec:					; ...
		cmp	al, 0Dh		; a CR?
		jnz	short ncperror
		jmp	cperror
; ---------------------------------------------------------------------------

ncperror:				; ...
		cmp	al, [ds:SWITCHAR] ; is the char	the switch char?
		jnz	short na_switch
		jmp	a_switch	; yes, process...
; ---------------------------------------------------------------------------

na_switch:				; ...
		mov	dl, ':'
		cmp	[si], dl
		jnz	short anum_chard ; Drive not specified
		cmp	[ds:cpyflag], 1
		jnz	short cpcont2
		call	UPCONV

cpcont2:				; ...
		call	move_char
		lodsb			; Get the ':'
		call	move_char
		mov	[ds:STARTEL], di
		mov	[ds:ELCNT], 0
		jmp	anum_test
; ---------------------------------------------------------------------------

anum_chard:				; ...
		mov	[ds:STARTEL], di
		mov	[ds:ELCNT], 0	; Store	of this	char sets it to	one
		cmp	[ds:cpyflag], 1	; Was CPARSE called from COPY?
		jnz	short anum_char	; No, don't add drive spec.
		call	pathchrcmp	; Starts with a	pathchar?
		jnz	short anum_char	; no
		push	ax
		mov	al, [ds:CURDRV]	; Insert drive spec
		add	al, 41h	; 'A'
		call	move_char
		mov	al, 3Ah	; ':'
		call	move_char
		pop	ax
		mov	[ds:STARTEL], di
		mov	[ds:ELCNT], 0	; byte

anum_char:				; ...
		call	testkanj
		jz	short NOTKANJ
		call	move_char
		lodsb
		jmp	short notspecial
; ---------------------------------------------------------------------------

NOTKANJ:				; ...
		cmp	[ds:cpyflag], 1	; and if we're in COPY
		jnz	short TESTDOT
		call	UPCONV		; upper	case the char

TESTDOT:				; ...
		cmp	al, 2Eh	; '.'
		jnz	short testquest
		inc	[ds:ELPOS]	; byte ; flag in extension
		mov	[ds:ELCNT], 0FFh ; Store of the	'.' resets it to 0

testquest:				; ...
		cmp	al, 3Fh	; '?'
		jnz	short testsplat
		or	bh, 2

testsplat:				; ...
		cmp	al, 2Ah	; '*'
		jnz	short testpath
		or	bh, 2
		cmp	[ds:expand_star], 0
		jnz	short expand_filename
		jmp	short testpath
; ---------------------------------------------------------------------------

BADPERR2J:				; ...
		jmp	short BADPERR2
; ---------------------------------------------------------------------------

expand_filename:			; ...
		mov	ah, 7
		cmp	[ds:ELPOS], 0
		jz	short gotelcnt
		mov	ah, 2

gotelcnt:				; ...
		mov	al, 3Fh	; '?'
		sub	ah, [ds:ELCNT]
		jb	short BADPERR2J
		xchg	ah, cl
		jcxz	short testpathx

qmove:					; ...
		xchg	ah, cl
		call	move_char
		xchg	ah, cl
		loop	qmove

testpathx:				; ...
		xchg	ah, cl

testpath:				; ...
		call	pathchrcmp
		jnz	short notspecial
		or	bh, 4
		cmp	[ds:expand_star], 0
		jz	short no_err_check
		test	bh, 2		; If just hit a	'/', cannot have ? or * yet
		jnz	short BADPERR

no_err_check:				; ...
		mov	[ds:STARTEL], di ; New element
		inc	[ds:STARTEL]	; word ; Point to char after /
		mov	[ds:ELCNT], 0FFh ; Store of '/' sets it to 0
		mov	[ds:ELPOS], 0	; byte

notspecial:				; ...
		call	move_char	; just an alphanum string

anum_test:				; ...
		lodsb
		call	DELIM
		jz	short x_done
		cmp	al, 0Dh
		jz	short x_done
		cmp	al, [ds:SWITCHAR]
		jz	short x_done
		cmp	al, bl
		jz	short x_done
		cmp	al, ':'         ; ':' allowed as trailer because of devices
		jz	short FOO15
		jmp	anum_char
; ---------------------------------------------------------------------------

FOO15:					; ...
		cmp	[ds:cpyflag], 2
		jnz	short cpcont4
		call	move_char
		jmp	short anum_test
; ---------------------------------------------------------------------------

cpcont4:				; ...
		inc	si		; Skip the ':'
		jmp	short x_done
; ---------------------------------------------------------------------------
		jmp	anum_char
; ---------------------------------------------------------------------------

BADPERR2:				; ...
		mov	dx, offset BADCPMES_PTR	; Issue	"Invalid Directory" message
		jmp	cerror
; ---------------------------------------------------------------------------

BADPERR:				; ...
		mov	dx, offset badcd_ptr
		jmp	cerror
; ---------------------------------------------------------------------------

cperror:				; ...
		dec	si		; adjust the pointer
		pop	di		; retrive token	buffer address
		popf			; restore flags
		stc			; set the carry	bit
		retn
; ---------------------------------------------------------------------------

x_done:					; ...
		dec	si		; adjust for next round
		jmp	short out_token
; ---------------------------------------------------------------------------

a_switch:				; ...
		or	bh, 1		; Indicate switch
		or	bp, 8000h	; FSWITCH
		call	scanoff
		inc	si
		call	testkanj
		jz	short a_switch_notkanj
		call	move_char
		lodsb
		call	move_char
		or	bp, 4000h	; FBADSWITCH
		jmp	short out_token
; ---------------------------------------------------------------------------

a_switch_notkanj:			; ...
		cmp	al, 0Dh
		jnz	short Store_swt
		mov	al, 0
		stosb
		or	bp, 4000h	; FBADSWITCH
		jmp	short cperror	; Trailing switch character error
					; BP = fSwitch but no switch bit is set
					; (unknown switch)
; ---------------------------------------------------------------------------

Store_swt:				; ...
		call	move_char	; store	the character
		call	UPCONV
		push	es
		push	di
		push	cx
		push	cs
		pop	es
		assume es:TRANGROUP
		mov	di, offset switch_list ; "-Y?VBAPW"
		mov	cx, 8		; SWCOUNT = 8
		or	bp, 4000h
		repne scasb
		jnz	short out_tokenp
		and	bp, 0BFFFh	; ~FBADSWITCH
		mov	ax, 1
		shl	ax, cl
		or	bp, ax

out_tokenp:				; ...
		pop	cx
		pop	di
		pop	es
		assume es:nothing

out_token:				; ...
		mov	al, 0
		stosb
		pop	di
		popf
		clc
		retn
endp		cparse


; =============== S U B	R O U T	I N E =======================================


proc		move_char near		; ...
		stosb			; store	char in	token buffer
		inc	cx		; increment char count
		inc	[ds:ELCNT]	; byte ; increment element count for * substi
		retn
endp		move_char


; =============== S U B	R O U T	I N E =======================================


proc		sysparse near		; ...

; FUNCTION CHUNK AT 4C8C SIZE 00000069 BYTES

		mov	[word ptr cs:$P_Flags],	0
		mov	[cs:$P_ORIG_ORD], cx
		mov	[cs:$P_ORIG_STACK], sp
		mov	[cs:$P_ORIG_SI], si

$P_Redo_Time:				; ...
		cld
		mov	[cs:$P_ORDINAL], cx
		mov	[cs:$P_RC], 0	; word ; $P_No_Error
		mov	[cs:$P_Found_SYNONYM], 0
		mov	[cs:$P_DX], 0
		mov	[word ptr cs:$P_FileSp_Char], '][' ; "[]|<>+=;\""
		mov	[word ptr cs:$P_FileSp_Char+2],	'<|'
		mov	[word ptr cs:$P_FileSp_Char+4],	'+>'
		mov	[word ptr cs:$P_FileSp_Char+6],	';='
		call	$P_Skip_Delim
		jnb	short $P_Start
		mov	ax, 0FFFFh	; $P_RC_EOL
		push	bx
		mov	bx, [es:di]	; [es:di+$P_PARMS_BLK.$P_PARMSX_Address]
		cmp	cl, [es:bx]	; [es:bx+$P_PARMSX_BLK.$P_MinP]
					; check	ORDINAL	to see if the minimum
		jnb	short $P_Fin	; positional found.
		mov	ax, 2		; $P_Op_Missing

$P_Fin:					; ...
		pop	bx
		jmp	$P_Single_Exit
; ---------------------------------------------------------------------------

$P_Start:				; ...
		mov	[cs:$P_SaveSI_Cmpx], si
		push	bx
		push	di
		push	bp
		lea	bx, [$P_STRING_BUF]
		test	[cs:$P_Flags2],	20h ; $P_Extra
		jnz	short $P_Pack_End

$P_Pack_Loop:				; ...
		lodsb
		call	$P_Chk_Switch	; Check	switch character
		jb	short $P_Pack_End_BY_EOL ; if carry set	found delimiter	type slash,
					; need backup si, else continue
		call	$P_Chk_EOL	; Check	EOL character
		jz	short $P_Pack_End_BY_EOL
		call	$P_Chk_Delim	; Check	delimiter
		jnz	short $P_PL01	; If no, process next byte
		test	[cs:$P_Flags2],	20h ; $P_Extra
		jnz	short $P_Pack_End_backup_si
		call	$P_Skip_Delim	; skip subsequent white	space,too
		jmp	short $P_Pack_End ; finish copy	by placing NUL at end
; ---------------------------------------------------------------------------

$P_Pack_End_backup_si:			; ...
		test	[cs:$P_Flags2],	41h ; $P_SW+$P_equ
		jz	short $P_Pack_End
		dec	si
		jmp	short $P_Pack_End
; ---------------------------------------------------------------------------

$P_PL01:				; ...
		mov	[cs:bx], al
		cmp	al, 3Dh	; '='   ; $P_Keyword
		jnz	short $P_PL00
		or	[cs:$P_Flags2],	1 ; $P_equ

$P_PL00:				; ...
		inc	bx		; ready	to see next byte
		call	$P_Chk_DBCS	; was it 1st byte of DBCS ?
		jnb	short $P_Pack_Loop ; if	no, process to next byte
		lodsb			; if yes, store	2nd byte of DBCS
		mov	[cs:bx], al
		inc	bx		; update pointer
		jmp	short $P_Pack_Loop ; process to	next byte
; ---------------------------------------------------------------------------

$P_Pack_End_BY_EOL:			; ...
		dec	si		; backup si pointer

$P_Pack_End:				; ...
		mov	[cs:$P_SI_Save], si ; save next	pointer
		mov	[byte ptr cs:bx], 0 ; $P_NULL ;	put nul	at the end
		mov	[cs:$P_Save_EOB], bx ; keep the	addr for later use of complex
		mov	bx, [es:di]	; get PARMSX address
		lea	si, [$P_STRING_BUF]
		cmp	[byte ptr cs:si], 2Fh ;	'/' ; $P_Switch
		jz	short $P_SW_Manager ; if yes, process as switch
		cmp	[byte ptr cs:si], 22h ;	'"' ; $P_DQuote
		jz	short $P_Positional_Manager ; if so, process as	one!
		test	[cs:$P_Flags2],	1 ; $P_equ
					; is the operand includes equal	char ?
		jnz	short $P_Key_Manager ; if yes, process as keyword

$P_Positional_Manager:			; ...
		mov	al, [es:bx+1]	; [es:bx+$P_PARMSX_BLK.$P_MaxP]
		xor	ah, ah		; ax = maxp
		cmp	[cs:$P_ORDINAL], ax ; too many positional ?
		jnb	short $P_Too_Many_Error	; if yes, set exit code	to too many
		mov	ax, [cs:$P_ORDINAL] ; see what the current ordinal
		shl	ax, 1		; ax = ax*2
		inc	bx		; add 2	to bx
		inc	bx		; now bx points	to 1st CONTROL
		add	bx, ax		; now bx points	to specified CONTROL address
		mov	bx, [es:bx]	; now bx points	to specified CONTROL itself
		call	$P_Chk_Pos_Control ; Do	process	for positional
		jmp	short $P_Return_to_Caller
; ---------------------------------------------------------------------------

$P_Too_Many_Error:			; ...
		mov	[cs:$P_RC], 1	; $P_Too_Many ;	set exit code
		jmp	short $P_Return_to_Caller
endp		sysparse


; =============== S U B	R O U T	I N E =======================================


proc		$P_get_max_ptr near	; ...
		mov	al, [es:bx+1]	; [es:bx+$P_PARMSX_BLK.$P_MaxP]	; get maxp
		xor	ah, ah		; ax = maxp
		inc	ax
		shl	ax, 1		; ax = (ax+1)*2
		add	bx, ax		; now bx points	to maxs
		retn
endp		$P_get_max_ptr

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sysparse

$P_SW_Manager:				; ...
		call	$P_get_max_ptr
		mov	cl, [es:bx]
		xor	ch, ch
		jcxz	short $P_SW_Not_Found
		inc	bx

$P_SW_Mgr_Loop:				; ...
		push	bx
		mov	bx, [es:bx]	; bx points to Switch CONTROL itself
		call	$P_Chk_SW_Control
		pop	bx
		jnb	short $P_Return_to_Caller ;
					; if the CONTROL is for	the switch, exit
		inc	bx
		inc	bx		; bx points to the next	CONTROL
		loop	$P_SW_Mgr_Loop	; loop

$P_SW_Not_Found:			; ...
		mov	[cs:$P_RC], 3	; $P_Not_In_SW
		jmp	short $P_Return_to_Caller
; ---------------------------------------------------------------------------

$P_Key_Manager:				; ...
		call	$P_get_max_ptr
		mov	al, [es:bx]
		xor	ah, ah
		shl	ax, 1
		inc	ax
		add	bx, ax
		mov	cl, [es:bx]
		xor	ch, ch
		jcxz	short $P_Key_Not_Found
		inc	bx

$P_Key_Mgr_Loop:			; ...
		push	bx
		mov	bx, [es:bx]
		call	$P_Chk_Key_Control
		pop	bx
		jnb	short $P_Return_to_Caller
		inc	bx
		inc	bx
		loop	$P_Key_Mgr_Loop

$P_Key_Not_Found:			; ...
		mov	[cs:$P_RC], 4	; $P_Not_In_Key

$P_Return_to_Caller:			; ...
		pop	bp
		pop	di
		pop	bx
		mov	cx, [cs:$P_ORDINAL] ; return next ordinal
		mov	ax, [cs:$P_RC]	; return exit code
		mov	si, [cs:$P_SI_Save] ; return next operand pointer
		mov	dx, [cs:$P_DX]	; return result	buffer address
		mov	bl, [cs:$P_Terminator] ; return	delimiter code found

$P_Single_Exit:				; ...
		clc
		retn
; END OF FUNCTION CHUNK	FOR sysparse

; =============== S U B	R O U T	I N E =======================================


proc		$P_Chk_Pos_Control near	; ...
		push	ax
		mov	ax, [es:bx]	; [es:bx+$P_CONTROL_BLK.$P_Match_Flag]
		test	ax, 2		; $P_Repeat ; repeat allowed ?
		jnz	short $P_CPC00	; then do not increment	ORDINAL
		inc	[cs:$P_ORDINAL]	; inc word [cs:$P_ORDINAL]

$P_CPC00:				; ...
		cmp	[byte ptr cs:si], 0 ; $P_NULL ;	no data	?
		jnz	short $P_CPC01
		test	ax, 1		; $P_Optional
		jnz	short $P_CPC02	; optional
		mov	[cs:$P_RC], 2	; $P_Op_Missing	; no, then error
		jmp	short $P_CPC_Exit
; ---------------------------------------------------------------------------

$P_CPC02:				; ...
		push	ax		; if it	is optional return NULL
		mov	ax, 0FF03h	; ($P_No_Tag<<8)+$P_String
		call	$P_Fill_Result
		pop	ax
		jmp	short $P_CPC_Exit
; ---------------------------------------------------------------------------

$P_CPC01:				; ...
		call	$P_Check_Match_Flags

$P_CPC_Exit:				; ...
		pop	ax
		retn
endp		$P_Chk_Pos_Control


; =============== S U B	R O U T	I N E =======================================


proc		$P_Chk_Key_Control near	; ...
		stc
		retn
endp		$P_Chk_Key_Control


; =============== S U B	R O U T	I N E =======================================


proc		$P_Search_KEYorSW near	; ...
		push	bp
		push	cx
		mov	cl, [es:bx+8]	; [es:bx+$P_CONTROL_BLK.$P_nid]
		xor	ch, ch
		jcxz	short $P_KEYorSW_Not_Found
		lea	bp, [bx+9]	; [es:bx+$P_CONTROL_BLK.$P_KEYorSW]

$P_KEYorSW_Loop:			; ...
		call	$P_String_Comp	; compare string in buffer with	the synonym
		jnb	short $P_KEYorSW_Found ; If match, set it to synonym pointer
		call	$P_MoveBP_NUL	; else,	bp points to the next string
		loop	$P_KEYorSW_Loop

$P_KEYorSW_Not_Found:			; ...
		stc
		jmp	short $P_KEYorSW_Exit
; ---------------------------------------------------------------------------

$P_KEYorSW_Found:			; ...
		mov	[cs:$P_Found_SYNONYM], bp ; set	synonym	pointer
		clc

$P_KEYorSW_Exit:			; ...
		pop	cx
		pop	bp
		retn
endp		$P_Search_KEYorSW


; =============== S U B	R O U T	I N E =======================================


proc		$P_MoveBP_NUL near	; ...
		cmp	[byte ptr es:bp+0], 0 ;	$P_NULL
		jz	short $P_MBP_Exit
		inc	bp
		jmp	short $P_MoveBP_NUL
; ---------------------------------------------------------------------------

$P_MBP_Exit:				; ...
		inc	bp
		retn
endp		$P_MoveBP_NUL


; =============== S U B	R O U T	I N E =======================================


proc		$P_Chk_SW_Control near	; ...
		or	[cs:$P_Flags2],	10h ; $P_SW_Cmp
		call	$P_Search_KEYorSW
		jb	short $P_Chk_SW_Err0
		and	[cs:$P_Flags2],	0EFh ; 0FFh-$P_SW_Cmp
		push	ax
		mov	ax, [cs:$P_KEYorSW_Ptr]
		sub	ax, si
		add	[cs:$P_SaveSI_Cmpx], ax
		pop	ax
		mov	si, [cs:$P_KEYorSW_Ptr]
		cmp	[byte ptr cs:si], 0 ; $P_NULL
		jnz	short $P_CSW00
		cmp	[byte ptr cs:si-1], 3Ah	; ':' ; $P_Colon
		jnz	short $P_Chk_if_data_required
		mov	[cs:$P_RC], 9	; $P_Syntax
		jmp	short $P_Chk_SW_Exit
; ---------------------------------------------------------------------------

$P_Chk_if_data_required:		; ...
		cmp	[word ptr es:bx], 0
		jz	short $P_Chk_SW_Exit
		test	[word ptr es:bx], 1 ; [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
		jnz	short $P_Chk_SW_Exit
		mov	[cs:$P_RC], 2	; [cs:$P_RC],$P_Op_Missing
		jmp	short $P_Chk_SW_Exit
; ---------------------------------------------------------------------------

$P_CSW00:				; ...
		call	$P_Check_Match_Flags
		clc
		jmp	short $P_Chk_SW_Single_Exit
; ---------------------------------------------------------------------------

$P_Chk_SW_Err0:				; ...
		stc
		retn
; ---------------------------------------------------------------------------

$P_Chk_SW_Exit:				; ...
		push	ax
		mov	ax, 0FF03h	; ($P_No_Tag<<8)+$P_String
		call	$P_Fill_Result
		pop	ax
		clc

$P_Chk_SW_Single_Exit:			; ...
		retn
endp		$P_Chk_SW_Control


; =============== S U B	R O U T	I N E =======================================


proc		$P_Fill_Result near	; ...
		push	di
		mov	di, [es:bx+4]	; [es:bx+$P_CONTROL_BLK.$P_Result_Buf]
		mov	[cs:$P_DX], di
		mov	[es:di], al	; [es:di+$P_RESULT_BLK.$P_Type]
		mov	[es:di+1], ah	; [es:di+$P_RESULT_BLK.$P_Item_Tag]
		push	ax
		mov	ax, [cs:$P_Found_SYNONYM]
		mov	[es:di+2], ax	; [es:di+$P_RESULT_BLK.$P_SYNONYM_Ptr]
		pop	ax
		cmp	al, 1		; $P_Number
		jnz	short $P_RLT00

$P_RLT02:				; ...
		mov	[es:di+4], dx	; [es:di+$P_RESULT_BLK.$P_Picked_Val]
		mov	[es:di+6], cx	; [es:di+2+$P_RESULT_BLK.$P_Picked_Val]
		jmp	short $P_RLT_Exit
; ---------------------------------------------------------------------------

$P_RLT00:				; ...
		cmp	al, 2		; $P_List_Idx
		jnz	short $P_RLT01
		mov	[es:di+4], dx	; [es:di+$P_RESULT_BLK.$P_Picked_Val]
		jmp	short $P_RLT_Exit
; ---------------------------------------------------------------------------

$P_RLT01:				; ...
		cmp	al, 7		; $P_Date_F
		jz	short $P_RLT02
		cmp	al, 8		; $P_Time_F
		jz	short $P_RLT02
		cmp	al, 6		; $P_Drive
		jnz	short $P_RLT03
		mov	[es:di+4], dl	; [es:di+$P_RESULT_BLK.$P_Picked_Val]
		jmp	short $P_RLT_Exit
; ---------------------------------------------------------------------------

$P_RLT03:				; ...
		cmp	al, 4		; $P_Complex
		jnz	short $P_RLT05
		mov	ax, [cs:$P_SaveSI_Cmpx]
		inc	ax
		mov	[es:di+4], ax	; [es:di+$P_RESULT_BLK.$P_Picked_Val]
		mov	[word ptr es:di+6], ds ; [es:di+2+$P_RESULT_BLK.$P_Picked_Val]
		jmp	short $P_RLT_Exit
; ---------------------------------------------------------------------------

$P_RLT05:				; ...
		mov	[es:di+4], si	; [es:di+$P_RESULT_BLK.$P_Picked_Val]
		mov	[word ptr es:di+6], cs ; [es:di+2+$P_RESULT_BLK.$P_Picked_Val]
		push	ax
		test	[byte ptr es:bx+2], 1 ;	[es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_File
		jz	short $P_RLT_CAP00
		mov	al, 4		; $P_DOSTBL_File
		jmp	short $P_RLT_CAP02
; ---------------------------------------------------------------------------

$P_RLT_CAP00:				; ...
		test	[byte ptr es:bx+2], 2 ;	[es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_Char
		jz	short $P_RLT_CAP01
		mov	al, 2		; $P_DOSTBL_Char

$P_RLT_CAP02:				; ...
		call	$P_Do_CAPS_String ; process CAPS along the table

$P_RLT_CAP01:				; ...
		pop	ax
		test	[byte ptr es:bx+2], 10h	; [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_Rm_Colon
		jz	short $P_RLT_Exit
		call	$P_Remove_Colon

$P_RLT_Exit:				; ...
		pop	di
		retn
endp		$P_Fill_Result


; =============== S U B	R O U T	I N E =======================================


proc		$P_Check_Match_Flags near ; ...
		mov	[cs:$P_err_flag], 0 ; $P_NULL
		push	ax
		mov	ax, [es:bx]	; [es:bx+$P_CONTROL_BLK.$P_Match_Flag]
		or	ax, ax
		jnz	short $P_Mat
		push	ax
		push	bx
		push	dx
		push	di
		mov	[cs:$P_RC], 9	; $P_Syntax
		mov	ax, 0FF03h	; ($P_No_Tag<<8)+$P_String
		call	$P_Fill_Result
		pop	di
		pop	dx
		pop	bx
		pop	ax
		jmp	short $P_Bridge
; ---------------------------------------------------------------------------

$P_Mat:					; ...
		test	ax, 1000h	; $P_Date_S
		jz	short $P_Match02
		mov	[cs:$P_RC], 0	; $P_No_Error
		call	$P_Date_Format
		cmp	[cs:$P_RC], 9	; $P_Syntax
		jnz	short $P_Bridge

$P_Match02:				; ...
		test	ax, 800h	; $P_Time_S
		jz	short $P_Match03
		mov	[cs:$P_RC], 0
		call	$P_Time_Format
		cmp	[cs:$P_RC], 9
		jnz	short $P_Bridge
		jmp	short $P_Match03
; ---------------------------------------------------------------------------

$P_Bridge:				; ...
		jmp	short $P_Match_Exit
; ---------------------------------------------------------------------------
		nop

$P_Match03:				; ...
		test	ax, 8000h	; $P_Num_Val
		jz	short $P_Match04
		mov	[cs:$P_RC], 0
		call	$P_Value
		cmp	[cs:$P_RC], 9
		jnz	short $P_Match_Exit

$P_Match04:				; ...
		test	ax, 4000h	; $P_SNum_Val
		jz	short $P_Match05
		mov	[cs:$P_RC], 0
		call	$P_SValue
		cmp	[cs:$P_RC], 9
		jnz	short $P_Match_Exit

$P_Match05:				; ...
		test	ax, 100h	; $P_Drv_Only
		jz	short $P_Match06
		mov	[cs:$P_RC], 0
		call	$P_File_Format
		call	$P_Drive_Format
		cmp	[cs:$P_RC], 9
		jnz	short $P_Match_Exit

$P_Match06:				; ...
		test	ax, 200h	; $P_File_Spc
		jz	short $P_Match07
		mov	[cs:$P_RC], 0
		call	$P_File_Format
		cmp	[cs:$P_RC], 9
		jnz	short $P_Match_Exit

$P_Match07:				; ...
		test	ax, 2000h	; $P_Simple_S
		jz	short $P_Match_Exit
		mov	[cs:$P_RC], 0	; $P_No_Error
		call	$P_Simple_String

$P_Match_Exit:				; ...
		cmp	[cs:$P_err_flag], 1 ; $P_error_filespec
		jnz	short $P_Match2_Exit
		cmp	[cs:$P_RC], 0	; $P_No_Error
		jnz	short $P_Match2_Exit
		mov	[cs:$P_RC], 9	; $P_Syntax

$P_Match2_Exit:				; ...
		pop	ax
		retn
endp		$P_Check_Match_Flags


; =============== S U B	R O U T	I N E =======================================


proc		$P_Remove_Colon	near	; ...
		push	ax
		push	si

$P_RCOL_Loop:				; ...
		mov	al, [cs:si]
		or	al, al
		jz	short $P_RCOL_Exit
		cmp	al, 3Ah	; ':'   ; $P_Colon
		jnz	short $P_RCOL00
		cmp	[byte ptr cs:si+1], 0 ;	$P_NULL
		jnz	short $P_RCOL00
		mov	[byte ptr cs:si], 0
		jmp	short $P_RCOL_Exit
; ---------------------------------------------------------------------------

$P_RCOL00:				; ...
		call	$P_Chk_DBCS
		jnb	short $P_RCOL01
		inc	si

$P_RCOL01:				; ...
		inc	si
		jmp	short $P_RCOL_Loop
; ---------------------------------------------------------------------------

$P_RCOL_Exit:				; ...
		pop	si
		pop	ax
		retn
endp		$P_Remove_Colon


; =============== S U B	R O U T	I N E =======================================


proc		$P_Do_CAPS_String near	; ...
		push	si
		push	dx
		mov	dl, al

$P_DCS_Loop:				; ...
		mov	al, [cs:si]
		call	$P_Chk_DBCS
		jb	short $P_DCS00
		or	al, al
		jz	short $P_DCS_Exit
		call	$P_Do_CAPS_Char
		mov	[cs:si], al
		jmp	short $P_DCS01
; ---------------------------------------------------------------------------

$P_DCS00:				; ...
		inc	si

$P_DCS01:				; ...
		inc	si
		jmp	short $P_DCS_Loop
; ---------------------------------------------------------------------------

$P_DCS_Exit:				; ...
		pop	dx
		pop	si
		retn
endp		$P_Do_CAPS_String


; =============== S U B	R O U T	I N E =======================================


proc		$P_Do_CAPS_Char	near	; ...
		cmp	al, 80h		; $P_ASCII80
		jnb	short $P_DCC_Go
		cmp	al, 'a'
		jb	short $P_CAPS_Ret
		cmp	al, 'z'
		ja	short $P_CAPS_Ret
		and	al, 0DFh	; $P_Make_Upper
		retn
; ---------------------------------------------------------------------------

$P_DCC_Go:				; ...
		push	bx
		push	es
		push	di
		lea	di, [$P_File_CAP_Ptr]
		cmp	dl, 4		; $P_DOSTBL_File
		jz	short $P_DCC00
		lea	di, [$P_Char_CAP_Ptr]

$P_DCC00:				; ...
		cmp	[cs:di], dl
		jz	short $P_DCC01
		push	ax
		push	cx
		push	dx
		push	cs
		pop	es
		assume es:TRANGROUP
		xchg	ax, dx
		mov	ah, 65h		; $P_DOS_Get_TBL
		mov	bx, 0FFFFh	; -1 ; $P_DOSTBL_Def
		mov	cx, 5		; $P_DOSTBL_BL
		mov	dx, bx		; $P_DOSTBL_Def
		int	21h		; DOS -	4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
					; AL = function	-
		pop	dx
		pop	cx
		pop	ax

$P_DCC01:				; ...
		les	bx, [cs:di+1]
		assume es:nothing
		inc	bx
		inc	bx
		sub	al, 80h		; $P_ASCII80
		xlat	[byte ptr es:bx]
		pop	di
		pop	es
		pop	bx

$P_CAPS_Ret:				; ...
		retn
endp		$P_Do_CAPS_Char


; =============== S U B	R O U T	I N E =======================================


proc		$P_SValue near		; ...
		push	ax
		or	[cs:$P_Flags2],	80h ; $P_Signed
		and	[cs:$P_Flags2],	0FDh ; 0FFh-$P_Neg
		mov	al, [cs:si]
		cmp	al, '+'         ; $P_Plus
		jz	short $P_SVal00
		cmp	al, '-'         ; $P_Plus
		jnz	short $P_Sval01
		or	[cs:$P_Flags2],	2 ; $P_Neg

$P_SVal00:				; ...
		inc	si

$P_Sval01:				; ...
		call	$P_Value
		pop	ax
		retn
endp		$P_SValue


; =============== S U B	R O U T	I N E =======================================


proc		$P_Value near		; ...
		push	ax
		push	cx
		push	dx
		push	si
		xor	cx, cx
		xor	dx, dx
		push	bx

$P_Value_Loop:				; ...
		mov	al, [cs:si]
		or	al, al
		jz	short $P_Value00
		call	$P_0099
		jb	short $P_Value_Err0
		xor	ah, ah
		mov	bp, ax
		call	$P_Check_OVF_shl32
		mov	bx, dx
		mov	ax, cx
		call	$P_Check_OVF_shl32
		call	$P_Check_OVF_shl32
		add	dx, bx
		adc	cx, ax
		call	$P_Check_OVF_@
		add	dx, bp
		adc	cx, 0
		call	$P_Check_OVF_@
		inc	si
		jmp	short $P_Value_Loop
endp		$P_Value

; ---------------------------------------------------------------------------

$P_Check_OVF_shl32:			; ...
		shl	dx, 1
		rcl	cx, 1

$P_Check_OVF_@:				; ...
		call	$P_Check_OVF
		jb	short $P_Value_Err0_@
		retn
; ---------------------------------------------------------------------------

$P_Value_Err0_@:			; ...
		inc	sp
		inc	sp

$P_Value_Err0:				; ...
		pop	bx
		jmp	$P_Value_Err
; ---------------------------------------------------------------------------

$P_Value00:				; ...
		pop	bx
		test	[cs:$P_Flags2],	2 ; $P_Neg
		jz	short $P_Value01
		not	cx
		not	dx
		add	dx, 1
		adc	cx, 0

$P_Value01:				; ...
		mov	si, [es:bx+6]	; [es:bx+$P_CONTROL_BLK.$P_Value_List]
		mov	al, [es:si]
		cmp	al, 0		; $P_nval_None
		jnz	short $P_Value02
		mov	ax, 0FF01h	; ($P_No_Tag<<8)+$P_Number
		jmp	short $P_Value_Exit
; ---------------------------------------------------------------------------
		nop

$P_Value02:				; ...
		inc	si
		mov	al, [es:si]
		cmp	al, 0		; $P_No_nrng
		jz	short $P_Value_Err
		inc	si

$P_Val02_Loop:				; ...
		test	[cs:$P_Flags2],	80h ; $P_Signed
		jnz	short $P_Val02_Sign
		cmp	cx, [es:si+3]	; [es:si+$P_VAL_LIST.$P_Val_XH]
		jb	short $P_Val02_Next
		ja	short $P_Val_In
		cmp	dx, [es:si+1]	; [es:si+$P_VAL_LIST.$P_Val_XL]
		jb	short $P_Val02_Next

$P_Val_In:				; ...
		cmp	cx, [es:si+7]	; [es:si+$P_VAL_LIST.$P_Val_YH]
		ja	short $P_Val02_Next
		jb	short $P_Val_Found
		cmp	dx, [es:si+5]	; [es:si+$P_VAL_LIST.$P_Val_YL]
		ja	short $P_Val02_Next
		jmp	short $P_Val_Found
; ---------------------------------------------------------------------------

$P_Val02_Sign:				; ...
		cmp	cx, [es:si+3]	; [es:si+$P_VAL_LIST.$P_Val_XH]
		jl	short $P_Val02_Next
		jg	short $P_SVal_In
		cmp	dx, [es:si+1]	; [es:si+$P_VAL_LIST.$P_Val_XL]
		jl	short $P_Val02_Next

$P_SVal_In:				; ...
		cmp	cx, [es:si+7]	; [es:si+$P_VAL_LIST.$P_Val_YH]
		jg	short $P_Val02_Next
		jl	short $P_Val_Found
		cmp	dx, [es:si+5]	; [es:si+$P_VAL_LIST.$P_Val_YL]
		jg	short $P_Val02_Next
		jmp	short $P_Val_Found
; ---------------------------------------------------------------------------

$P_Val02_Next:				; ...
		add	si, 9		; $P_Len_Range
		dec	al
		jnz	short $P_Val02_Loop
		mov	[cs:$P_RC], 6	; $P_Out_Of_Range
		mov	ax, 0FF01h	; ($P_No_Tag<<8)+$P_Number
		jmp	short $P_Value_Exit
; ---------------------------------------------------------------------------

$P_Val_Found:				; ...
		mov	al, 1		; $P_Number
		mov	ah, [es:si]
		jmp	short $P_Value_Exit
; ---------------------------------------------------------------------------

$P_Value_Err:				; ...
		mov	[cs:$P_RC], 9	; $P_Syntax
		mov	ax, 0FF03h	; ($P_No_Tag<<8)+$P_String

$P_Value_Exit:				; ...
		call	$P_Fill_Result
		pop	si
		pop	dx
		pop	cx
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================


proc		$P_Check_OVF near	; ...
		pushf
		test	[cs:$P_Flags2],	2 ; $P_Neg ; is	it negative value ?
		jnz	short $P_COVF	; if no, check overflow
		popf
		retn
; ---------------------------------------------------------------------------

$P_COVF:				; ...
		popf
		jo	short $P_COVF00	; CY=1 means overflow
		clc			; CY=0 means no	overflow
		retn
; ---------------------------------------------------------------------------

$P_COVF00:				; ...
		stc			; CY=1 means overflow
		retn
endp		$P_Check_OVF


; =============== S U B	R O U T	I N E =======================================


proc		$P_0099	near		; ...
		cmp	al, 30h	; '0'   ; Make ASCII 0-9 to Binary 0-9
		jb	short $P_0099Err
		cmp	al, 39h	; '9'
		ja	short $P_0099Err
		sub	al, 30h	; '0'
		clc
		retn
; ---------------------------------------------------------------------------

$P_0099Err:				; ...
		stc
		retn
endp		$P_0099


; =============== S U B	R O U T	I N E =======================================


proc		$P_Simple_String near	; ...
		push	ax
		push	bx
		push	dx
		push	di
		mov	di, [es:bx+6]	; [es:bx+$P_CONTROL_BLK.$P_Value_List]
		mov	al, [es:di]	; get nval
		or	al, al
		jnz	short $P_Sim00
		mov	ah, 0FFh	; $P_No_Tag
		jmp	short $P_Sim_Exit
; ---------------------------------------------------------------------------

$P_Sim00:				; ...
		cmp	al, 3		; $P_nval_String
		jnz	short $P_Sim01
		inc	di
		mov	al, [es:di]
		mov	ah, 9		; $P_Len_Range
		mul	ah		; Skip nrng field
		inc	ax		; ax = (nrng*9)+1
		add	di, ax
		mov	al, [es:di]	; get nnval
		mov	ah, 5		; $P_Len_Value
		mul	ah		; Skip nnval field
		inc	ax		; ax = (nnval*5)+1
		add	di, ax
		mov	al, [es:di]	; get nstrval
		inc	di
		inc	di		; di points to 1st string in list

$P_Sim_Loop:				; ...
		mov	bp, [es:di]
		call	$P_String_Comp
		jnb	short $P_Sim_Found
		add	di, 3		; $P_Len_String
		dec	al		; loop nstval times in AL
		jnz	short $P_Sim_Loop
		mov	[cs:$P_RC], 8	; $P_Not_In_Str
		mov	ah, 0FFh	; $P_No_Tag
		jmp	short $P_Sim_Exit
; ---------------------------------------------------------------------------

$P_Sim_Found:				; ...
		mov	ah, [es:di-1]	; set item_tag
		mov	al, 2		; $P_List_Idx
		mov	dx, [es:di]
		jmp	short $P_Sim_Exit0
; ---------------------------------------------------------------------------

$P_Sim01:				; ...
		mov	[cs:$P_RC], 9	; $P_Syntax
		mov	ah, 0FFh	; $P_No_Tag

$P_Sim_Exit:				; ...
		mov	al, 3		; $P_String

$P_Sim_Exit0:				; ...
		call	$P_Fill_Result
		pop	di
		pop	dx
		pop	bx
		pop	ax
		retn
endp		$P_Simple_String


; =============== S U B	R O U T	I N E =======================================


proc		$P_String_Comp near	; ...
		push	ax
		push	bp
		push	dx
		push	si
		mov	dl, 2		; $P_DOSTBL_Char

$P_SCOM_Loop:				; ...
		mov	al, [cs:si]
		call	$P_Chk_DBCS
		jb	short $P_SCOM00
		call	$P_Do_CAPS_Char
		test	[cs:$P_Flags2],	8
		jz	short $P_SCOM04
		cmp	al, 3Dh	; '='   ; $P_Keyword
		jnz	short $P_SCOM03
		cmp	[byte ptr es:bp+1], 0 ;	$P_NULL
		jnz	short $P_SCOM_Differ
		jmp	short $P_SCOM05
; ---------------------------------------------------------------------------

$P_SCOM04:				; ...
		test	[cs:$P_Flags2],	10h ; $P_SW_Cmp
		jz	short $P_SCOM03
		cmp	al, 3Ah	; ':'
		jnz	short $P_SCOM03
		cmp	[byte ptr es:bp+0], 0
		jnz	short $P_SCOM_Differ

$P_SCOM05:				; ...
		inc	si
		jmp	short $P_SCOM_Same
; ---------------------------------------------------------------------------

$P_SCOM03:				; ...
		cmp	al, [es:bp+0]
		jnz	short $P_SCOM_Differ0
		or	al, al
		jz	short $P_SCOM_Same
		inc	si
		inc	bp
		jmp	short $P_SCOM01
; ---------------------------------------------------------------------------

$P_SCOM00:				; ...
		cmp	al, [es:bp+0]
		jnz	short $P_SCOM_Differ
		inc	si
		mov	al, [cs:si]
		inc	bp
		cmp	al, [es:bp+0]
		jnz	short $P_SCOM_Differ
		inc	si
		inc	bp

$P_SCOM01:				; ...
		jmp	short $P_SCOM_Loop
; ---------------------------------------------------------------------------

$P_SCOM_Differ0:			; ...
		test	[cs:$P_Flags2],	40h ; $P_SW
		jz	short $P_not_applicable
		test	[word ptr es:bx+2], 20h	; [es:bx+$P_CONTROL_BLK.$P_Function_Flag],
					; $P_colon_is_not_necessary
		jz	short $P_not_applicable
		cmp	[byte ptr es:bp+0], 0 ;	$P_NULL
		jz	short $P_SCOM_Same

$P_not_applicable:			; ...
		test	[word ptr es:bx], 10h ;	[es:bx+$P_CONTROL_BLK.$P_Match_Flag],
					; $P_Ig_Colon
		jz	short $P_SCOM_Differ
		cmp	al, 3Ah	; ':'   ; $P_Colon
		jnz	short $P_SCOM02
		cmp	[byte ptr es:bp+0], 0 ;	$P_NULL
		jnz	short $P_SCOM_Differ
		jmp	short $P_SCOM_Same
; ---------------------------------------------------------------------------

$P_SCOM02:				; ...
		cmp	al, 0		; $P_NULL
		jnz	short $P_SCOM_Differ
		cmp	[byte ptr es:bp+0], 3Ah	; ':' ; $P_Colon
		jz	short $P_SCOM_Same

$P_SCOM_Differ:				; ...
		stc
		jmp	short $P_SCOM_Exit
; ---------------------------------------------------------------------------

$P_SCOM_Same:				; ...
		mov	[cs:$P_KEYorSW_Ptr], si
		clc

$P_SCOM_Exit:				; ...
		pop	si
		pop	dx
		pop	bp
		pop	ax
		retn
endp		$P_String_Comp


; =============== S U B	R O U T	I N E =======================================


proc		$P_Date_Format near	; ...
		push	ax
		push	cx
		push	dx
		push	si
		push	bx
		push	si
		call	$P_Set_CDI	; set country dependent	information before process
		pop	si
		mov	ax, 0FFFFh
		mov	[cs:$P_1st_Val], ax
		mov	[cs:$P_2nd_Val], ax
		mov	[cs:$P_3rd_Val], ax
		call	$P_Get_DecNum
		jb	short $P_DateF_Err0
		mov	[cs:$P_1st_Val], ax
		or	bl, bl		; end of line ?
		jz	short $P_DateF_YMD ; yes
		call	$P_Get_DecNum
		jb	short $P_DateF_Error
		mov	[cs:$P_2nd_Val], ax
		or	bl, bl
		jz	short $P_DateF_YMD
		call	$P_Get_DecNum

$P_DateF_Err0:				; ...
		jb	short $P_DateF_Error
		mov	[cs:$P_3rd_Val], ax
		or	bl, bl		; end of line ?
		jnz	short $P_DateF_Error ; no, error

$P_DateF_YMD:				; ...
		mov	bx, [cs:$P_Country_Info] ; [cs:$P_Country_Info+$P_CDI.$P_CDI_DateF]
		cmp	bx, 2		; $P_Date_YMD
		jz	short $P_DateF00
		mov	ax, [cs:$P_1st_Val]
		or	ah, ah
		jnz	short $P_DateF_Error
		mov	cl, al
		mov	ax, [cs:$P_2nd_Val]
		or	ah, ah
		jnz	short $P_DateF_Error
		mov	ch, al
		mov	dx, [cs:$P_3rd_Val]
		cmp	bx, 1		; $P_Date_DMY
		jnz	short $P_DateF01
		xchg	ch, cl

$P_DateF01:				; ...
		jmp	short $P_DateF02
; ---------------------------------------------------------------------------

$P_DateF00:				; ...
		mov	dx, [cs:$P_1st_Val] ; set year
		mov	ax, [cs:$P_2nd_Val]
		or	ah, ah		; if overflow, error
		jnz	short $P_DateF_Error
		mov	cl, al		; set month
		mov	ax, [cs:$P_3rd_Val]
		or	ah, ah		; if overflow, error
		jnz	short $P_DateF_Error
		mov	ch, al		; set date

$P_DateF02:				; ...
		cmp	dx, 100
		jnb	short $P_DateF03
		cmp	dx, 80
		jnb	short $P_DateF02_@
		add	dx, 100

$P_DateF02_@:				; ...
		add	dx, 1900

$P_DateF03:				; ...
		pop	bx
		pop	si
		mov	ax, 0FF07h	; ($P_No_Tag<<8)+$P_Date_F
		call	$P_Fill_Result
		jmp	short $P_Date_Format_Exit
; ---------------------------------------------------------------------------

$P_DateF_Error:				; ...
		pop	bx
		pop	si
		mov	ax, 0FF03h	; ($P_No_Tag<<8)+$P_String
		call	$P_Fill_Result
		mov	[cs:$P_RC], 9	; $P_Syntax ; indicate syntax error

$P_Date_Format_Exit:			; ...
		pop	dx
		pop	cx
		pop	ax
		retn
endp		$P_Date_Format


; =============== S U B	R O U T	I N E =======================================


proc		$P_Set_CDI near		; ...
		lea	si, [$P_Country_Info]
		cmp	[word ptr cs:si], 0FFFFh ; -1 ;	$P_NeedToBeRead
		jnz	short $P_Set_CDI_Exit
		push	ds
		push	dx
		push	ax
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	ax, 3800h	; $P_DOS_Get_CDI
		mov	dx, si
		int	21h		; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
					; get current-country info
					; DS:DX	-> buffer for returned info
		pop	ax
		pop	dx
		pop	ds
		assume ds:nothing

$P_Set_CDI_Exit:			; ...
		retn
endp		$P_Set_CDI


; =============== S U B	R O U T	I N E =======================================


proc		$P_Get_DecNum near	; ...
		push	cx		; Read a character code	from psdata_seg:SI
					; until	specified delimiter or NULL encountered.
					; And make a decimal number.
		push	dx
		xor	cx, cx

$P_GetNum_Loop:				; ...
		mov	al, [cs:si]
		or	al, al
		jz	short $P_GetNum00
		cmp	[cs:$P_Got_Time], 0
		jz	short $P_Do_Date_Delims
		cmp	bl, 1
		jnz	short $P_Do_Time_Delim1
		cmp	al, ':'         ; $P_Colon
		jz	short $P_GetNum01

$P_Do_Time_Delim1:			; ...
		cmp	al, '.'         ; $P_Period
		jz	short $P_GetNum01
		jmp	short $P_Neither_Delims
; ---------------------------------------------------------------------------

$P_Do_Date_Delims:			; ...
		cmp	al, '-'         ; $P_Minus
		jz	short $P_GetNum01
		cmp	al, '/'         ; $P_Slash
		jz	short $P_GetNum01
		cmp	al, '.'         ; $P_Period
		jz	short $P_GetNum01

$P_Neither_Delims:			; ...
		call	$P_0099
		jb	short $P_GetNum_Exit
		mov	ah, 0
		xchg	ax, cx
		mov	dx, 10
		mul	dx		; ax = ax * 10
		or	dx, dx
		jnz	short $P_GetNum02
		add	ax, cx
		jb	short $P_GetNum_Exit
		xchg	ax, cx
		inc	si
		jmp	short $P_GetNum_Loop
; ---------------------------------------------------------------------------

$P_GetNum00:				; ...
		mov	bl, al

$P_GetNum_Exit_clc:			; ...
		clc
		jmp	short $P_GetNum_Exit
; ---------------------------------------------------------------------------

$P_GetNum01:				; ...
		inc	si
		jmp	short $P_GetNum_Exit_clc
; ---------------------------------------------------------------------------

$P_GetNum02:				; ...
		stc

$P_GetNum_Exit:				; ...
		xchg	ax, cx
		pop	dx
		pop	cx
		retn
endp		$P_Get_DecNum


; =============== S U B	R O U T	I N E =======================================


proc		$P_Time_Format near	; ...
		push	ax
		push	cx
		push	dx
		push	si
		push	bx
		push	si
		call	$P_Set_CDI
		test	[byte ptr cs:si+11h], 1	; [cs:si+$P_CDI.$P_CDI_TimeF],1	; 24 hour system ?
		pop	si
		jnz	short $P_TimeF00 ; yes
		call	$P_Time_2412	; this routine handle "am" "pm"

$P_TimeF00:				; ...
		xor	ax, ax
		mov	[cs:$P_1st_Val], ax
		mov	[cs:$P_2nd_Val], ax
		mov	[cs:$P_3rd_Val], ax
		mov	[cs:$P_4th_Val], ax
		mov	[cs:$P_Got_Time], 1
		mov	bl, 1		; $P_colon_period ; flag, indicates use	of delimiters
					; between hours, minutes,seconds
		call	$P_Get_DecNum
		jb	short $P_TimeF_Err0
		mov	[cs:$P_1st_Val], ax
		or	bl, bl
		jz	short $P_TimeF_Rlt
		call	$P_Get_DecNum
		jb	short $P_TimeF_Err0
		mov	[cs:$P_2nd_Val], ax
		or	bl, bl		; end of line ?
		jz	short $P_TimeF_Rlt ; yes
		mov	bl, 2		; $P_period_only ; flag, which to decimal separator
		call	$P_Get_DecNum
		jb	short $P_TimeF_Err0
		mov	[cs:$P_3rd_Val], ax
		or	bl, bl		; end of line ?
		jnz	short $P_Time_4	; no
		test	[cs:$P_Flags], 2 ; $P_Time_Again ; has time parse been repeated?
		jnz	short $P_TimeF_Rlt ; yes, this is really the end of line
		mov	si, [cs:$P_SI_Save] ; get where	parser quit in command line
		cmp	[byte ptr si-1], ',' ; $P_Comma
		jnz	short $P_TimeF_Rlt
		mov	[byte ptr si-1], '.' ; $P_Period
		mov	[word ptr cs:$P_Flags],	0 ; clear all internal flags
		or	[cs:$P_Flags], 2 ; $P_Time_Again ; indicate TIME
		mov	cx, [cs:$P_ORIG_ORD] ; original	ordinal	from cx
		mov	sp, [cs:$P_ORIG_STACK] ; original value	of stack from sp
		mov	si, [cs:$P_ORIG_SI] ; original start parse pointer from	si
		jmp	$P_Redo_Time	; go try TIME again
; ---------------------------------------------------------------------------

$P_Time_4:				; ...
		call	$P_Get_DecNum

$P_TimeF_Err0:				; ...
		jb	short $P_TimeF_Error
		mov	[cs:$P_4th_Val], ax
		or	bl, bl		; After	hundredth, no data allowed
		jnz	short $P_TimeF_Error ; if some,	then error

$P_TimeF_Rlt:				; ...
		mov	ax, [cs:$P_1st_Val]
		or	ah, ah		; if overflow then error
		jnz	short $P_TimeF_Error
		test	[cs:$P_Flags], 1 ; if "am" specified
		jz	short $P_Time_notAM ; skip if no "AM" specified
		cmp	al, 12
		ja	short $P_TimeF_Error ; error if	"AM" on	more than noon
		jnz	short $P_Time_notAM
		xor	al, al		; for noon exactly, set	hour to	zero

$P_Time_notAM:				; ...
		test	[cs:$P_Flags2],	4 ; $P_Time12 ;	if 12 hour system and "PM" is specified
		jz	short $P_TimeSkip00 ; then
		cmp	al, 12		; if 12:00 o'clock already
		jz	short $P_TimeSkip00
		add	al, 12		; add 12 hours to make it afternoon
		jb	short $P_TimeF_Error
		cmp	al, 24		; after	adding 12, now cannot be >24
		ja	short $P_TimeF_Error ; if too big, error

$P_TimeSkip00:				; ...
		mov	dl, al		; set hour
		mov	ax, [cs:$P_2nd_Val]
		or	ah, ah		; if overflow then error
		jnz	short $P_TimeF_Error
		mov	dh, al		; set minute
		mov	ax, [cs:$P_3rd_Val]
		or	ah, ah
		jnz	short $P_TimeF_Error
		mov	cl, al		; set second
		mov	ax, [cs:$P_4th_Val]
		or	ah, ah
		jnz	short $P_TimeF_Error
		mov	ch, al		; set hundredth
		pop	bx
		pop	si
		mov	ax, 0FF08h	; ($P_No_Tag<<8)+$P_Time_F
		call	$P_Fill_Result
		jmp	short $P_Time_Format_Exit
; ---------------------------------------------------------------------------

$P_TimeF_Error:				; ...
		pop	bx
		pop	si
		mov	ax, 0FF03h	; ($P_No_Tag<<8)+$P_String
		call	$P_Fill_Result
		mov	[cs:$P_RC], 9	; $P_Syntax

$P_Time_Format_Exit:			; ...
		mov	[cs:$P_Got_Time], 0
		pop	dx
		pop	cx
		pop	ax
		retn
endp		$P_Time_Format


; =============== S U B	R O U T	I N E =======================================


proc		$P_Time_2412 near	; ...
		push	ax
		push	si

$P_T12_Loop:				; ...
		mov	al, [cs:si]
		inc	si
		or	al, al
		jnz	short $P_T12_Loop
		mov	al, [cs:si-2]
		or	al, 20h		; $P_Make_Lower
		cmp	al, 'p'         ; only "p" of "pm" ?
		jz	short $P_T1200	; yes
		cmp	al, 'a'         ; only "a" of "am" ?
		jz	short $P_T1201	; yes
		cmp	al, 'm'         ; "m" of "am" or "pm"
		jnz	short $P_T12_Exit
		dec	si
		mov	al, [cs:si-2]
		or	al, 20h		; $P_Make_Lower
		cmp	al, 'p'         ; "p" of "pm" ?
		jz	short $P_T1200	; yes
		cmp	al, 'a'         ; "a" of "am" ?
		jz	short $P_T1201	; yes
		jmp	short $P_T12_Exit
; ---------------------------------------------------------------------------

$P_T1200:				; ...
		or	[cs:$P_Flags2],	4 ; $P_Time12 ;	flag "PM" found
		jmp	short $P_Tclr_chr
; ---------------------------------------------------------------------------

$P_T1201:				; ...
		or	[cs:$P_Flags], 1 ; $P_Time12AM ; flag "AM" found

$P_Tclr_chr:				; ...
		mov	[byte ptr cs:si-2], 0 ;	$P_NULL	; null out special char

$P_T12_Exit:				; ...
		pop	si
		pop	ax
		retn
endp		$P_Time_2412


; =============== S U B	R O U T	I N E =======================================


proc		$P_File_Format near	; ...
		push	ax
		push	di
		push	si
		mov	di, [cs:$P_SaveSI_Cmpx]	; get user buffer address
		mov	al, [cs:si]	; load character
		or	al, al		; end of line ?
		jz	short $P_FileF_Err ; if	yes, error exit
		call	$P_FileSp_Chk	; else,	check if file special character
		jnz	short $P_FileF03 ; if yes
		mov	[cs:$P_err_flag], 1 ; $P_error_filespec	; bad char.
		pop	si
		mov	[byte ptr cs:si], 0 ; $P_NULL
		pop	di
		jmp	short $P_FileF02
; ---------------------------------------------------------------------------

$P_FileF_Err:				; ...
		pop	si
		mov	[byte ptr cs:si], 0 ; $P_NULL
		pop	di
		test	[word ptr es:bx], 1 ; [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
		jnz	short $P_FileF02 ; optional
		mov	[cs:$P_RC], 2	; $P_Op_Missing
		jmp	short $P_FileF02
; ---------------------------------------------------------------------------

$P_FileF03:				; ...
		pop	ax		; discard save si
		push	si		; save new si

$P_FileF_Loop1:				; ...
		mov	al, [cs:si]	; load character (not special char)
		or	al, al		; end of line ?
		jz	short $P_FileF_RLT ; yes
		call	$P_FileSp_Chk	; File special character ?
		jz	short $P_FileF00
		call	$P_Chk_DBCS	; no, then DBCS	?
		jnb	short $P_FileF01
		inc	di		; if yes, skip next byte
		inc	si

$P_FileF01:				; ...
		inc	di
		inc	si
		jmp	short $P_FileF_Loop1
; ---------------------------------------------------------------------------

$P_FileF00:				; ...
		mov	[cs:$P_Terminator], al
		mov	[byte ptr cs:si], 0 ; $P_NULL ;	update end of string
		inc	di
		mov	[cs:$P_SI_Save], di ; update next pointer in command line

$P_FileF_RLT:				; ...
		pop	si
		pop	di

$P_FileF02:				; ...
		pop	ax
		test	ax, 200h	; $P_File_Spc
		jz	short $P_Drv_Only_Exit
		push	ax
		mov	ax, 0FF05h	; ($P_No_Tag<<8)+$P_File_Spec
		call	$P_Fill_Result
		pop	ax

$P_Drv_Only_Exit:			; ...
		retn
endp		$P_File_Format


; =============== S U B	R O U T	I N E =======================================


proc		$P_FileSp_Chk near	; ...
		push	bx
		push	cx
		lea	bx, [$P_FileSp_Char] ; "[]|<>+=;\""
		mov	cx, 9		; $P_FileSp_Len

$P_FileSp_Loop:				; ...
		cmp	al, [cs:bx]
		jz	short $P_FileSp_Exit
		inc	bx
		loop	$P_FileSp_Loop
		inc	cx

$P_FileSp_Exit:				; ...
		pop	cx
		pop	bx
		retn
endp		$P_FileSp_Chk


; =============== S U B	R O U T	I N E =======================================


proc		$P_Drive_Format	near	; ...
		push	ax
		push	dx
		mov	al, [cs:si]
		or	al, al
		jz	short $P_Drv_Exit
		call	$P_Chk_DBCS
		jb	short $P_Drv_Err
		cmp	[word ptr cs:si+1], ':' ; $P_Colon
		jz	short $P_DrvF00
		test	[word ptr es:bx], 10h ;	$P_Ig_Colon
		jz	short $P_Drv_Err
		cmp	[byte ptr cs:si+1], 0 ;	$P_NULL
		jnz	short $P_Drv_Err

$P_DrvF00:				; ...
		or	al, 20h		; $P_Make_Lower
		cmp	al, 61h	; 'a'
		jb	short $P_Drv_Err
		cmp	al, 7Ah	; 'z'
		ja	short $P_Drv_Err
		sub	al, 60h	; '`'   ; "a"-1
		mov	dl, al
		mov	ah, 0FFh	; $P_No_Tag
		mov	al, 6		; $P_Drive
		call	$P_Fill_Result
		jmp	short $P_Drv_Exit
; ---------------------------------------------------------------------------

$P_Drv_Err:				; ...
		mov	[cs:$P_RC], 9	; $P_Syntax

$P_Drv_Exit:				; ...
		pop	dx
		pop	ax
		retn
endp		$P_Drive_Format


; =============== S U B	R O U T	I N E =======================================


proc		$P_Skip_Delim near	; ...
		lodsb
		call	$P_Chk_EOL
		jz	short $P_Skip_Delim_CY
		call	$P_Chk_Delim
		jnz	short $P_Skip_Delim_NCY
		test	[cs:$P_Flags2],	20h ; $P_Extra
		jz	short $P_Skip_Delim
		test	[cs:$P_Flags2],	41h ; $P_SW+$P_equ
		jz	short $P_Exit_At_Extra
		dec	si
		jmp	short $P_Exit_At_Extra
; ---------------------------------------------------------------------------

$P_Skip_Delim_CY:			; ...
		stc			; indicate EOL
		jmp	short $P_Skip_Delim_Exit
; ---------------------------------------------------------------------------

$P_Skip_Delim_NCY:			; ...
		clc			; indicate non delim

$P_Skip_Delim_Exit:			; ...
		dec	si
		retn
; ---------------------------------------------------------------------------

$P_Exit_At_Extra:			; ...
		clc			; indicate extra delim
		retn
endp		$P_Skip_Delim


; =============== S U B	R O U T	I N E =======================================


proc		$P_Chk_EOL near		; ...
		push	bx
		push	cx
		cmp	al, 0Dh		; $P_CR
		jz	short $P_Chk_EOL_Exit
		cmp	al, 0		; $P_NULL
		jz	short $P_Chk_EOL_Exit
		cmp	[byte ptr es:di+2], 2 ;	[es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_EOL
		jb	short $P_Chk_EOL_Exit
		xor	bx, bx
		mov	bl, [es:di+3]	; [es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
		add	bx, 4		; $P_Len_PARMS
		cmp	[byte ptr es:bx+di], 0 ; $P_I_Use_Default
		jz	short $P_Chk_EOL_NZ
		xor	cx, cx
		mov	cl, [es:bx+di]

$P_Chk_EOL_Loop:			; ...
		inc	bx
		cmp	al, [es:bx+di]
		jz	short $P_Chk_EOL_Exit
		loop	$P_Chk_EOL_Loop

$P_Chk_EOL_NZ:				; ...
		cmp	al, 0Dh		; $P_CR

$P_Chk_EOL_Exit:			; ...
		pop	cx
		pop	bx
		retn
endp		$P_Chk_EOL


; =============== S U B	R O U T	I N E =======================================


proc		$P_Chk_Delim near	; ...
		push	bx
		push	cx
		mov	[cs:$P_Terminator], 20h	; ' ' ; $P_Space
		and	[cs:$P_Flags2],	0DFh ; 0FFh-$P_Extra
		cmp	al, 20h	; ' '   ; $P_Space
		jz	short $P_Chk_Delim_Exit
		cmp	al, 9		; $P_TAB
		jz	short $P_Chk_Delim_Exit
		cmp	al, 2Ch	; ','   ; $P_Comma
		jz	short $P_Chk_Delim_Exit0
		cmp	al, 20h	; ' '   ; $P_DBSP1
		jnz	short $P_Chk_Delim01
		cmp	[byte ptr si], 20h ; ' ' ; $P_DBSP2
		jnz	short $P_Chk_Delim01
		mov	al, 20h	; ' '   ; $P_Space
		inc	si
		cmp	al, al
		jmp	short $P_Chk_Delim_Exit
; ---------------------------------------------------------------------------

$P_Chk_Delim01:				; ...
		cmp	[byte ptr es:di+2], 1 ;	[es:di+$P_PARMS_BLK.$P_Num_Extra],
					; $P_I_Have_Delim
		jb	short $P_Chk_Delim_Exit
		xor	cx, cx
		mov	cl, [es:di+3]	; [es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
		jcxz	short $P_Chk_Delim_NZ
		mov	bx, 3

$P_Chk_Delim_Loop:			; ...
		inc	bx
		cmp	al, [es:bx+di]
		jz	short $P_Chk_Delim_Exit0
		loop	$P_Chk_Delim_Loop

$P_Chk_Delim_NZ:			; ...
		cmp	al, 20h	; ' '   ; $P_Space

$P_Chk_Delim_Exit:			; ...
		pop	cx
		pop	bx
		retn
; ---------------------------------------------------------------------------

$P_Chk_Delim_Exit0:			; ...
		mov	[cs:$P_Terminator], al
		test	[cs:$P_Flags2],	1 ; $P_equ ; if	terminating a key=
		jnz	short $P_No_Set_Extra ;	then do	not set	the EXTRA bit
		or	[cs:$P_Flags2],	20h ; $P_Extra
					; flag terminated extra	delimiter or comma

$P_No_Set_Extra:			; ...
		cmp	al, al
		jmp	short $P_Chk_Delim_Exit
endp		$P_Chk_Delim


; =============== S U B	R O U T	I N E =======================================


proc		$P_Chk_Switch near	; ...
		lea	bp, [$P_STRING_BUF] ; AL = character code
					; BX = current pointer within $P_String_Buf
					; SI = next char on command line (following the	one in AL)
		cmp	bx, bp
		jz	short $P_STRUC_L2
		cmp	al, 2Fh	; '/'   ; $P_Switch
		jnz	short $P_STRUC_L5
		stc
		push	ax
		mov	al, [cs:bx-1]	; AL=char before the current char
		call	$P_0099		; return carry set if not numeric
		jb	short $P_STRUC_L7
		mov	al, [si]	; AL=char after	the current char
		call	$P_0099

$P_STRUC_L7:				; ...
		pop	ax
		retn
; ---------------------------------------------------------------------------

$P_STRUC_L5:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

$P_STRUC_L2:				; ...
		cmp	al, 2Fh	; '/'   ; $P_Switch
		jnz	short $P_STRUC_L12
		or	[cs:$P_Flags2],	40h ; $P_SW
					; could	be valid switch, first char and	is slash

$P_STRUC_L12:				; ...
		clc
		retn
endp		$P_Chk_Switch


; =============== S U B	R O U T	I N E =======================================


proc		$P_Chk_DBCS near	; ...
		push	ds		; AL = Code to be examined
		push	si
		push	bx
		cmp	[cs:$P_DBCSEV_SEG], 0
		jnz	short $P_DBCS00	; ALREADY SET
		push	ax
		push	ds
		push	cx
		push	dx
		push	di
		push	bp
		push	es
		xor	si, si
		mov	ds, si
		assume ds:RESGROUP
		mov	ax, 6300h
		int	21h		; DOS -	3.2+ only - GET	DOUBLE BYTE CHARACTER SET LEAD TABLE
		mov	bx, ds
		or	bx, bx
		pop	es
		pop	bp
		pop	di
		pop	dx
		pop	cx
		pop	ds
		assume ds:nothing
		pop	ax
		jz	short $P_NON_DBCS
		mov	[cs:$P_DBCSEV_OFF], si
		mov	[cs:$P_DBCSEV_SEG], bx

$P_DBCS00:				; ...
		lds	si, [dword ptr cs:$P_DBCSEV_OFF]

$P_DBCS_LOOP:				; ...
		cmp	[word ptr si], 0
		jz	short $P_NON_DBCS
		cmp	al, [si]
		jb	short $P_DBCS01
		cmp	al, [si+1]
		ja	short $P_DBCS01
		stc			; indicate DBCS
		jmp	short $P_DBCS_EXIT
; ---------------------------------------------------------------------------

$P_DBCS01:				; ...
		inc	si
		inc	si
		jmp	short $P_DBCS_LOOP
; ---------------------------------------------------------------------------

$P_NON_DBCS:				; ...
		clc			; indicate SBCS

$P_DBCS_EXIT:				; ...
		pop	bx
		pop	si
		pop	ds
		retn
endp		$P_Chk_DBCS


; =============== S U B	R O U T	I N E =======================================


proc		cmd_parse near		; ...
		call	sysparse
		retn
endp		cmd_parse

; ---------------------------------------------------------------------------

append_parse:				; ...
		call	sysparse
		retf
; ---------------------------------------------------------------------------

Printf_Init:				; ...
		call	std_printf
		retf

; =============== S U B	R O U T	I N E =======================================


proc		Printf_Crlf near	; ...
		call	std_printf
		call	CRLF2
		retn
endp		Printf_Crlf


; =============== S U B	R O U T	I N E =======================================


proc		std_eprintf near	; ...
		mov	[ds:PRINTF_HANDLE], 2
		jmp	short new_printf
endp		std_eprintf


; =============== S U B	R O U T	I N E =======================================


proc		std_printf near		; ...
		mov	[ds:PRINTF_HANDLE], 1 ;	Print to STDOUT

new_printf:				; ...
		push	ax
		push	bx
		push	cx
		push	es
		push	ds
		pop	es
		push	di
		push	si
		push	dx
		mov	[ds:print_err_flag], 0 ; word [print_err_flag]
		mov	si, dx
		lodsw
		push	ax
		lodsb
		mov	cl, al
		xor	ch, ch
		pop	ax
		cmp	cx, 0
		jz	short ready_to_print
		mov	di, offset subst_buffer
		push	di
		push	cx

move_subst:				; ...
		push	cx
		mov	bx, si
		mov	cx, 11		; parm_block_size
		rep movsb
		test	[byte ptr bx+7], 4 ; [bx+$M_SUBLIST_STRUC.$M_S_FLAG],date_type
		jz	short move_subst_cont
		mov	[word ptr bx+2], 0 ; [bx+$M_SUBLIST_STRUC.$M_S_VALUE]
		mov	[word ptr bx+4], 0 ; [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2]

move_subst_cont:			; ...
		pop	cx
		loop	move_subst
		pop	cx
		push	ax
		cmp	[ds:msg_disp_class], 0FFh ; util_msg_class
		jz	short check_fix
		mov	[ds:msg_flag], 1
		mov	di, offset extend_buf_ptr
		xor	ax, ax
		stosw
		stosb

check_fix:				; ...
		pop	ax
		pop	di
		mov	si, di
		mov	bx, si
		push	cx

set_subst:				; ...
		cmp	[word ptr bx+4], 0 ; [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2]
		jnz	short subst_seg_set
		test	[byte ptr bx+7], 4 ; [bx+$M_SUBLIST_STRUC.$M_S_FLAG],date_type
		jnz	short subst_seg_set
		mov	[word ptr bx+4], cs

subst_seg_set:				; ...
		add	bx, 11		; parm_block_size
		loop	set_subst
		pop	cx
		mov	bx, si
		cmp	[word ptr bx+2], offset	string_ptr_2 ;
					; [bx+$M_SUBLIST_STRUC.$M_S_VALUE],string_ptr_2
		jnz	short ready_to_print
		mov	dx, [ds:string_ptr_2]
		mov	[bx+2],	dx

ready_to_print:				; ...
		mov	bx, [ds:PRINTF_HANDLE] ; get print handle
		mov	dl, [ds:msg_cont_flag] ; set up	control	flag
		mov	dh, [ds:msg_disp_class]	; set up display class
		mov	[ds:msg_cont_flag], 0 ;	no_cont_flag ; reset flags to avoid
		mov	[ds:msg_disp_class], 0FFh ; util_msg_class
		push	ds
		push	es
		call	SYSDISPMSG
		pop	es
		pop	ds
		jnb	short print_success
		mov	[ds:print_err_flag], ax

print_success:				; ...
		pop	dx
		pop	si
		pop	di
		pop	es
		pop	cx
		pop	bx
		pop	ax
		cmp	[ds:print_err_flag], 0 ; if an error occurred
		jnz	short print_err	; handle it
		retn
; ---------------------------------------------------------------------------

print_err:				; ...
		push	cs
		pop	es
		assume es:TRANGROUP
		cmp	[ds:PRINTF_HANDLE], 2 ;	Print to STDERR?
		jnz	short not_stderr ; no -	continue
		jmp	TCOMMAND	; Yes -	hopless	- just exit
; ---------------------------------------------------------------------------

not_stderr:				; ...
		mov	ax, [ds:print_err_flag]
		mov	es, [ds:RESSEG]
		assume es:nothing
		test	[es:PipeFlag], 0FFh ; -1
		jz	short _go_to_error
		call	PipeOff
		mov	dx, offset PIPEEMES_PTR
		jmp	short print_err_exit
; ---------------------------------------------------------------------------

_go_to_error:				; ...
		mov	[ds:msg_disp_class], 1 ; ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	[ds:extend_buf_ptr], ax	; get msg num in control block

print_err_exit:				; ...
		push	cs
		pop	es
		assume es:TRANGROUP
		jmp	cerror
endp		std_printf


; =============== S U B	R O U T	I N E =======================================


proc		TSYSLOADMSG near	; ...
		push	bx
		call	SYSLOADMSG
		pop	bx
		retn
endp		TSYSLOADMSG


; =============== S U B	R O U T	I N E =======================================


proc		TSYSGETMSG near		; ...
		push	cx
		call	SYSGETMSG
		pop	cx
		retn
endp		TSYSGETMSG


; =============== S U B	R O U T	I N E =======================================


proc		SYSLOADMSG near		; ...
		push	ax
		push	bx
		push	dx
		push	es
		push	di
		xor	cx, cx
		mov	es, cx
		assume es:RESGROUP
		xor	di, di
		mov	ax, 122Eh	; DOS_GET_EXT_PARSE_ADD
		mov	dl, 0		; DOS_GET_EXTENDED
		int	2Fh		; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
					; DL = subfunction - get standard DOS error table (errors 00h-12h,50h-5Bh)
					; Return: ES:DI	-> error table
		mov	[ds:$M_RT_$M_EXT_COMMAND+2], es	; [$M_RT+$M_RES_ADDRS.$M_EXT_COMMAND+2]
		mov	[ds:$M_RT_$M_EXT_COMMAND], di
		mov	ax, 122Eh
		mov	dl, 2		; DOS_GET_PARSE
		int	2Fh		; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
					; DL = subfunction - get parameter error table (errors 00h-0Ah)
					; ES:DI	-> error table
		mov	[ds:$M_RT_$M_PARSE_COMMAND+2], es ; [$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND+2]
		mov	[ds:$M_RT_$M_PARSE_COMMAND], di
		mov	ax, 122Eh
		mov	dl, 4		; DOS_GET_CRITICAL
		int	2Fh		; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
					; DL = subfunction - get critical/SHARE	error table (errors 13h-2Bh)
					; ES:DI	-> error table
		mov	[ds:$M_RT_$M_CRIT_COMMAND+2], es ; [$M_RT+$M_RES_ADDRS.$M_CRIT_COMMAND+2]
		mov	[ds:$M_RT_$M_CRIT_COMMAND], di
		mov	ax, 122Eh
		mov	dl, 6		; DOS_GET_FILE
		int	2Fh		; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
					; DL = subfunction - get ??? error table
					; ES:DI	-> error table
		mov	[ds:$M_RT_$M_EXT_FILE+2], es ; [$M_RT+$M_RES_ADDRS.$M_EXT_FILE+2]
		mov	[ds:$M_RT_$M_EXT_FILE],	di
		call	$M_MSGSERV_1	; Get addressibility to	MSGSERV	CLASS 1	(EXTENDED Errors)
		mov	[ds:$M_RT_$M_EXT_ERR_ADDRS+2], es ; [$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS+2]
		mov	[ds:$M_RT_$M_EXT_ERR_ADDRS], di
		mov	[ds:$M_RT_$M_CRIT_ADDRS+2], es ; [$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS+2]
		mov	[ds:$M_RT_$M_CRIT_ADDRS], di
		call	$M_MSGSERV_2	; Get addressibility to	MSGSERV	CLASS 2	(PARSE Errors)
		mov	[ds:$M_RT_$M_PARSE_ADDRS+2], es	; [$M_RT+$M_RES_ADDRS.$M_PARSE_ADDRS+2]
		mov	[ds:$M_RT_$M_PARSE_ADDRS], di
		mov	ax, 122Eh
		mov	dl, 8		; DOS_GET_ADDR
		int	2Fh		; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
					; DL = subfunction - get ??? error table
					; Return: ES:DI	-> error table
		mov	[word ptr ds:$M_RT_$M_DISK_PROC_ADDR+2], es ; [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR+2]
		mov	[word ptr ds:$M_RT_$M_DISK_PROC_ADDR], di
		mov	[word ptr ds:$M_RT_$M_CRLF], 0A0Dh ; [$M_RT+$M_RES_ADDRS.$M_CRLF]
		mov	[ds:$M_RT_$M_BUF_TERM],	24h ; '$' ; [$M_RT+$M_RES_ADDRS.$M_BUF_TERM]
		mov	[ds:$M_RT_$M_MSG_NUM], 0 ; [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],$M_NULL
		mov	[ds:$M_RT_$M_DIVISOR], 10 ; [$M_RT+$M_RES_ADDRS.$M_DIVISOR],$M_BASE10
		call	$M_CLS_3	; Get addressibility to	class F	; Build	all utility classes
		mov	[word ptr ds:$M_RT_$M_CLASS_ADDRS], di ; [$M_RT+$M_RES_ADDRS.$M_CLASS_ADDRS]
		call	$M_GET_DBCS_VEC
		clc
		jb	short $MIF20
		pop	di
		pop	es
		assume es:nothing
		pop	dx
		pop	bx
		pop	ax
		retn
; ---------------------------------------------------------------------------

$MIF20:					; ...
		add	sp, 10
		stc
		retn
endp		SYSLOADMSG


; =============== S U B	R O U T	I N E =======================================


proc		$M_GET_DBCS_VEC	near	; ...
		push	ax
		push	si
		push	ds
		mov	ax, 6300h	; DOS_GET_DBCS_INFO
		int	21h		; DOS -	3.2+ only - GET	DOUBLE BYTE CHARACTER SET LEAD TABLE
		push	ds
		pop	es
		pop	ds
		jb	short $MIF23
		mov	[ds:$M_RT_$M_DBCS_VEC],	si ; [$M_RT+60]
		mov	[ds:$M_RT_$M_DBCS_VEC+2], es ; [$M_RT+62]

$MIF23:					; ...
		pop	si
		pop	ax
		retn
endp		$M_GET_DBCS_VEC


; =============== S U B	R O U T	I N E =======================================


proc		SYSGETMSG near		; ...
		push	ax
		push	es
		push	di
		push	bp
		call	$M_GET_MSG_ADDRESS
		jb	short $MIF31
		cmp	dh, 0FFh	; utility_msg_class
		clc
		jz	short $MIF32
		push	es
		pop	ds
		jmp	short $MEN32
; ---------------------------------------------------------------------------

$MIF32:					; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP

$MEN32:					; ...
		mov	si, di

$MIF31:					; ...
		pop	bp
		pop	di
		pop	es
		pop	ax
		retn
endp		SYSGETMSG


; =============== S U B	R O U T	I N E =======================================


proc		$M_GET_MSG_ADDRESS near	; ...

; FUNCTION CHUNK AT 58C6 SIZE 00000007 BYTES

		push	si
		push	bx
		xor	si, si
		xor	cx, cx

$MDO36:					; ...
		cmp	dh, 0FFh	; utility_msg_class
		jnz	short $MIF37
		mov	di, [word ptr $M_RT_$M_CLASS_ADDRS+si] ;
					; [si+$M_RT+$M_RES_ADDRS.$M_CLASS_ADDRS]
		mov	bx, di
		jmp	short $MEN37
; ---------------------------------------------------------------------------

$MIF37:					; ...
		test	dh, 2		; parse_err_class
		jz	short $MIF39
		les	di, [dword ptr $M_RT_$M_PARSE_COMMAND+si] ;
					; [si+$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND]
		mov	bx, es
		jmp	short $MEN37
; ---------------------------------------------------------------------------

$MIF39:					; ...
		cmp	ax, 19		; $M_CRIT_LO
		jb	short $MIF41
		cmp	ax, 39		; $M_CRIT_HI
		ja	short $MIF41
		les	di, [dword ptr $M_RT_$M_CRIT_ADDRS+si] ;
					; [si+$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS]
		mov	bx, es
		jmp	short $MEN37
; ---------------------------------------------------------------------------

$MIF41:					; ...
		les	di, [dword ptr $M_RT_$M_EXT_ERR_ADDRS+si] ;
					; [si+$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS]
		mov	bx, es

$MEN37:					; ...
		cmp	bx, 0FFFFh	; -1 ; $M_TERMINATING_FLAG
		jnz	short $MIF46
		cmp	dh, 0FFh	; utility_msg_class
		jnz	short $MIF47
		stc
		jmp	short $MEN47
; ---------------------------------------------------------------------------

$MIF47:					; ...
		mov	[$M_RT_$M_MSG_NUM], ax ; [$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
		mov	ax, 0FFFFh	; $M_SPECIAL_MSG_NUM
		mov	bp, 1		; $M_ONE_REPLACE
		xor	si, si
		clc

$MEN47:					; ...
		jmp	short $MEN46
; ---------------------------------------------------------------------------

$MIF46:					; ...
		cmp	bx, 0		; $M_CLASS_NOT_EXIST
		jz	short $MIF51
		call	$M_FIND_SPECIFIED_MSG

$MIF51:					; ...
		add	si, 4		; $M_ADDR_SZ_FAR
		clc

$MEN46:					; ...
		jb	short $MEN36
		or	cx, cx
		jnz	short $MEN36
		jmp	short $MDO36
; ---------------------------------------------------------------------------

$MEN36:					; ...
		pushf
		cmp	dh, 1		; EXT_ERR_CLASS
		jnz	short $MIF56
		push	dx
		push	bp
		push	cx
		push	es
		push	di
		push	ax
		mov	ax, 500h	; IFSFUNC_INSTALL_CHECK
		int	2Fh		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
					; Return: AL = 00h not installed, OK to	install
					; 01h not installed, can't install
					; FFh installed
		cmp	al, 0FFh	; IFSFUNC_INSTALLED
		pop	ax
		jnz	short $MIF57
		xchg	ax, bx
		mov	ax, 502h	; IFS_GET_ERR_TEXT
		int	2Fh		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
		jmp	short $MEN57
; ---------------------------------------------------------------------------

$MIF57:					; ...
		stc

$MEN57:					; ...
		jnb	short $MIF60
		pop	di
		pop	es
		pop	cx
		jmp	short $MEN60
; ---------------------------------------------------------------------------

$MIF60:					; ...
		add	sp, 6
		call	$M_SET_LEN_IN_CX

$MEN60:					; ...
		pop	bp
		pop	dx

$MIF56:					; ...
		jmp	short $M_MYRET
endp		$M_GET_MSG_ADDRESS


; =============== S U B	R O U T	I N E =======================================


proc		m_popf_iret far		; ...
		iret
endp		m_popf_iret

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $M_GET_MSG_ADDRESS

$M_MYRET:				; ...
		push	cs
		call	near ptr m_popf_iret
		pop	bx
		pop	si
		retn
; END OF FUNCTION CHUNK	FOR $M_GET_MSG_ADDRESS

; =============== S U B	R O U T	I N E =======================================


proc		$M_SET_LEN_IN_CX near	; ...
		push	di
		push	ax
		mov	cx, 0FFFFh
		xor	al, al
		repne scasb
		not	cx
		dec	cx
		pop	ax
		pop	di
		retn
endp		$M_SET_LEN_IN_CX


; =============== S U B	R O U T	I N E =======================================


proc		$M_FIND_SPECIFIED_MSG near ; ...
		cmp	bx, 1
		jnz	short $MIF64
		cmp	[word ptr $M_RT_$M_DISK_PROC_ADDR], 0FFFFh ;
					; [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR],-1
		jz	short $MIF64
		cmp	ax, 0FFFFh	; -1
		jnz	short $MIF65
		push	ax
		mov	ax, [$M_RT_$M_MSG_NUM] ; [$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
		call	[$M_RT_$M_DISK_PROC_ADDR] ;
					; call far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]
		pop	ax
		jmp	short $MEN65
; ---------------------------------------------------------------------------

$MIF65:					; ...
		call	[$M_RT_$M_DISK_PROC_ADDR] ;
					; call far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]

$MEN65:					; ...
		jmp	short $MEN64
; ---------------------------------------------------------------------------

$MIF64:					; ...
		xor	cx, cx
		cmp	dh, 0FFh	; utility_msg_class ; -1
		jz	short $MIF69
		mov	cl, [es:di+3]	; [es:di+$M_CLASS_ID.$M_NUM_CLS_MSG]
		jmp	short $MEN69
; ---------------------------------------------------------------------------

$MIF69:					; ...
		cmp	[cs:di], dh	; [cs:di+$M_CLASS_ID.$M_CLS_ID]
		jnz	short $MEN69
		mov	cl, [cs:di+3]	; [cs:di+$M_CLASS_ID.$M_NUM_CLS_MSG]

$MEN69:					; ...
		add	di, 4		; $M_CLASS_ID_SZ
		stc

$MEN64:					; ...
		jnb	short $MIF75
		clc

$MDO76:					; ...
		or	cx, cx
		jz	short $MEN76
		cmp	dh, 0FFh	; utility_msg_class
		jz	short $MIF78
		cmp	ax, [es:di]	; [es:di+$M_ID.$M_NUM]
		jmp	short $MEN78
; ---------------------------------------------------------------------------

$MIF78:					; ...
		cmp	ax, [cs:di]	; [cs:di+$M_ID.$M_NUM]

$MEN78:					; ...
		jnz	short $MIF76
		jmp	short $MSR76
; ---------------------------------------------------------------------------

$MIF76:					; ...
		dec	cx
		jz	short $MEN76
		add	di, 4		; $M_ID_SZ
		jmp	short $MDO76
; ---------------------------------------------------------------------------

$MEN76:					; ...
		stc

$MSR76:					; ...
		jb	short $MIF75
		cmp	dh, 0FFh	; utility_msg_class
		clc
		jnz	short $MIF87
		push	cs
		pop	es
		assume es:TRANGROUP

$MIF87:					; ...
		add	di, [es:di+2]	; [es:di+$M_ID.$M_TXT_PTR]

$MIF75:					; ...
		jb	short $MIF91
		xor	ch, ch
		mov	cl, [es:di]
		inc	di

$MIF91:					; ...
		mov	[$M_RT_$M_SIZE], 0 ; [$M_RT+$M_RES_ADDRS.$M_SIZE]
		retn
endp		$M_FIND_SPECIFIED_MSG


; =============== S U B	R O U T	I N E =======================================


proc		SYSDISPMSG near		; ...
		push	ax
		push	bx
		push	cx
		push	bp
		push	di
		push	es
		push	dx
		mov	bp, cx
		mov	[$M_RT_$M_HANDLE], bx ;	[$M_RT+$M_RES_ADDRS.$M_HANDLE]
		mov	[$M_RT_$M_CLASS], dh ; [$M_RT+$M_RES_ADDRS.$M_CLASS]
		call	$M_GET_MSG_ADDRESS
		or	cx, cx
		jz	short $MIF93
		or	bp, bp
		jnz	short $MIF94
		call	$M_DISPLAY_STRING
		jmp	short $MEN94
; ---------------------------------------------------------------------------

$MIF94:					; ...
		call	$M_DISPLAY_MESSAGE

$MEN94:					; ...
		jb	short $MIF97
		pop	dx
		call	$M_ADD_CRLF
		pop	es
		assume es:nothing
		pop	di
		or	dl, dl
		jz	short $MIF98
		call	$M_WAIT_FOR_INPUT

$MIF98:					; ...
		jmp	short $MEN97
; ---------------------------------------------------------------------------

$MIF97:					; ...
		add	sp, 6
		stc

$MEN97:					; ...
		jmp	short $MEN93
; ---------------------------------------------------------------------------

$MIF93:					; ...
		pop	es
		pop	di
		pop	dx
		stc

$MEN93:					; ...
		jb	short $MIF104
		pop	bp
		pop	cx
		pop	bx
		add	sp, 2
		jmp	short $MEN104
; ---------------------------------------------------------------------------

$MIF104:				; ...
		add	sp, 8
		stc

$MEN104:				; ...
		retn
endp		SYSDISPMSG


; =============== S U B	R O U T	I N E =======================================


proc		$M_DISPLAY_STRING near	; ...
		push	ax
		push	bx
		push	dx
		mov	bx, [$M_RT_$M_HANDLE] ;	[$M_RT+$M_RES_ADDRS.$M_HANDLE]
		cmp	bx, 0FFFFh	; $M_NO_HANDLE
		jnz	short $MIF107
		call	$M_DISPLAY_$_STRING
		jmp	short $MEN107
; ---------------------------------------------------------------------------

$MIF107:				; ...
		call	$M_DISPLAY_H_STRING

$MEN107:				; ...
		jnb	short $MIF110
		mov	ah, 59h		; DOS_GET_EXT_ERROR
		mov	bx, 0
		int	21h		; DOS -	3+ - GET EXTENDED ERROR	CODE
					; BX = version code (0000h for DOS 3.x)
		xor	ah, ah
		add	sp, 6
		stc
		jmp	short $MEN110
; ---------------------------------------------------------------------------

$MIF110:				; ...
		cmp	bx, 0FFFFh	; $M_NO_HANDLE
		jz	short $MEN110
		cmp	ax, cx
		jz	short $MEN110
		call	$M_GET_EXT_ERR_39
		add	sp, 6
		stc

$MEN110:				; ...
		jb	short $MIF117
		pop	dx
		pop	bx
		pop	ax

$MIF117:				; ...
		retn
endp		$M_DISPLAY_STRING


; =============== S U B	R O U T	I N E =======================================


proc		$M_DISPLAY_$_STRING near ; ...
		push	ds
		push	es
		pop	ds
		assume ds:nothing
		cmp	cx, 1		; $M_SINGLE_CHAR
		jnz	short $MIF119
		mov	ah, 2		; DOS_DISP_CHAR
		mov	dl, [es:di]
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		pop	ds
		mov	al, dl
		call	$M_IS_IT_DBCS
		push	ds
		push	es
		pop	ds
		jnb	short $MIF120
		mov	dl, [es:di+1]
		int	21h		; DOS -
		clc

$MIF120:				; ...
		jmp	short $MEN119
; ---------------------------------------------------------------------------

$MIF119:				; ...
		mov	ah, 2		; DOS_DISP_CHAR

$MDO123:				; ...
		or	cx, cx
		jz	short $MEN119
		mov	dl, [es:di]
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		inc	di
		loop	$MDO123

$MEN119:				; ...
		clc
		pop	ds
		retn
endp		$M_DISPLAY_$_STRING


; =============== S U B	R O U T	I N E =======================================


proc		scan_ctrlz near		; ...
		push	di
		push	ax
		push	es
		push	bx
		mov	di, dx
		push	ds
		pop	es
		mov	bx, cx
		mov	al, 1Ah		; Ctrl-Z
		cld
		repne scasb
		jnz	short noCtrlZ
		sub	bx, cx
		dec	bx

noCtrlZ:				; ...
		mov	cx, bx
		pop	bx
		pop	es
		pop	ax
		pop	di
		retn
endp		scan_ctrlz


; =============== S U B	R O U T	I N E =======================================


proc		$M_DISPLAY_H_STRING near ; ...

; FUNCTION CHUNK AT 5A61 SIZE 00000006 BYTES

		xor	ax, ax
		or	cx, cx
		jz	short $MIF127
		push	ds
		push	es
		pop	ds
		mov	ah, 40h		; DOS_WRITE_HANDLE
		mov	dx, di
		cmp	cx, 1		; $M_SINGLE_CHAR
		jnz	short $MIF128
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		pop	ds
		push	ax
		mov	al, [es:di]
		call	$M_IS_IT_DBCS
		pop	ax
		push	ds
		push	es
		pop	ds
		jnb	short $MIF129
		clc
		mov	ah, 40h
		inc	dx
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer

$MIF129:				; ...
		pushf
		cmp	[byte ptr es:di], 1Ah ;	is char	a Ctrl-Z?
		jnz	short m_popf_j	; no, continue
		mov	ax, cx

m_popf_j:				; ...
		jmp	short m_popf
endp		$M_DISPLAY_H_STRING


; =============== S U B	R O U T	I N E =======================================


proc		intret far		; ...
		iret
endp		intret

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $M_DISPLAY_H_STRING

m_popf:					; ...
		push	cs
		call	near ptr intret
		jmp	short $MEN128
; END OF FUNCTION CHUNK	FOR $M_DISPLAY_H_STRING
; ---------------------------------------------------------------------------

$MIF128:				; ...
		push	bp
		push	cx
		call	scan_ctrlz
		mov	bp, cx
		pop	cx
		int	21h		; DOS -
		jb	short m_cnt_ok
		cmp	cx, ax
		jz	short m_cnt_ok
		cmp	bp, ax
		clc
		jnz	short m_cnt_ok
		mov	ax, cx

m_cnt_ok:				; ...
		pop	bp

$MEN128:				; ...
		pop	ds

$MIF127:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


proc		$M_GET_EXT_ERR_39 near	; ...
		mov	ax, 27h		; EXT_ERR_39
		mov	bx, 4
		mov	ch, 1
		retn
endp		$M_GET_EXT_ERR_39


; =============== S U B	R O U T	I N E =======================================


proc		$M_ADD_CRLF near	; ...
		cmp	dh, 0FFh	; utility_msg_class
		jz	short $MIF134
		test	dh, 80h		; $M_NO_CRLF_MASK
		jnz	short $MIF134
		push	ds
		pop	es
		lea	di, [$M_RT_$M_CRLF] ; [$M_RT+$M_RES_ADDRS.$M_CRLF]
		mov	cx, 2		; $M_CRLF_SIZE
		call	$M_DISPLAY_STRING

$MIF134:				; ...
		retn
endp		$M_ADD_CRLF


; =============== S U B	R O U T	I N E =======================================


proc		$M_IS_IT_DBCS near	; ...
		push	es
		push	di
		les	di, [dword ptr ds:$M_RT_$M_DBCS_VEC] ;
					; [$M_RT+$M_RES_ADDRS.$M_DBCS_VEC]
		or	di, di
		jz	short $MIF138

$MDO139:				; ...
		cmp	[word ptr es:di], 0 ; $M_DBCS_TERM
		clc
		jz	short $MIF138
		cmp	al, [es:di]
		jb	short $MIF141
		cmp	al, [es:di+1]
		ja	short $MIF141
		stc

$MIF141:				; ...
		inc	di
		inc	di
		jmp	short $MDO139
; ---------------------------------------------------------------------------

$MIF138:				; ...
		pop	di
		pop	es
		retn
endp		$M_IS_IT_DBCS


; =============== S U B	R O U T	I N E =======================================


proc		$M_CONVERT2ASC near	; ...
		pop	[ds:$M_RT_$M_RETURN_ADDR] ; [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
					; Save Return Address
		xor	bx, bx
		xchg	ax, bx
		xchg	ax, dx

$MDO145:				; ...
		div	[ds:$M_RT_$M_DIVISOR] ;	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR]
		xchg	ax, bx
		div	[ds:$M_RT_$M_DIVISOR]
		cmp	dx, 9
		jbe	short $MIF146
		add	dl, 55
		jmp	short $MEN146
; ---------------------------------------------------------------------------

$MIF146:				; ...
		add	dl, '0'

$MEN146:				; ...
		push	dx
		inc	cx
		or	ax, ax
		jnz	short $MLL149
		or	bx, bx
		jz	short $MEN145

$MLL149:				; ...
		cmp	cx, 3		; $M_FIRST_THOU
		jnz	short $MIF150
		cmp	[byte ptr si+0Ah], 2Ch ; ',' ;
					; [si+$M_SUBLIST_STRUC.$M_S_PAD],','
		jnz	short $MIF151
		push	[ds:$M_RT_$M_THOU_SEPARA] ; [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
		inc	cx

$MIF151:				; ...
		jmp	short $MEN150
; ---------------------------------------------------------------------------

$MIF150:				; ...
		cmp	cx, 7		; $M_SECOND_THOU
		jnz	short $MIF153
		cmp	[byte ptr si+0Ah], 2Ch ; ',' ; [si+$M_SUBLIST_STRUC.$M_S_PAD],','
		jnz	short $MIF155
		push	[ds:$M_RT_$M_THOU_SEPARA] ; [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
		inc	cx

$MIF155:				; ...
		jmp	short $MEN150
; ---------------------------------------------------------------------------

$MIF153:				; ...
		cmp	cx, 11		; $M_THIRD_THOU
		jnz	short $MEN150
		cmp	[byte ptr si+0Ah], 2Ch ; ',' ;
					; [si+$M_SUBLIST_STRUC.$M_S_PAD],','
		jnz	short $MEN150
		push	[ds:$M_RT_$M_THOU_SEPARA] ; [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
		inc	cx

$MEN150:				; ...
		xchg	ax, bx
		xor	dx, dx
		jmp	short $MDO145
; ---------------------------------------------------------------------------

$MEN145:				; ...
		xor	ax, ax
		cwd
		push	[ds:$M_RT_$M_RETURN_ADDR] ; [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
					; Restore Return Address
		retn
endp		$M_CONVERT2ASC


; =============== S U B	R O U T	I N E =======================================


proc		$M_DISPLAY_MESSAGE near	; ...
		xor	dx, dx
		or	cx, cx
		jz	short $MEN167
		mov	ax, 2500h	; mov ah,"%" ; mov al,0

$MDO167:				; ...
		cmp	[es:di], ah
		jnz	short $MLL168
		cmp	[es:di+1], ah
		jz	short $MLL168
		cmp	al, ah
		jnz	short $MEN167

$MLL168:				; ...
		mov	al, [es:di]
		call	$M_IS_IT_DBCS
		jnb	short $MIF169
		inc	di

$MIF169:				; ...
		inc	di
		inc	dx
		loop	$MDO167

$MEN167:				; ...
		push	si
		xchg	cx, dx
		or	bp, bp
		jz	short $MIF173
		dec	bp
		cmp	[ds:$M_RT_$M_MSG_NUM], 0 ; [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],$M_NULL
		jnz	short $MIF173

$MDO175:				; ...
		mov	al, [si+6]	; [si+$M_SUBLIST_STRUC.$M_S_ID]
		add	al, 30h	; '0'
		cmp	al, [es:di+1]
		jnz	short $MSR175
		jmp	short $MIF173
; ---------------------------------------------------------------------------

$MSR175:				; ...
		cmp	al, 30h	; '0'   ; $M_SPECIAL_CASE
		jnz	short $MLL178
		or	dx, dx
		jz	short $MEN175

$MLL178:				; ...
		add	si, [si]
		jmp	short $MDO175
; ---------------------------------------------------------------------------

$MEN175:				; ...
		cmp	[ds:$M_RT_$M_CLASS], 0FFh ; [$M_RT+$M_RES_ADDRS.$M_CLASS],
					; utility_msg_class
		jnz	short $MIF180
		inc	dx
		inc	dx
		dec	cx
		dec	cx
		dec	di
		dec	di
		jmp	short $MIF173
; ---------------------------------------------------------------------------

$MIF180:				; ...
		mov	dx, 0FFFFh	; -1

$MIF173:				; ...
		push	di
		sub	di, cx
		call	$M_DISPLAY_STRING
		pop	di
		pop	cx
		jnb	short $MXL3
		jmp	$MEN165
; ---------------------------------------------------------------------------

$MXL3:					; ...
		push	cx
		mov	cx, dx
		cmp	[byte ptr si+6], 0 ; [si+$M_SUBLIST_STRUC.$M_S_ID],
					; $M_SPECIAL_CASE-30h
		jz	short $MIF187
		or	cx, cx
		jz	short $MIF188
		dec	cx
		dec	cx
		inc	di
		inc	di
		jmp	short $MEN188
; ---------------------------------------------------------------------------

$MIF188:				; ...
		pop	si

$MEN188:				; ...
		jmp	short $MEN187
; ---------------------------------------------------------------------------

$MIF187:				; ...
		or	cx, cx
		jnz	short $MIF192
		pop	si
		jmp	short $MEN187
; ---------------------------------------------------------------------------

$MIF192:				; ...
		cmp	cx, 0FFFFh	; -1
		jnz	short $MIF194
		xor	cx, cx

$MIF194:				; ...
		or	di, di

$MEN187:				; ...
		jz	short $MEN165
		push	bp
		push	di
		push	es
		push	cx
		xor	cx, cx
		cmp	[ds:$M_RT_$M_MSG_NUM], 0 ; [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],$M_NULL
		jnz	short $MIF199
		test	[byte ptr si+7], 0Fh ; [si+$M_SUBLIST_STRUC.$M_S_FLAG]
		jnz	short $MIF200
		les	di, [si+2]	; [si+$M_SUBLIST_STRUC.$M_S_VALUE]
		call	$M_CHAR_REPLACE
		jmp	short $MEN202
; ---------------------------------------------------------------------------

$MIF200:				; ...
		test	[byte ptr si+7], 0Dh ; [si+$M_SUBLIST_STRUC.$M_S_FLAG]
					; not Sgn_Bin_Type and $M_TYPE_MASK
		jz	short $MLL202
		test	[byte ptr si+7], 0Eh ; [si+$M_SUBLIST_STRUC.$M_S_FLAG],
					; NOT Unsgn_Bin_Type AND $M_TYPE_MASK
		jz	short $MLL202
		test	[byte ptr si+7], 0Ch ; [si+$M_SUBLIST_STRUC.$M_S_FLAG],
					; not Bin_Hex_Type and $M_TYPE_MASK
		jnz	short $MIF202

$MLL202:				; ...
		les	di, [si+2]	; [si+$M_SUBLIST_STRUC.$M_S_VALUE]
		call	$M_BIN2ASC_REPLACE
		jmp	short $MEN202
; ---------------------------------------------------------------------------

$MIF202:				; ...
		test	[byte ptr si+7], 0Bh ; [si+$M_SUBLIST_STRUC.$M_S_FLAG],
					; not Date_Type	and $M_TYPE_MASK
		jnz	short $MIF204
		call	$M_DATE_REPLACE
		jmp	short $MEN202
; ---------------------------------------------------------------------------

$MIF204:				; ...
		call	$M_TIME_REPLACE

$MEN202:				; ...
		call	$M_DISPLAY_REPLACE
		jmp	short $MEN199
; ---------------------------------------------------------------------------

$MIF199:				; ...
		call	$M_EXT_PAR_REPLACE

$MEN199:				; ...
		jb	short $MIF211
		pop	cx
		pop	es
		pop	di
		pop	bp
		pop	si
		jmp	short $MEN211
; ---------------------------------------------------------------------------

$MIF211:				; ...
		add	sp, 10
		stc
		jmp	short $MEN165
; ---------------------------------------------------------------------------

$MEN211:				; ...
		cmp	[ds:$M_RT_$M_MSG_NUM], 0 ; [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],$M_NULL
		jnz	short $MEN165
		jb	short $MEN165
		jmp	$M_DISPLAY_MESSAGE
; ---------------------------------------------------------------------------

$MEN165:				; ...
		mov	[ds:$M_RT_$M_MSG_NUM], 0 ; [$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
		retn
endp		$M_DISPLAY_MESSAGE


; =============== S U B	R O U T	I N E =======================================


proc		$M_EXT_PAR_REPLACE near	; ...
		xor	dx, dx
		mov	ax, [ds:$M_RT_$M_MSG_NUM] ; [$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
		mov	[ds:$M_RT_$M_DIVISOR], 10 ; [$M_RT+$M_RES_ADDRS.$M_DIVISOR],$M_BASE10
		call	$M_CONVERT2ASC

$MDO215:				; ...
		pop	ax
		mov	[byte ptr ds:$M_RT_$M_TEMP_BUF+bx], al ;
					; [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
		inc	bx
		cmp	bx, 64		; $M_TEMP_BUF_SZ
		jnz	short $MIF216
		call	$M_FLUSH_BUF

$MIF216:				; ...
		dec	cl
		jnz	short $MDO215
		mov	ax, 0A0Dh	; $M_CR_LF
		mov	[ds:$M_RT_$M_TEMP_BUF+bx], ax ;
					; [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
		inc	bx
		inc	bx
		call	$M_FLUSH_BUF
		retn
endp		$M_EXT_PAR_REPLACE


; =============== S U B	R O U T	I N E =======================================


proc		$M_DISPLAY_REPLACE near	; ...
		xor	bx, bx
		cmp	[byte ptr si+6], 0 ; [si+$M_SUBLIST_STRUC.$M_S_ID]
		jnz	short $MIF276
		mov	[ds:$M_RT_$M_TEMP_BUF+bx], 2D20h ;
					; [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],$M_SPACE_HYP
		inc	bx
		inc	bx
		mov	[byte ptr ds:$M_RT_$M_TEMP_BUF+bx], 20h	; ' ' ;
					; [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],$M_SPACE
		inc	bx
		call	$M_FLUSH_BUF

$MIF276:				; ...
		pop	bp
		xor	bx, bx
		xor	dx, dx
		mov	[ds:$M_RT_$M_SIZE], cl ; [$M_RT+$M_RES_ADDRS.$M_SIZE]
		mov	al, [si+9]	; [si+$M_SUBLIST_STRUC.$M_S_MINW]
		cmp	al, cl
		jbe	short $MIF278
		sub	al, cl
		mov	dh, al
		test	[byte ptr si+7], 80h ; [si+$M_SUBLIST_STRUC.$M_S_FLAG]
		jz	short $MIF278

$MDO280:				; ...
		mov	al, [si+0Ah]	; [si+$M_SUBLIST_STRUC.$M_S_PAD]
		mov	[byte ptr ds:$M_RT_$M_TEMP_BUF+bx], al ;
					; [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
		inc	bx
		cmp	bx, 64		; $M_TEMP_BUF_SZ
		jnz	short $MIF281
		call	$M_FLUSH_BUF

$MIF281:				; ...
		dec	dh
		jnz	short $MDO280

$MIF278:				; ...
		cmp	[byte ptr si+8], 0 ; [si+$M_SUBLIST_STRUC.$M_S_MAXW],$M_UNLIM_W
		jz	short $MIF286
		cmp	[si+8],	cl	; [si+$M_SUBLIST_STRUC.$M_S_MAXW]
		jnb	short $MIF286
		sub	cl, [si+8]
		mov	dl, cl
		mov	cl, [si+8]

$MIF286:				; ...
		or	cx, cx
		jz	short $MIF290

$MDO291:				; ...
		test	[byte ptr si+7], 0Fh ; [si+$M_SUBLIST_STRUC.$M_S_FLAG],
					; not Char_Type	not $M_TYPE_MASK
		jnz	short $MIF292
		test	[byte ptr si+7], 10h ; [si+$M_SUBLIST_STRUC.$M_S_FLAG],
					; Char_field_ASCIIZ and	$M_SIZE_MASK
		jz	short $MIF292
		mov	al, [es:di]
		inc	di
		jmp	short $MEN292
; ---------------------------------------------------------------------------

$MIF292:				; ...
		pop	ax

$MEN292:				; ...
		mov	[byte ptr ds:$M_RT_$M_TEMP_BUF+bx], al ;
					; [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
		inc	bx
		cmp	bx, 64		; $M_TEMP_BUF_SZ
		jnz	short $MIF295
		call	$M_FLUSH_BUF

$MIF295:				; ...
		dec	cl
		jnz	short $MDO291

$MIF290:				; ...
		test	[byte ptr si+7], 80h ;
					; [si+$M_SUBLIST_STRUC.$M_S_FLAG],Right_Align
		jnz	short $MIF299
		or	dh, dh
		jz	short $MIF299

$MDO301:				; ...
		mov	al, [si+0Ah]	; [si+$M_SUBLIST_STRUC.$M_S_PAD]
		mov	[byte ptr ds:$M_RT_$M_TEMP_BUF+bx], al ;
					; [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
		inc	bx
		cmp	bx, 64		; $M_TEMP_BUF_SZ
		jnz	short $MIF302
		call	$M_FLUSH_BUF

$MIF302:				; ...
		dec	dh
		jnz	short $MDO301

$MIF299:				; ...
		test	[byte ptr si+7], 0Fh ; [si+$M_SUBLIST_STRUC.$M_S_FLAG],
					; not Char_Type	and $M_TYPE_MASK
		jnz	short $MIF307
		test	[byte ptr si+7], 10h ; [si+$M_SUBLIST_STRUC.$M_S_FLAG],
					; Char_field_ASCIIZ and	$M_SIZE_MASK
		jz	short $MIF307
		jmp	short $MEN307
; ---------------------------------------------------------------------------

$MIF307:				; ...
		or	dl, dl
		jz	short $MEN307

$MDO310:				; ...
		pop	[ds:$M_RT_$M_RETURN_ADDR] ;
					; [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
		dec	dl
		jnz	short $MDO310

$MEN307:				; ...
		call	$M_FLUSH_BUF
		push	bp
		retn
endp		$M_DISPLAY_REPLACE


; =============== S U B	R O U T	I N E =======================================


proc		$M_FLUSH_BUF near	; ...
		push	cx
		push	es
		push	di
		push	ds
		pop	es
		mov	cx, bx
		xor	bx, bx
		lea	di, [$M_RT_$M_TEMP_BUF]	; [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
		call	$M_DISPLAY_STRING
		jb	short $MIF314
		pop	di
		pop	es
		pop	cx
		retn
; ---------------------------------------------------------------------------

$MIF314:				; ...
		add	sp, 6
		stc
		retn
endp		$M_FLUSH_BUF


; =============== S U B	R O U T	I N E =======================================


proc		$M_CHAR_REPLACE	near	; ...
		pop	bp
		test	[byte ptr si+7], 30h ; [si+$M_SUBLIST_STRUC.$M_S_FLAG],
					; not Char_Field_Char and $M_SIZE_MASK
		jnz	short $MIF317
		mov	al, [es:di]
		push	ax
		inc	cx
		call	$M_IS_IT_DBCS
		jnb	short $MIF318
		mov	al, [es:di+1]
		push	ax
		clc

$MIF318:				; ...
		jmp	short $MEN317
; ---------------------------------------------------------------------------

$MIF317:				; ...
		mov	al, [es:di]
		or	al, al
		jz	short $MEN321
		inc	di
		inc	cx
		jmp	short $MIF317
; ---------------------------------------------------------------------------

$MEN321:				; ...
		sub	di, cx

$MEN317:				; ...
		push	bp
		retn
endp		$M_CHAR_REPLACE


; =============== S U B	R O U T	I N E =======================================


proc		$M_BIN2ASC_REPLACE near	; ...
		pop	bp
		xor	ax, ax
		cwd
		mov	[ds:$M_RT_$M_DIVISOR], 16 ; [$M_RT+$M_RES_ADDRS.$M_DIVISOR],
					; $M_BASE16
		xor	bx, bx
		test	[byte ptr si+7], 20h ; [si+$M_SUBLIST_STRUC.$M_S_FLAG],
					; not $M_BYTE and $M_SIZE_MASK
		jnz	short $MIF325
		mov	al, [es:di]
		test	[byte ptr si+7], 0Dh ; [si+$M_SUBLIST_STRUC.$M_S_FLAG],
					; not Sgn_Bin_Type and $M_TYPE_MASK
		jnz	short $MIF326
		test	al, 80h		; Is this number negative?
		jz	short $MIF327	; No
		inc	bx
		and	al, 7Fh		; Make it positive

$MIF327:				; ...
		mov	[ds:$M_RT_$M_DIVISOR], 10 ; [$M_RT+$M_RES_ADDRS.$M_DIVISOR],
					; $M_BASE10

$MIF326:				; ...
		test	[byte ptr si+7], 0Eh ; [si+$M_SUBLIST_STRUC.$M_S_FLAG],
					; not Unsgn_Bin_Type and $M_TYPE_MASK
		jnz	short $MIF330
		mov	[ds:$M_RT_$M_DIVISOR], 10 ; [$M_RT+$M_RES_ADDRS.$M_DIVISOR],
					; $M_BASE10

$MIF330:				; ...
		jmp	short $MEN333
; ---------------------------------------------------------------------------

$MIF325:				; ...
		test	[byte ptr si+7], 10h ; [si+$M_SUBLIST_STRUC.$M_S_FLAG],
					; not $M_WORD and $M_SIZE_MASK
		jnz	short $MIF333
		mov	ax, [es:di]
		test	[byte ptr si+7], 0Dh ; [si+$M_SUBLIST_STRUC.$M_S_FLAG],
					; not Sgn_Bin_Type and $M_TYPE_MASK
		jnz	short $MIF334
		test	ah, 80h		; Is this number negative?
		jz	short $MIF335	; No
		inc	bx
		and	ah, 7Fh		; Make it positive

$MIF335:				; ...
		mov	[ds:$M_RT_$M_DIVISOR], 10 ; [$M_RT+$M_RES_ADDRS.$M_DIVISOR],$M_BASE10

$MIF334:				; ...
		test	[byte ptr si+7], 0Eh ; [si+$M_SUBLIST_STRUC.$M_S_FLAG],
					; not Unsgn_Bin_Type and $M_TYPE_MASK
		jnz	short $MIF338
		mov	[ds:$M_RT_$M_DIVISOR], 10 ; [$M_RT+$M_RES_ADDRS.$M_DIVISOR],$M_BASE10

$MIF338:				; ...
		jmp	short $MEN333
; ---------------------------------------------------------------------------

$MIF333:				; ...
		mov	ax, [es:di]
		mov	dx, [es:di+2]
		test	[byte ptr si+7], 0Dh ; [si+$M_SUBLIST_STRUC.$M_S_FLAG],
					; not Sgn_Bin_Type and $M_TYPE_MASK
		jnz	short $MIF341
		test	dh, 80h		; Is this number negative?
		jz	short $MIF342	; No
		inc	bx
		and	dh, 7Fh		; Make it positive

$MIF342:				; ...
		mov	[ds:$M_RT_$M_DIVISOR], 10 ; [$M_RT+$M_RES_ADDRS.$M_DIVISOR],$M_BASE10

$MIF341:				; ...
		test	[byte ptr si+7], 0Eh ; [si+$M_SUBLIST_STRUC.$M_S_FLAG],
					; not Unsgn_Bin_Type and $M_TYPE_MASK
		jnz	short $MEN333
		mov	[ds:$M_RT_$M_DIVISOR], 10 ; [$M_RT+$M_RES_ADDRS.$M_DIVISOR],$M_BASE10

$MEN333:				; ...
		test	[byte ptr si+7], 40h ; [si+$M_SUBLIST_STRUC.$M_S_FLAG]
					; (Custom/International	flag for thousand separator)
		jz	short $MEN325
		push	ax
		push	dx
		mov	ah, 38h
		xor	al, al
		lea	dx, [$M_RT_$M_TEMP_BUF]	; lea dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
		int	21h		; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
					; get current-country info
					; DS:DX	-> buffer for returned info
		jnb	short $MEN341
		mov	[byte ptr ds:$M_RT_$M_THOU_SEPARA], 2Ch	; ',' ;
					; [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA],','

$MEN341:				; ...
		mov	al, [si+0Ah]	; [si+$M_SUBLIST_STRUC.$M_S_PAD]
		mov	di, ax
		pop	dx
		pop	ax
		mov	[byte ptr si+0Ah], 2Ch ; ',' ; [si+$M_SUBLIST_STRUC.$M_S_PAD],','
		call	$M_CONVERT2ASC
		mov	ax, di
		mov	[si+0Ah], al	; [si+$M_SUBLIST_STRUC.$M_S_PAD],al
		jmp	short $MEN345
; ---------------------------------------------------------------------------

$MEN325:				; ...
		call	$M_CONVERT2ASC

$MEN345:				; ...
		or	bx, bx
		jz	short $MIF349
		mov	dx, '-'         ; $M_NEG_SIGN
		push	dx

$MIF349:				; ...
		push	bp
		retn
endp		$M_BIN2ASC_REPLACE


; =============== S U B	R O U T	I N E =======================================


proc		$M_DATE_REPLACE	near	; ...
		pop	bp
		mov	[ds:$M_RT_$M_DIVISOR], 10
		call	$M_GET_DATE
		xor	ax, ax
		cwd
		cmp	[ds:$M_RT_$M_TEMP_BUF],	0 ; [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT]
		jnz	short $MIF351
		call	$M_YEAR
		call	$M_CONVERTDATE
		push	[ds:$M_RT_$M_DATE_SEPARA]
		inc	cx
		xor	ax, ax
		mov	al, [si+5]
		call	$M_CONVERTDATE
		push	[ds:$M_RT_$M_DATE_SEPARA]
		inc	cx
		mov	al, [si+4]	; [si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
		call	$M_CONVERTDATE

$MIF351:				; ...
		cmp	[ds:$M_RT_$M_TEMP_BUF],	1 ; [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT]
		jnz	short $MIF353
		call	$M_YEAR
		call	$M_CONVERTDATE
		push	[ds:$M_RT_$M_DATE_SEPARA]
		inc	cx
		xor	ax, ax
		mov	al, [si+4]
		call	$M_CONVERTDATE
		push	[ds:$M_RT_$M_DATE_SEPARA]
		inc	cx
		mov	al, [si+5]	; [si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
		call	$M_CONVERTDATE

$MIF353:				; ...
		cmp	[ds:$M_RT_$M_TEMP_BUF],	2 ; [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT]
		jnz	short $MIF355
		mov	al, [si+5]	; [si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
		call	$M_CONVERTDATE
		push	[ds:$M_RT_$M_DATE_SEPARA]
		inc	cx
		mov	al, [si+4]	; [si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
		call	$M_CONVERTDATE
		push	[ds:$M_RT_$M_DATE_SEPARA] ;
					; [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
		inc	cx
		call	$M_YEAR
		call	$M_CONVERTDATE

$MIF355:				; ...
		push	bp
		retn
endp		$M_DATE_REPLACE


; =============== S U B	R O U T	I N E =======================================


proc		$M_GET_DATE near	; ...
		mov	ax, 3800h	; DOS_GET_COUNTRY*256
		lea	dx, [$M_RT_$M_TEMP_BUF]	; [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
		int	21h		; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
					; get current-country info
					; DS:DX	-> buffer for returned info
		jnb	short $MIF357
		mov	[ds:$M_RT_$M_TEMP_BUF],	0 ; [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],0
		mov	[byte ptr ds:$M_RT_$M_DATE_SEPARA], 2Dh	; '-' ;
					; [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA],'-'

$MIF357:				; ...
		retn
endp		$M_GET_DATE


; =============== S U B	R O U T	I N E =======================================


proc		$M_YEAR	near		; ...
		mov	ax, [si+2]	; [si+$M_SUBLIST_STRUC.$M_S_VALUE]
		test	[byte ptr si+7], 10h ; [si+$M_SUBLIST_STRUC.$M_S_FLAG],
					; Date_MDY_4 and $M_DATE_MASK
		jnz	short $MIF359	; not 2	digits year
		cmp	ax, 99
		jbe	short $MIF359
		mov	ax, 99

$MIF359:				; ...
		retn
endp		$M_YEAR


; =============== S U B	R O U T	I N E =======================================


proc		$M_CONVERTDATE near	; ...
		pop	[ds:$M_RT_$M_TEMP_BUF] ; [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
					; Save return address
		mov	[ds:$M_RT_$M_SIZE], cl
		call	$M_CONVERT2ASC
		dec	cx
		cmp	cl, [ds:$M_RT_$M_SIZE] ; [$M_RT+$M_RES_ADDRS.$M_SIZE]
		jnz	short $MIF363
		mov	ax, 30h	; '0'   ; $M_TIMEDATE_PAD
		push	ax		; Save pad character
		inc	cx		; Count	it

$MIF363:				; ...
		inc	cx
		push	[ds:$M_RT_$M_TEMP_BUF] ; [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
					; Restore return address
		retn
endp		$M_CONVERTDATE


; =============== S U B	R O U T	I N E =======================================


proc		$M_TIME_REPLACE	near	; ...
		pop	bp
		mov	[ds:$M_RT_$M_DIVISOR], 10 ; [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
		call	$M_GET_TIME
		test	[byte ptr si+7], 1 ; [si+$M_SUBLIST_STRUC.$M_S_FLAG],
					; Time_Cty_Type	and $M_TIME_MASK
		jz	short $MIF365
		cmp	[byte ptr ds:$M_RT_$M_TIME_FORMAT], 0 ;	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT]
		jnz	short $MIF365	; 24 hours time	format
		mov	al, [si+2]	; [si+$M_SUBLIST_STRUC.$M_S_VALUE]
		cmp	al, 12
		jl	short $MLL367
		cmp	al, 23
		jle	short $MIF367

$MLL367:				; ...
		mov	al, 'a'         ; $M_AM
		push	ax
		inc	cx
		jmp	short $MIF365
; ---------------------------------------------------------------------------

$MIF367:				; ...
		mov	al, 'p'         ; $M_PM
		push	ax
		inc	cx

$MIF365:				; ...
		xor	ax, ax
		cwd			; dx = 0
		test	[byte ptr si+7], 20h ; [si+$M_SUBLIST_STRUC.$M_S_FLAG],
					; Time_HHMMSSHH_Cty and	$M_SIZE_MASK
		jz	short $MIF372
		mov	al, [si+5]	; [si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
		call	$M_CONVERTTIME
		push	[ds:$M_RT_$M_DECI_SEPARA] ; [$M_RT+$M_COUNTRY_INFO.$M_DECI_SEPARA]
		inc	cx

$MIF372:				; ...
		test	[byte ptr si+7], 20h ; [si+$M_SUBLIST_STRUC.$M_S_FLAG],
					; Time_HHMMSSHH_Cty and	$M_SIZE_MASK
		jnz	short $MLL374
		test	[byte ptr si+7], 10h ; [si+$M_SUBLIST_STRUC.$M_S_FLAG],
					; Time_HHMMSS_Cty AND $M_SIZE_MASK
		jz	short $MIF374

$MLL374:				; ...
		mov	al, [si+4]	; [si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
		call	$M_CONVERTTIME
		push	[ds:$M_RT_$M_TIME_SEPARA] ; [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA]
		inc	cx

$MIF374:				; ...
		mov	al, [si+3]	; [si+$M_SUBLIST_STRUC.$M_S_VALUE+1]
		call	$M_CONVERTTIME
		push	[ds:$M_RT_$M_TIME_SEPARA] ; [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA]
		inc	cx
		mov	al, [si+2]	; [si+$M_SUBLIST_STRUC.$M_S_VALUE]
		test	[byte ptr si+7], 1 ; [si+$M_SUBLIST_STRUC.$M_S_FLAG],
					; Time_Cty_Type	and $M_TIME_MASK
		jz	short $MIF376
		cmp	[byte ptr ds:$M_RT_$M_TIME_FORMAT], 0 ;	[$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT]
		jnz	short $MIF376
		cmp	al, 13		; Is hour less than 12?
		jl	short $MIF378	; no
		sub	al, 12		; Set to a 12 hour value

$MIF378:				; ...
		cmp	al, 0
		jnz	short $MIF376
		mov	al, 12		; Set to a 12 hour value

$MIF376:				; ...
		call	$M_CONVERT2ASC
		push	bp
		retn
endp		$M_TIME_REPLACE


; =============== S U B	R O U T	I N E =======================================


proc		$M_GET_TIME near	; ...
		mov	ax, 3800h	; DOS_GET_COUNTRY*256
		lea	dx, [$M_RT_$M_TEMP_BUF]	; lea dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
		int	21h		; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
					; get current-country info
					; DS:DX	-> buffer for returned info
		jnb	short $MIF384
		mov	[ds:$M_RT_$M_TIME_FORMAT], 1 ; [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],
					; $M_DEF_TIME_FORM
		mov	[byte ptr ds:$M_RT_$M_TIME_SEPARA], 3Ah	; ':' ;
					; [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA],
					; $M_DEF_TIME_SEP
		mov	[byte ptr ds:$M_RT_$M_DECI_SEPARA], 2Eh	; '.' ;
					; [$M_RT+$M_COUNTRY_INFO.$M_DECI_SEPARA],
					; $M_DEF_DECI_SEP

$MIF384:				; ...
		retn
endp		$M_GET_TIME


; =============== S U B	R O U T	I N E =======================================


proc		$M_CONVERTTIME near	; ...
		pop	[ds:$M_RT_$M_TEMP_BUF] ; [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
					; Save return address
		mov	[ds:$M_RT_$M_SIZE], cl
		call	$M_CONVERT2ASC
		dec	cx
		cmp	cl, [ds:$M_RT_$M_SIZE] ; [$M_RT+$M_RES_ADDRS.$M_SIZE]
		jnz	short $MIF386
		mov	ax, 30h	; '0'
		push	ax		; Save pas character
		inc	cx

$MIF386:				; ...
		inc	cx
		push	[ds:$M_RT_$M_TEMP_BUF] ; [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
					; Restore return address
		retn
endp		$M_CONVERTTIME


; =============== S U B	R O U T	I N E =======================================


proc		$M_WAIT_FOR_INPUT near	; ...
		push	cx
		push	dx
		push	ds
		cmp	dl, 0C0h	; DOS_CLR_KEYB_BUF_MASK
		jbe	short $MIF388
		mov	al, dl
		and	al, 0Fh		; LOW_NIB_MASK
		mov	ah, 0Ch		; DOS_CLR_KEYB_BUF
		jmp	short $MEN388
; ---------------------------------------------------------------------------

$MIF388:				; ...
		mov	ah, dl

$MEN388:				; ...
		push	es
		pop	ds
		mov	dx, di
		int	21h		; DOS -
		pop	ds
		cmp	dl, 0Ah		; DOS_BUF_KEYB_INP
		clc
		jz	short $MIF391
		call	$M_IS_IT_DBCS	; Is this character DBCS?
		jnb	short $MIF392	; no
		mov	cl, al
		mov	ah, dl
		int	21h		; DOS -
		mov	ah, cl		; Retrieve first character  AX = xxxx
		clc
		jmp	short $MIF391
; ---------------------------------------------------------------------------

$MIF392:				; ...
		mov	ah, 0		; AX = 00xx where xx is	SBCS

$MIF391:				; ...
		jb	short $MIF396
		pop	dx
		pop	cx
		retn
; ---------------------------------------------------------------------------

$MIF396:				; ...
		add	sp, 4
		stc
		retn
endp		$M_WAIT_FOR_INPUT


; =============== S U B	R O U T	I N E =======================================


proc		InitVar	near		; ...
		push	ax		; initializes all the variables	used in	ParseVar
					; and HideUMBs
		push	cx
		push	di
		push	es
		mov	es, [ds:RESSEG]
		xor	ax, ax
		mov	[es:fUmbTiny], al
		mov	[es:fInHigh], al
		mov	[es:SegLoad], ax
		mov	[es:UmbLoad], 0FFh
		mov	[es:fm_argc], al
		cld
		mov	cx, 16
		mov	di, offset MsgBuffer ; UmbUsed
		rep stosb
		mov	cx, 16		; MAXUMB
		mov	di, offset UmbSize
		rep stosw
		pop	es
		pop	di
		pop	cx
		pop	ax
		retn
endp		InitVar


; =============== S U B	R O U T	I N E =======================================


proc		FixMem near		; ...
		push	ax		; scans	the upper memory chain
					; and concatenates adjacent free MCBs
		push	bx
		push	cx
		push	dx
		push	es
		call	fm_link
		call	UmbHead
		jb	short fmX
		mov	es, ax
		xor	dx, dx
		mov	cx, dx
		inc	dx

fm10:					; ...
		mov	al, [es:0]	; [es:arena_signature]
		mov	bx, [es:1]	; [es:arena_owner]
		or	bx, dx		; dx was owner of previous MCB
		jnz	short fm30	; If not both zero, don't cat.
		mov	bx, [es:3]	; [es:arena_size]
		mov	es, cx		; Go back to prev MCB's address
		assume es:RESGROUP
		mov	[es:0],	al	; & move the SECOND sig	here
		add	bx, [es:3]	; Size += first	MCB's size
		add	bx, 1		; And add one for the header
		mov	[es:3],	bx	; Write	the size

fm30:					; ...
		mov	cx, es
		mov	dx, [es:1]
		mov	bx, es
		add	bx, [es:3]
		inc	bx
		mov	es, bx
		assume es:nothing
		cmp	al, 5Ah	; 'Z'   ; arena_signature_end
		jnz	short fm10

fmX:					; ...
		call	fm_unlink
		pop	es
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn
endp		FixMem


; =============== S U B	R O U T	I N E =======================================


proc		fm_link	near		; ...
		mov	ax, 5802h	; links	UMBs not already linked	in
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) get UMB link state
		push	es
		mov	es, [ds:RESSEG]
		mov	[es:fm_umb], al
		pop	es
		mov	ax, 5803h
		mov	bx, 1
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) set UMB link state
		retn
endp		fm_link


; =============== S U B	R O U T	I N E =======================================


proc		fm_unlink near		; ...
		xor	bx, bx		; unlinks UMBs if fm_umb is set	to 0
		push	ds
		mov	ds, [ds:RESSEG]
		mov	bl, [ds:fm_umb]
		pop	ds
		mov	ax, 5803h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) set UMB link state
		retn
endp		fm_unlink


; =============== S U B	R O U T	I N E =======================================


proc		ParseVar near		; ...
		push	di
		push	ds
		push	es
		push	es
		pop	ds
		cld

pv10:					; ...
		lodsb
		call	isWhite
		jz	short pv10	; ES:SI==" /L..."--keep	eating.
		cmp	al, '/'
		jz	short pv20	; ES:SI=="/L..."--go process a switch
		dec	si
		clc
		jmp	short pvX
; ---------------------------------------------------------------------------

pv20:					; ...
		lodsb
		and	al, 0DFh	; make it uppercase
		cmp	al, 'S'
		jnz	short pv30
		call	incArgc		; If it's /S, it's another arg for LH to skip.
		push	es
		mov	es, [ds:RESSEG]
		mov	[es:fUmbTiny], 1 ; /S, so ES:SI=="  /L..." or "	module opts", or
		pop	es
		jmp	short pv10
; ---------------------------------------------------------------------------

pv30:					; ...
		cmp	al, 'L'         ; If it's not 'L' either, then it's a bad switch!
		jnz	short pvE1
		call	incArgc
		call	parseL
		jnb	short pv10	; If no	carry, go back and look	for more
		dec	si
		jmp	short pvErr	; AX has already been set by parseL
; ---------------------------------------------------------------------------

pvE1:					; ...
		mov	ax, 3		; PV_InvSwt

pvErr:					; ...
		dec	si
		dec	si
		stc

pvX:					; ...
		pop	es
		pop	ds
		pop	di
		retn
endp		ParseVar


; =============== S U B	R O U T	I N E =======================================


proc		parseL near		; ...
		lodsb			; parses ":nnnn[,nnnn][;nnnn[,nnnn]]*" for ParseVar
		cmp	al, ':'
		jnz	short plE1

pl10:					; ...
		call	GetXNum		; After	this, 'tis ",size" or ";umb" or " mod"
		jb	short plE2
		call	convUMB		; Convert any address to a UMB number
		mov	cl, al
		call	stowUMB		; Mark this UMB	# as used
		jb	short plE2
		call	incArgc		; Each UMB number is another arg for LH	to skip
		lodsb
		cmp	al, ';'         ; Did "umb;" ?
		jz	short pl10	; Yep: go back and get another UMB.
		call	isWhite		; Did "umb " ?
		jz	short plX	; Yep: return (it'll go back to whitespace)
		call	isEOL		; Did "umb" ?
		jz	short plSwX	; If so, backup	and exit like everything's ok
		cmp	al, '/'         ; Did "umb/" ? (as in, "/L:1,100;2/S")
		jz	short plSwX	; If so, back up ES:SI one character and return
		cmp	al, ','         ;  Did "umb," ?
		jnz	short plE1	; Just what the	heck DID they do? Return error.
		call	GetXNum		; Stop on "size;" or "size " or	anything else
		jb	short plE1	; And error if it's a bad size.
		call	toPara		; Convert from bytes to	paragraphs
		call	stowSiz		; CL still has the UMB number for this routine
		call	incArgc		; Each UMB size	is another arg for LH to skip
		lodsb
		cmp	al, ';'         ; They did "umb,size;", so get another UMB.
		jz	short pl10
		call	isWhite		; Did it end with whitespace?
		jz	short plX	; If so, we're done here--go back.
		call	isEOL		; Did they do "umb,size" and end??? (stupid)
		jz	short plSwX	; If so, backup	and exit like everything's ok
		cmp	al, '/'         ; Did they do "umb,size/" ?
		jz	short plSwX	; If so, again,	we're done here.

plE1:					; ...
		mov	ax, 1		; PV_InvArg
		dec	si
		stc
		retn
; ---------------------------------------------------------------------------

plE2:					; ...
		mov	ax, 2		; PV_BadUMB
		stc
		retn
; ---------------------------------------------------------------------------

plSwX:					; ...
		dec	si

plX:					; ...
		clc
		retn
endp		parseL


; =============== S U B	R O U T	I N E =======================================


proc		incArgc	near		; ...
		push	ax
		push	ds
		mov	ds, [ds:RESSEG]
		mov	al, [ds:fm_argc]
		pop	ds
		inc	al
		push	es
		mov	es, [ds:RESSEG]
		mov	[es:fm_argc], al
		pop	es
		pop	ax
		retn
endp		incArgc


; =============== S U B	R O U T	I N E =======================================


proc		isEOL near		; ...
		cmp	al, 0
		jz	short ieX
		cmp	al, 0Dh		; CR
		jz	short ieX
		cmp	al, 0Ah		; LF

ieX:					; ...
		retn
endp		isEOL


; =============== S U B	R O U T	I N E =======================================


proc		isWhite	near		; ...
		cmp	al, 20h	; ' '
		jz	short iwX
		cmp	al, 3Dh	; '='
		jz	short iwX
		cmp	al, 9		; TAB

iwX:					; ...
		retn
endp		isWhite


; =============== S U B	R O U T	I N E =======================================


proc		unMarkUMB near		; ...
		push	ax
		push	bx
		push	di
		push	es
		mov	es, [ds:RESSEG]
		xor	ah, ah
		mov	bx, ax
		mov	[es:MsgBuffer+bx], 0 ; [es:bx+UmbUsed] = [es:bx+MsgBuffer]
		cmp	[es:UmbLoad], al
		jnz	short umu10
		mov	[es:UmbLoad], 0

umu10:					; ...
		pop	es
		pop	di
		pop	bx
		pop	ax
		retn
endp		unMarkUMB


; =============== S U B	R O U T	I N E =======================================


proc		stowUMB	near		; ...
		cmp	al, 16		; MAXUMB
		jb	short su10
		stc
		retn
; ---------------------------------------------------------------------------

su10:					; ...
		push	bx
		push	di
		push	si
		push	ds
		push	es
		mov	es, [ds:RESSEG]
		mov	ds, [ds:RESSEG]
		cmp	[ds:UmbLoad], 0FFh ; UNSPECIFIED
		jnz	short su20
		mov	[ds:UmbLoad], al

su20:					; ...
		or	al, al
		jz	short su30
		mov	bl, al
		xor	bh, bh
		mov	ax, 1
		xchg	al, [es:MsgBuffer+bx] ;	[es:bx+UmbUsed]	= [es:bx+MsgBuffer]
		or	al, al
		jz	short su30
		stc

su30:					; ...
		pop	es
		pop	ds
		pop	si
		pop	di
		pop	bx
		retn
endp		stowUMB


; =============== S U B	R O U T	I N E =======================================


proc		stowSiz	near		; ...
		push	bx
		push	di
		push	es
		mov	es, [ds:RESSEG]
		mov	bl, cl
		mov	bh, 0
		shl	bl, 1
		mov	[es:UmbSize+bx], ax
		pop	es
		pop	di
		pop	bx
		retn
endp		stowSiz

; ---------------------------------------------------------------------------
gnradix		dw 0			; ...

; =============== S U B	R O U T	I N E =======================================


proc		toDigit	near		; ...
		cmp	[ds:gnradix], 16
		jnz	short td20
		cmp	cl, 'a'
		jb	short td10
		cmp	cl, 'f'
		ja	short tdE
		sub	cl, 57h		; 'a'-10
		retn
; ---------------------------------------------------------------------------

td10:					; ...
		cmp	cl, 'A'
		jb	short td20
		cmp	cl, 'F'
		ja	short tdE
		sub	cl, 37h		; 'A'-10
		retn
; ---------------------------------------------------------------------------

td20:					; ...
		cmp	cl, '0'
		jb	short tdE
		cmp	cl, '9'
		ja	short tdE
		sub	cl, 30h		; '0'
		retn
; ---------------------------------------------------------------------------

tdE:					; ...
		stc
		retn
endp		toDigit


; =============== S U B	R O U T	I N E =======================================


proc		GetXNum	near		; ...
		push	bx
		push	cx
		push	ds
		cld
		xor	ax, ax
		xor	bx, bx
		xor	cx, cx
		xor	dx, dx
		mov	[ds:gnradix], 10
		mov	cl, [es:si]
		call	toDigit
		jb	short gxnE
		or	cl, cl
		jnz	short gxn20
		mov	cl, [es:si+1]
		cmp	cl, 'x'
		jz	short gxn10
		cmp	cl, 'X'
		jnz	short gxn20

gxn10:					; ...
		mov	[ds:gnradix], 16
		inc	si
		inc	si

gxn20:					; ...
		mov	cl, [es:si]
		inc	si
		call	toDigit
		jb	short gxnQ
		call	mul32
		jb	short gxnX
		add	ax, cx
		adc	dx, bx
		jb	short gxnX
		jmp	short gxn20
; ---------------------------------------------------------------------------

gxnE:					; ...
		stc
		jmp	short gxnX
; ---------------------------------------------------------------------------

gxnQ:					; ...
		dec	si
		clc

gxnX:					; ...
		pop	ds
		pop	cx
		pop	bx
		retn
endp		GetXNum


; =============== S U B	R O U T	I N E =======================================


proc		mul32 near		; ...
		push	ax
		mov	ax, dx
		mul	[ds:gnradix]
		jb	short m32E
		mov	dx, ax
		pop	ax
		xchg	dx, bx
		mul	[ds:gnradix]
		xchg	dx, bx
		add	dx, bx
		xor	bx, bx
		retn
; ---------------------------------------------------------------------------

m32E:					; ...
		pop	ax
		retn
endp		mul32


; =============== S U B	R O U T	I N E =======================================


proc		toPara near		; ...
		push	cx
		mov	cl, 4
		shr	ax, cl
		xchg	ax, dx
		mov	cl, 12
		shl	ax, cl
		or	ax, dx
		pop	cx
		retn
endp		toPara


; =============== S U B	R O U T	I N E =======================================


proc		UmbHead	near		; ...
		push	si
		push	ds
		push	es
		mov	ah, 52h
		int	21h		; DOS -	2+ internal - GET LIST OF LISTS
					; Return: ES:BX	-> DOS list of lists
		mov	ax, [es:8Ch]	; [es:DOS_UMB_HEAD]
		cmp	ax, 0FFFFh
		jz	short uhE
		clc
		jmp	short uhX
; ---------------------------------------------------------------------------

uhE:					; ...
		stc

uhX:					; ...
		pop	es
		pop	ds
		pop	si
		retn
endp		UmbHead


; =============== S U B	R O U T	I N E =======================================


proc		isSysMCB near		; ...
		push	ax
		mov	ax, [es:1]	; [es:arena_owner]
		cmp	ax, 8
		jz	short ism10
		cmp	ax, 9
		jz	short ism10
		jmp	short ismX
; ---------------------------------------------------------------------------

ism10:					; ...
		mov	ax, [es:8]	; [es:arena_name]
		cmp	ax, 4353h	; 'SC' (NASM syntax)

ismX:					; ...
		pop	ax
		retn
endp		isSysMCB


; =============== S U B	R O U T	I N E =======================================


proc		AddrToUmb near		; ...
		push	cx		; convert segment addr to UMB number
		push	dx
		push	es
		mov	dx, ax
		call	UmbHead
		jb	short atuE
		mov	es, ax
		xor	cx, cx

atu10:					; ...
		mov	ax, es
		cmp	ax, dx
		jnb	short atuX
		call	isSysMCB
		jnz	short atu20
		inc	cx

atu20:					; ...
		mov	al, [es:0]	; [es:arena_signature]
		cmp	al, 5Ah	; 'Z'   ; arena_signature_end
		jz	short atu30
		mov	ax, es
		add	ax, [es:3]	; [es:arena_size]
		inc	ax
		mov	es, ax
		jmp	short atu10
; ---------------------------------------------------------------------------

atu30:					; ...
		mov	ax, es
		add	ax, [es:3]	; [es:arena_size]
		cmp	ax, dx
		jnb	short atuX

atuE:					; ...
		xor	cx, cx
		dec	cx

atuX:					; ...
		mov	ax, cx
		pop	es
		pop	dx
		pop	cx
		retn
endp		AddrToUmb


; =============== S U B	R O U T	I N E =======================================


proc		convUMB	near		; ...
		cmp	[ds:gnradix], 16
		jnz	short cu10
		call	AddrToUmb
		cmp	ax, 0FFFFh
		jnz	short cu10
		inc	ax

cu10:					; ...
		retn
endp		convUMB


; =============== S U B	R O U T	I N E =======================================


proc		setUMBs	near		; ...
		push	ax
		push	bx
		call	fm_link
		mov	ax, 5800h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: get allocation strategy
		push	es
		mov	es, [ds:RESSEG]
		mov	[es:fm_strat], al
		pop	es
		and	ax, 7Fh
		push	ax
		call	loadLow
		ror	al, 1
		pop	bx
		or	bl, al
		mov	ax, 5801h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		pop	bx
		pop	ax
		retn
endp		setUMBs


; =============== S U B	R O U T	I N E =======================================


proc		loadLow	near		; ...
		push	ds
		mov	ds, [ds:RESSEG]
		mov	al, [ds:UmbLoad]
		cmp	al, 0FFh
		jnz	short ll10
		mov	al, 1
		stc
		jmp	short lly
; ---------------------------------------------------------------------------

ll10:					; ...
		or	al, al
		jz	short lly
		mov	al, 1
		clc

lly:					; ...
		pop	ds
		retn
endp		loadLow


; =============== S U B	R O U T	I N E =======================================


proc		HideUMBs near		; ...
		push	ax		; links	UMBs and hides upper-memory as appropriate
		push	cx
		push	ds
		push	es
		call	UmbTest
		jb	short husX
		call	FixMem
		call	setUMBs
		push	es
		mov	es, [ds:RESSEG]
		mov	[es:fInHigh], 1
		pop	es
		call	GetLoadUMB
		cmp	al, 0FFh
		jz	short husX
		xor	cx, cx

hus10:					; ...
		inc	cx
		cmp	cx, 16		; MAXUMB
		jnb	short hus20
		mov	al, cl
		push	es
		call	findumb
		pop	es
		jb	short hus20
		call	hideUMB?
		jmp	short hus10
; ---------------------------------------------------------------------------

hus20:					; ...
		call	GetLoadUMB
		or	al, al
		jnz	short husX
		call	hl_unlink

husX:					; ...
		pop	es
		pop	ds
		pop	cx
		pop	ax
		retn
endp		HideUMBs


; =============== S U B	R O U T	I N E =======================================


proc		GetLoadUMB near		; ...
		push	ds
		mov	ds, [ds:RESSEG]
		mov	al, [ds:UmbLoad]
		pop	ds
		retn
endp		GetLoadUMB


; =============== S U B	R O U T	I N E =======================================


proc		GetLoadSize near
		push	bx
		push	si
		push	ds
		mov	ds, [ds:RESSEG]
		mov	al, [ds:UmbLoad]
		xor	ah, ah
		mov	bx, offset UmbSize
		shl	al, 1
		add	ax, bx
		mov	si, ax
		lodsw
		pop	ds
		pop	si
		pop	bx
		retn
endp		GetLoadSize


; =============== S U B	R O U T	I N E =======================================


proc		GetSize	near		; ...
		push	bx
		push	si
		push	ds
		mov	ds, [ds:RESSEG]
		xor	ah, ah
		mov	bx, offset UmbSize
		shl	al, 1
		add	ax, bx
		mov	si, ax
		lodsw
		pop	ds
		pop	si
		pop	bx
		retn
endp		GetSize


; =============== S U B	R O U T	I N E =======================================


proc		StoLoadUMB near
		push	es
		mov	es, [ds:RESSEG]
		mov	[es:UmbLoad], al
		pop	es
		retn
endp		StoLoadUMB


; =============== S U B	R O U T	I N E =======================================


proc		StoLoadSize near
		push	dx
		push	ds
		mov	ds, [ds:RESSEG]
		mov	dl, [ds:UmbLoad]
		pop	ds
		cmp	dl, 0FFh
		jz	short sls10
		call	stowSiz

sls10:					; ...
		pop	dx
		retn
endp		StoLoadSize


; =============== S U B	R O U T	I N E =======================================


proc		hideUMB	near		; ...
		push	ax		; marks	as HIDDEN all FREE elements
					; in UMB passed	as AL
		push	es
		call	findumb
		jb	short huX

hu10:					; ...
		call	isSysMCB
		jz	short huX
		call	isFreeMCB
		jnz	short hu20
		call	hideMCB

hu20:					; ...
		mov	al, [es:0]	; [es:arena_signature]
		cmp	al, 5Ah	; 'Z'   ; arena_signature_end
		jz	short huX
		mov	ax, es
		add	ax, [es:3]	; [es:arena_size]
		inc	ax
		mov	es, ax
		jmp	short hu10
; ---------------------------------------------------------------------------

huX:					; ...
		pop	es
		pop	ax
		retn
endp		hideUMB


; =============== S U B	R O U T	I N E =======================================


proc		isTiny near		; ...
		push	ax		; returns with ZF set if
					; user didn't specify /S
		push	ds
		mov	ds, [ds:RESSEG]
		mov	al, [ds:fUmbTiny]
		pop	ds
		or	al, al
		pop	ax
		retn
endp		isTiny


; =============== S U B	R O U T	I N E =======================================


proc		isFreeMCB near		; ...
		or	[word ptr es:1], 0 ; [es:arena_owner]
		retn
endp		isFreeMCB


; =============== S U B	R O U T	I N E =======================================


proc		hideMCB	near		; ...
		mov	[word ptr es:1], 8 ; [es:arena_owner],SystemPSPOwner
		mov	[word ptr es:8], 4948h ; 'HIDDEN  '
					; [es:arena_name+0], 'HI'
		mov	[word ptr es:0Ah], 4444h ; [es:arena_name+2], 'DD
		mov	[word ptr es:0Ch], 4E45h ; [es:arena_name+4], 'EN'
		mov	[word ptr es:0Eh], 2020h ; [es:arena_name+6], '  '
		retn
endp		hideMCB


; =============== S U B	R O U T	I N E =======================================


proc		unHideMCB near		; ...
		push	ax
		mov	[word ptr es:1], 0 ; [es:arena_owner],FreePSPOwner
		mov	ax, 2020h	; '  '
		mov	[es:8],	ax	; [es:arena_name+0]
		mov	[es:10], ax	; [es:arena_name+2]
		mov	[es:12], ax	; [es:arena_name+4]
		mov	[es:14], ax	; [es:arena_name+6]
		pop	ax
		retn
endp		unHideMCB


; =============== S U B	R O U T	I N E =======================================


proc		findumb	near		; ...
		push	ax
		push	cx
		push	dx
		xor	ah, ah
		mov	dx, ax
		call	UmbHead
		mov	es, ax
		xor	cx, cx

fu10:					; ...
		cmp	cx, dx
		jz	short fuX
		call	isSysMCB
		jnz	short fu20
		inc	cx

fu20:					; ...
		mov	al, [es:0]	; [es:arena_signature]
		cmp	al, 5Ah	; 'Z'   ; arena_signature_end
		jz	short fuE
		mov	ax, es
		add	ax, [es:3]	; [es:arena_size]
		inc	ax
		mov	es, ax
		jmp	short fu10
; ---------------------------------------------------------------------------

fuE:					; ...
		stc

fuX:					; ...
		pop	dx
		pop	cx
		pop	ax
		retn
endp		findumb


; =============== S U B	R O U T	I N E =======================================


proc		BigFree	near		; ...
		push	bx
		push	cx
		call	findumb
		jb	short bfX
		xor	bx, bx
		xor	cx, cx

bf10:					; ...
		call	isSysMCB
		jz	short bf30
		call	isFreeMCB
		jnz	short bf20
		cmp	cx, [es:3]	; [es:arena_size]
		jg	short bf20
		mov	bx, es
		mov	cx, [es:3]

bf20:					; ...
		mov	al, [es:0]	; [es:arena_signature]
		cmp	al, 5Ah	; 'Z'   ; arena_signature_end
		jz	short bf30
		mov	ax, es
		add	ax, [es:3]
		inc	ax
		mov	es, ax
		jmp	short bf10
; ---------------------------------------------------------------------------

bf30:					; ...
		mov	es, bx
		mov	ax, cx
		or	bx, bx
		jnz	short bfX
		stc

bfX:					; ...
		pop	cx
		pop	bx
		retn
endp		BigFree


; =============== S U B	R O U T	I N E =======================================


proc		isSpecified near	; ...
		push	ax		; sets ZF if UMB in AL wasn't specified
					; in DH/LH line
		xor	bh, bh
		mov	bl, al
		push	ds
		mov	ds, [ds:RESSEG]
		mov	al, [ds:MsgBuffer+bx] ;	[bx+UmbUsed] = [bx+MsgBuffer]
		pop	ds
		or	al, al
		pop	ax
		retn
endp		isSpecified


; =============== S U B	R O U T	I N E =======================================


proc		shrinkMCB near		; ...
		push	bx
		push	cx
		push	es
		mov	bx, ax
		mov	ax, es
		mov	cx, [es:3]	; [es:arena_size]
		sub	cx, 32		; MIN_SPLIT_SIZE
		cmp	bx, cx
		ja	short smE
		mov	dl, [es:0]	; [es:arena_signature]
		mov	cx, [es:3]	; [es:arena_size]
		mov	[es:3],	bx
		mov	[byte ptr es:0], 'M' ; [es:arena_signature]
		add	ax, bx
		inc	ax
		mov	es, ax
		mov	ax, cx
		sub	ax, bx
		dec	ax
		mov	[es:0],	dl	; [es:arena_signature]
		mov	[word ptr es:1], 0 ; [es:arena_owner]
		mov	[es:3],	ax	; [es:arena_size]
		mov	ax, 2020h	; '  '
		mov	[es:8],	ax	; [es:arena_name+0]
		mov	[es:0Ah], ax	; [es:arena_name+2]
		mov	[es:0Ch], ax	; [es:arena_name+4]
		mov	[es:0Eh], ax	; [es:arena_name+6]
		clc
		jmp	short smX
; ---------------------------------------------------------------------------

smE:					; ...
		stc

smX:					; ...
		pop	es
		pop	cx
		pop	bx
		retn
endp		shrinkMCB


; =============== S U B	R O U T	I N E =======================================


proc		hideUMB? near		; ...
		push	bx
		push	dx
		push	es
		mov	al, cl
		call	isSpecified
		jz	short hu?20
		mov	al, cl
		call	BigFree
		jb	short hu?20
		push	ax
		mov	al, cl
		call	GetSize
		pop	bx
		or	ax, ax
		jz	short hu?20
		cmp	ax, bx
		jbe	short hu?10
		mov	al, cl
		call	unMarkUMB
		jmp	short hu?20
; ---------------------------------------------------------------------------

hu?10:					; ...
		call	isTiny
		jz	short hu?20
		call	shrinkMCB
		jb	short hu?20
		mov	dx, es
		jmp	short hu?30
; ---------------------------------------------------------------------------

hu?20:					; ...
		mov	ax, cx
		call	isSpecified
		jnz	short hu?X
		xor	dx, dx

hu?30:					; ...
		mov	al, cl
		call	hideUMB
		or	dx, dx
		jz	short hu?X
		mov	es, dx
		call	unHideMCB

hu?X:					; ...
		pop	es
		pop	dx
		pop	bx
		retn
endp		hideUMB?


; =============== S U B	R O U T	I N E =======================================


proc		UnFreeze near
		push	ax
		push	es
		call	UmbHead
		jb	short ufX
		mov	es, ax

uf10:					; ...
		call	isFrozMCB
		jnz	short uf20
		call	unHideMCB

uf20:					; ...
		mov	al, [es:0]	; [es:arena_signature]
		cmp	al, 5Ah	; 'Z'   ; arena_signature_end
		jz	short ufX
		mov	ax, es
		add	ax, [es:3]
		inc	ax
		mov	es, ax
		jmp	short uf10
; ---------------------------------------------------------------------------

ufX:					; ...
		pop	es
		pop	ax
		retn
endp		UnFreeze


; =============== S U B	R O U T	I N E =======================================


proc		isFrozMCB near		; ...
		push	ax
		mov	ax, [es:1]	; [es:arena_owner]
		cmp	ax, 8
		jnz	short ifmX
		mov	ax, [es:8]	; [es:arena_name]
		cmp	ax, 5246h	; 'FR'
		jnz	short ifmX
		mov	ax, [es:10]	; [es:arena_name+2]
		cmp	ax, 5A4Fh	; 'OZ'
		jnz	short ifmX
		mov	ax, [es:0Ch]	; [es:arena_name+4]
		cmp	ax, 4E45h	; 'EN'
		jnz	short ifmX
		mov	ax, [es:0Eh]	; [es:arena_name+6]
		cmp	ax, 2020h	; '  '

ifmX:					; ...
		pop	ax
		retn
endp		isFrozMCB


; =============== S U B	R O U T	I N E =======================================


proc		frezMCB	near		; ...
		mov	[word ptr es:1], 8 ; [es:arena_owner],SystemPSPOwner
		mov	[word ptr es:8], 5246h ; [es:arena_name+0],'FR'
		mov	[word ptr es:0Ah], 5A4Fh ; [es:arena_name+2],'OZ'
		mov	[word ptr es:0Ch], 4E45h ; [es:arena_name+4],'EN'
		mov	[word ptr es:0Eh], 2020h ; [es:arena_name+6],'  '
		retn
endp		frezMCB


; =============== S U B	R O U T	I N E =======================================


proc		FreezeUM near
		push	ax
		push	cx
		push	dx
		push	es
		call	GetLoadUMB
		xor	ah, ah
		mov	dx, ax
		call	UmbHead
		mov	es, ax
		xor	cx, cx

fum10:					; ...
		call	isSysMCB
		jnz	short fum20
		inc	cx

fum20:					; ...
		cmp	cx, dx
		jz	short fum30
		call	isFreeMCB
		jnz	short fum30
		call	frezMCB

fum30:					; ...
		mov	al, [es:0]
		cmp	al, 5Ah	; 'Z'
		jz	short fumX
		mov	ax, es
		add	ax, [es:3]
		inc	ax
		mov	es, ax
		jmp	short fum10
; ---------------------------------------------------------------------------

fumX:					; ...
		pop	es
		pop	dx
		pop	cx
		pop	ax
		retn
endp		FreezeUM


; =============== S U B	R O U T	I N E =======================================


proc		UmbTest	near		; ...
		push	ax
		push	bx
		push	ds
		push	es
		call	fm_link
		call	WalkMem
		pushf
		call	fm_unlink
		popf
		pop	es
		pop	ds
		pop	bx
		pop	ax
		retn
endp		UmbTest


; =============== S U B	R O U T	I N E =======================================


proc		WalkMem	near		; ...
		push	ax		; travels memory chain and returns carry clear
					; if UMBs are linked
		push	bx
		push	es
		mov	ah, 52h		; DOS_GET_DOS_LISTS
		int	21h		; DOS -
		mov	ax, [es:bx-2]
		mov	es, ax

um10:					; ...
		mov	al, [es:0]	; [es:arena_signature]
		cmp	al, 5Ah	; 'Z'   ; arena_signature_end
		jz	short um20
		mov	bx, es
		add	bx, [es:3]	; [es:arena_size]
		inc	bx
		mov	es, bx
		jmp	short um10
; ---------------------------------------------------------------------------

um20:					; ...
		mov	ax, es
		cmp	ax, 9FFFh
		pop	es
		pop	bx
		pop	ax
		retn
endp		WalkMem


; =============== S U B	R O U T	I N E =======================================


proc		hl_unlink near		; ...
		xor	bh, bh
		push	ds
		mov	ds, [ds:RESSEG]
		mov	bl, [ds:fm_umb]
		pop	ds
		mov	ax, 5803h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) set UMB link state
		xor	bh, bh
		push	ds
		mov	ds, [ds:RESSEG]
		mov	bl, [ds:fm_strat]
		pop	ds
		mov	ax, 5801h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		retn
endp		hl_unlink


; =============== S U B	R O U T	I N E =======================================


proc		LoadHigh far		; ...

; FUNCTION CHUNK AT 0554 SIZE 0000006E BYTES
; FUNCTION CHUNK AT 2E33 SIZE 0000004F BYTES

		push	ds
		pop	es
		call	ParseLhCmd
		jb	short LhErr
		call	SetupCmdLine	; setup	pgm's command line
		call	SetupPath	; setup	path for file
		jb	short LhErr
		call	HideUMBs
		jmp	LH_EXECUTE
; ---------------------------------------------------------------------------

LhErr:					; ...
		jmp	cerror
endp		LoadHigh


; =============== S U B	R O U T	I N E =======================================


proc		ParseLhCmd near		; ...
		mov	si, 81h		; iCmdLine
		push	es
		push	ds
		pop	es
		call	InitVar
		call	ParseVar
		pop	es
		jnb	short plcC
		cmp	ax, 2		; PV_BadUMB
		jnz	short plc10
		mov	dx, offset LhBadUMB_Ptr
		stc
		retn
; ---------------------------------------------------------------------------

plc10:					; ...
		mov	dx, offset LhInvSwt_Ptr
		cmp	ax, 3		; PV_InvSwt ; Unrecognized switch passed?
		jz	short plc20
		mov	dx, offset LhInvArg_Ptr

plc20:					; ...
		stc
		retn
; ---------------------------------------------------------------------------

plcC:					; ...
		call	LhCopyFilename	; copy filename	into our buffer
		retn
endp		ParseLhCmd


; =============== S U B	R O U T	I N E =======================================


proc		LhCopyFilename near	; ...
		mov	di, offset EXECPATH
		mov	cx, 0

lhcpfn1:				; ...
		lodsb
		cmp	al, 2Ah	; '*'
		jz	short lhfilerr
		cmp	al, 3Fh	; '?'
		jz	short lhfilerr
		cmp	al, 0Dh
		jz	short lhcpfn2
		cmp	al, [ds:SWITCHAR]
		jz	short lhcpfn2
		or	al, al
		jz	short lhcpfn2
		cmp	al, 20h	; ' '
		jz	short lhcpfn2
		or	al, al
		jz	short lhcpfn2
		stosb
		inc	cx
		jmp	short lhcpfn1
; ---------------------------------------------------------------------------

lhcpfn2:				; ...
		xor	al, al
		stosb
		or	cx, cx
		jz	short lhmissing
		dec	si
		clc
		retn
; ---------------------------------------------------------------------------

lhfilerr:				; ...
		mov	dx, offset LhInvFil_Ptr
		stc
		retn
; ---------------------------------------------------------------------------

lhmissing:				; ...
		mov	dx, offset ReqParmMiss
		stc
		retn
endp		LhCopyFilename


; =============== S U B	R O U T	I N E =======================================


proc		SetupCmdLine near	; ...
		mov	di, 81h		; iCmdLine
		xor	cl, cl
		dec	cl		; just CR means	count =	0

SetCmdL1:				; ...
		lodsb
		stosb
		inc	cl		; update count
		or	al, al
		jz	short SetCmdL2
		cmp	al, 0Dh		; carriage return?
		jnz	short SetCmdL1	; no, continue storing

SetCmdL2:				; ...
		mov	[es:80h], cl	; store	new cmd	line length
		retn
endp		SetupCmdLine


; =============== S U B	R O U T	I N E =======================================


proc		LhSetupErrMsg near	; ...
		mov	[ds:msg_disp_class], 1 ; [msg_disp_class],ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	[ds:extend_buf_ptr], ax
		retn
endp		LhSetupErrMsg


; =============== S U B	R O U T	I N E =======================================


proc		SetupPath near		; ...
		mov	ax, [ds:ARG_ARGVCNT] ; [ARG+ARG_UNIT.argvcnt]
		dec	ax
		mov	bx, 11		; ARGV_ELE.SIZE
		mul	bx
		push	ds
		mov	ds, [ds:RESSEG]
		mov	cl, [ds:fm_argc]
		pop	ds
		inc	cl

argloop:				; ...
		jcxz	short argdone
		dec	cx
		push	ax
		push	cx
		mov	cx, ax
		mov	di, offset ARG_ARGV ; mov di,[ARG+ARG_UNIT.argv] ; mov di,[ARG]
		mov	si, di
		add	si, 11		; ARGV_ELE.SIZE
		cld
		rep movsb
		dec	[ds:ARG_ARGVCNT] ; [ARG+ARG_UNIT.argvcnt]
		sub	ax, 11		; ARGV_ELE.SIZE
		pop	cx
		pop	ax
		jmp	short argloop
; ---------------------------------------------------------------------------

argdone:				; ...
		call	path_search
		or	ax, ax
		jz	short no_exec_file
		cmp	ax, 4		; executable file?
		jl	short no_exec_bat ; no,	indicate fail
		clc
		retn
; ---------------------------------------------------------------------------

no_exec_bat:				; ...
		mov	dx, offset NoExecBat_Ptr ; offset TRANGROUP:NoExecBat_Ptr
		jmp	short lhsp_errret
; ---------------------------------------------------------------------------

no_exec_file:				; ...
		mov	ax, 2		; setup	error message
		call	LhSetupErrMsg

lhsp_errret:				; ...
		stc
		retn
endp		SetupPath

; ---------------------------------------------------------------------------
$M_CLASS_3_STRUC db 0FFh		; ...
		dw 0A07h		; $M_COMMAND_VER (COMMAND.COM version)
		db 183
$M_ID_3_1	dw 1020
		dw 732
$M_ID_3_2	dw 1015
		dw 744
$M_ID_3_3	dw 1004, 776,1026, 798,1031, 814,1035, 825,1062, 836
		dw 1028, 847,1045, 877,1041, 902,1042, 932,1043, 955
		dw 1002, 983,1003,1019,1007,1043,1008,1066,1009,1084
		dw 1010,1101,1011,1129,1012,1152,1014,1177,1016,1190
		dw 1017,1228,1018,1261,1019,1277,1021,1285,1022,1311
		dw 1023,1346,1024,1386,1025,1405,1027,1425,1029,1454
		dw 1030,1468,1032,1479,1033,1499,1034,1517,1036,1535
		dw 1037,1552,1038,1565,1039,1580,1040,1637,1044,1652
		dw 1046,1668,1047,1719,1048,1740,1049,1754,1050,1760
		dw 1051,1787,1052,1800,1053,1819,1054,1853,1055,1888
		dw 1056,1898,1057,1909,1059,1918,1060,1919,1061,1919
		dw 1063,1941,1064,1940,1065,1939,1066,1938,1067,1937
		dw 1068,1935,1069,1944,1070,1944,1071,1943,1072,1942
		dw 1073,1948,1074,1954,1075,1960,1076,1962,1077,1961
		dw 1078,1965,1079,1988,1080,1995,1081,2013,1082,2052
		dw 1083,2060,1084,2059,1090,2071,1091,2081,1092,2091
		dw 1093,2101,1094,2118,1095,2143,1096,2168,1097,2213
		dw 1098,2238,1099,2263,1100,2281,1103,2315,1104,2338
		dw 1105,2338,1106,2345,1200,2359,1300,2356,1320,2487
		dw 1321,2547,1340,2656,1341,2744,1342,2839,1360,2981
		dw 1400,3005,1401,3158,1402,3259,1403,3374,1404,3434
		dw 1405,3547,1406,3658,1407,3721,1420,3853,1440,3988
		dw 1441,4023,1460,4151,1461,4248,1462,4376,1480,4452
		dw 1481,4608,1482,4682,1483,4770,1484,4893,1485,5014
		dw 1486,5160,1487,5300,1488,5391,1489,5534,1500,5611
		dw 1520,5670,1540,5728,1541,5818,1542,5922,1560,5978
		dw 1561,6030,1562,6151,1563,6195,1564,6234,1565,6292
		dw 1566,6341,1567,6382,1568,6500,1580,6573,1600,6641
		dw 1601,6666,1602,6746,1620,6903,1621,6987,1622,7113
		dw 1640,7185,1641,7234,1660,7362,1680,7429,1700,7463
		dw 1720,7637,1740,7716,1741,7804,1760,7915,1780,7988
		dw 1800,8092,1801,8166,1820,8250,1821,8318,1840,8453
		dw 1860,8524,1861,8611,1862,8678,1863,8800,1864,8959
		dw 1865,9058,1866,9161,1880,9261,1881,9377,1882,9499
		dw 1883,9582,1900,9741,1920,9810,1921,9854,1922,10003
		dw 1923,10182,1924,10312,1925,10432,1926,10431,1927,10515
$M_ID_3_183	dw 1107
		dw 10602
MSG_1020	db 15
		db '%1 bytes free',0Dh,0Ah
MSG_1015	db 35
		db 'File cannot be copied onto itself',0Dh,0Ah
MSG_1004	db 25
		db 'Insufficient disk space',0Dh,0Ah
MSG_1026	db 19
		db 'Invalid code page',0Dh,0Ah
MSG_1031	db 14
		db 'Invalid date',0Dh,0Ah
MSG_1035	db 14
		db 'Invalid time',0Dh,0Ah
MSG_1062	db 14
		db 'Invalid path',0Dh,0Ah
MSG_1028	db 33
		db 'Press any key to continue . . .',0Dh,0Ah
MSG_1045	db 28
		db 'Unable to create directory',0Dh,0Ah
MSG_1041	db 33
		db 'Volume in drive %1 has no label',0Dh,0Ah
MSG_1042	db 26
		db 'Volume in drive %1 is %2',0Dh,0Ah
MSG_1043	db 31
		db 'Volume Serial Number is %1-%2',0Dh,0Ah
MSG_1002	db 39
		db 'Duplicate file name or file not found',0Dh,0Ah
MSG_1003	db 27
		db 'Invalid path or file name',0Dh,0Ah
MSG_1007	db 26
		db 'Out of environment space',0Dh,0Ah
MSG_1008	db 21
		db 'File creation error',0Dh,0Ah
MSG_1009	db 20
		db 'Batch file missing',0Dh,0Ah
MSG_1010	db 31
		db 0Dh,0Ah
		db 'Insert disk with batch file',0Dh,0Ah
MSG_1011	db 26
		db 'Bad command or file name',0Dh,0Ah
MSG_1012	db 28
		db 'REXX interpreter not found',0Dh,0Ah
MSG_1014	db 16
		db 'Access denied ',0Dh,0Ah
MSG_1016	db 41
		db 'Content of destination lost before copy',0Dh,0Ah
MSG_1017	db 36
		db 'Invalid filename or file not found',0Dh,0Ah
		db 19
		db '%1 file(s) copied',0Dh,0Ah
		db 11
		db '%1 file(s) '
		db 29
		db 'Invalid drive specification',0Dh,0Ah
		db 38
		db 'Code page %1 not prepared for system',0Dh,0Ah
		db 43
		db 'Code page %1 not prepared for all devices',0Dh,0Ah
		db 22
		db 'Active code page: %1',0Dh,0Ah
		db 23
		db 'NLSFUNC not installed',0Dh,0Ah
		db 32
		db 'Current drive is no longer valid'
		db 17
		db 'Label not found',0Dh,0Ah
		db 14
		db 'Syntax error',0Dh,0Ah
		db 23
		db 'Current date is %1 %2',0Dh,0Ah
		db 21
		db 'SunMonTueWedThuFriSat'
		db 21
		db 'Enter new date (%1): '
		db 20
		db 'Current time is %1',0Dh,0Ah
		db 16
		db 'Enter new time: '
		db 18
		db ',    Delete (Y/N)?'
		db 60
		db 'All files in directory will be deleted!',0Dh,0Ah
		db 'Are you sure (Y/N)?'
MSG_1040	db 18
		db 'PC DOS Version 7.1'
		db 19
		db 'Invalid directory',0Dh,0Ah
		db 54
		db 'Invalid path, not directory,',0Dh,0Ah
		db 'or directory not empty',0Dh,0Ah
		db 24
		db 'Must specify ON or OFF',0Dh,0Ah
		db 17
		db 'Directory of %1',0Dh,0Ah
		db 9
		db 'No Path',0Dh,0Ah
		db 30
		db 'Invalid drive in search path',0Dh,0Ah
		db 16
		db 'Invalid device',0Dh,0Ah
		db 22
		db 'FOR cannot be nested',0Dh,0Ah
		db 37
		db 'Intermediate file error during pipe',0Dh,0Ah
		db 38
		db 'Cannot do binary reads from a device',0Dh,0Ah
MSG_1055	db 13
		db 'BREAK is %1',0Dh,0Ah
		db 14
		db 'VERIFY is %1',0Dh,0Ah
		db 12
		db 'ECHO is %1',0Dh,0Ah
		db 4
		db 'off',0
		db 3
		db 'on',0
MSG_1061	db 25
		db 'Error writing to device',0Dh,0Ah
		db 2
MSG_1063	db '%1'
		db 2
		db '%1'
		db 2
		db '%1'
		db 2
		db '%1'
MSG_1067	db 1
		db 9
MSG_1068	db 12
		db ' <DIR>      '
		db 3
		db 8, 20h, 8
MSG_1070	db 2
		db 0Dh,0Ah
		db 2
		db '%1'
MSG_1072	db 9
		db 'mm-dd-yy',0
MSG_1073	db 9
		db 'dd-mm-yy',0
MSG_1074	db 9
		db 'yy-mm-dd',0
MSG_1075	db 5
		db '%1 %2'
		db 2
		db '%1'
		db 7
		db ' %1  %2'
MSG_1078	db 26
		db 'Directory already exists',0Dh,0Ah
MSG_1079	db 10
		db '%1 bytes',0Dh,0Ah
MSG_1080	db 21
		db 'Total files listed:',0Dh,0Ah
		db 42
		db '(Error occurred in environment variable)',0Dh,0Ah
MSG_1082	db 11
		db ' [Y,N,ESC]?'
MSG_1083	db 2
		db 'YN'
MSG_1084	db 15
		db '(continuing %1)'
		db 13
		db 'Revision %1',0Dh,0Ah
		db 13
		db 'DOS is in ROM'
		db 13
		db 'DOS is in HMA'
		db 20
		db 'DOS is in low memory'
		db 28
		db 'Cannot Loadhigh batch file',0Dh,0Ah
MSG_1095	db 28
		db 'LOADHIGH: Invalid filename',0Dh,0Ah
		db 48
		db 'Cannot open specified country information file',0Dh,0Ah
MSG_1097	db 28
		db 'LoadHigh: Invalid argument',0Dh,0Ah
MSG_1098	db 28
		db 'Required parameter missing',0Dh,0Ah
		db 21
		db 'Unrecognized switch',0Dh,0Ah
		db 37
		db 'A bad UMB number has been specified',0Dh,0Ah
MSG_1103	db 26
		db 'Overwrite %1 (Yes/No/All)?'
MSG_1104	db 3			; ...
_Y_es		db 'Y'                  ; ...
_N_o		db 'N'                  ; ...
_A_ll		db 'A'                  ; ...
MSG_1105	db 10
		db ' <DIR>    '
MSG_1106	db 17
		db '%1 K bytes free',0Dh,0Ah
MSG_1200	db 0
MSG_1300	db 134
		db 'Sets or clears extended CTRL+C checking.',0Dh,0Ah
		db 0Dh,0Ah
		db 'BREAK [ON | OFF]',0Dh,0Ah
		db 0Dh,0Ah
		db 'Type BREAK without a parameter to display the current BREAK setti'
		db 'ng.',0Dh,0Ah
MSG_1320	db 63
		db 'Displays or sets the active code page number.',0Dh,0Ah
		db 0Dh,0Ah
		db 'CHCP [nnn]',0Dh,0Ah
		db 0Dh,0Ah
		db 112
		db '  nnn   Specifies a code page number.',0Dh,0Ah
		db 0Dh,0Ah
		db 'Type CHCP without a parameter to display the active code page num'
		db 'ber.',0Dh,0Ah
MSG_1340	db 91
		db 'Displays the name of or changes the current directory.',0Dh,0Ah
		db 0Dh,0Ah
		db 'CHDIR [drive:][path]',0Dh,0Ah
		db 'CHDIR[..]',0Dh,0Ah
		db 98
		db 'CD [drive:][path]',0Dh,0Ah
		db 'CD[..]',0Dh,0Ah
		db 0Dh,0Ah
		db '  ..   Specifies that you want to change to the parent directory.'
		db 0Dh,0Ah
		db 0Dh,0Ah
		db 145
		db 'Type CD drive: to display the current directory in the specified '
		db 'drive.',0Dh,0Ah
		db 'Type CD without parameters to display the current drive and direc'
		db 'tory.',0Dh,0Ah
MSG_1360	db 27
		db 'Clears the screen.',0Dh,0Ah
		db 0Dh,0Ah
		db 'CLS',0Dh,0Ah
MSG_1400	db 156
		db 'Copies one or more files to another location.',0Dh,0Ah
		db 0Dh,0Ah
		db 'COPY [/A | /B] source [/A | /B] [+ source [/A | /B] [+ ...]] [des'
		db 'tination',0Dh,0Ah
		db '  [/A | /B]] [/V] [/Y | /-Y]',0Dh,0Ah
		db 0Dh,0Ah
		db 104
		db '  source       Specifies the file or files to be copied.',0Dh,0Ah
		db '  /A           Indicates an ASCII text file.',0Dh,0Ah
		db 118
		db '  /B           Indicates a binary file.',0Dh,0Ah
		db '  destination  Specifies the directory and/or filename for the ne'
		db 'w file(s).',0Dh,0Ah
MSG_1403	db 63
		db '  /V           Verifies that new files are written correctly.',0Dh,0Ah
MSG_1404	db 116
		db '  /Y           Suppresses prompting to confirm you want to overwr'
		db 'ite an',0Dh,0Ah
		db '               existing destination file.',0Dh,0Ah
MSG_1405	db 114
		db '  /-Y          Causes prompting to confirm you want to overwrite '
		db 'an',0Dh,0Ah
		db '               existing destination file.',0Dh,0Ah
		db 0Dh,0Ah
MSG_1406	db 66
		db 'The switch /Y may be preset in the COPYCMD environment variable.',0Dh
		db 0Ah
MSG_1407	db 135
		db 'To append files, specify a single file for destination, but multi' ; ...
		db 'ple files',0Dh,0Ah
		db 'for source (using wildcards or file1+file2+file3 format).',0Dh,0Ah
MSG_1420	db 138
		db 'Changes the terminal device used to control your system.',0Dh,0Ah
		db 0Dh,0Ah
		db 'CTTY device',0Dh,0Ah
		db 0Dh,0Ah
		db '  device   The terminal device you want to use, such as COM1.',0Dh,0Ah
MSG_1440	db 38
		db 'Displays or sets the date.',0Dh,0Ah
		db 0Dh,0Ah
		db 'DATE',0Dh,0Ah
		db 0Dh,0Ah
		db 131
		db 'Type DATE without parameters to display the current date setting '
		db 'and',0Dh,0Ah
		db 'a prompt for a new one.  Press ENTER to keep the same date.',0Dh,0Ah
MSG_1460	db 100
		db 'Deletes one or more files.',0Dh,0Ah
		db 0Dh,0Ah
		db 'DEL [drive:][path]filename [/P]',0Dh,0Ah
		db 'ERASE [drive:][path]filename [/P]',0Dh,0Ah
		db 0Dh,0Ah
		db 131
		db '  [drive:][path]filename  Specifies the file(s) to delete.  Speci'
		db 'fy multiple',0Dh,0Ah
		db '                          files by using wildcards.',0Dh,0Ah
		db 79
		db '  /P                      Prompts for confirmation before deletin'
		db 'g each file.',0Dh,0Ah
MSG_1480	db 159
		db 'Displays a list of files and subdirectories in a directory.',0Dh,0Ah
		db 0Dh,0Ah
		db 'DIR [drive:][path][filename] [/P] [/W] [/A[[:]attribs]] [/O[[:]so'
		db 'rtord]]',0Dh,0Ah
		db '    [/S] [/B] [/L]',0Dh,0Ah
		db 0Dh,0Ah
MSG_1481	db 77
		db '  [drive:][path][filename]   Specifies drive, directory, and file'
		db 's to list.',0Dh,0Ah
		db 91
		db '  /P      Pauses after each full screen of information.',0Dh,0Ah
		db '  /W      Uses wide list format.',0Dh,0Ah
MSG_1483	db 126
		db '  /A      Displays files with specified attributes.',0Dh,0Ah
		db '  attribs   '
		db 'D  Directories   R  Read-only files         H  Hidden files',0Dh,0Ah
		db 124
		db '            S  System files  A  Files ready to archive  -  Prefix'
		db ' meaning "not"',0Dh,0Ah
		db '  /O      Lists by files in sorted order.',0Dh,0Ah
MSG_1485	db 149
		db '  sortord   N  By name (alphabetic)       S  By size (smallest fi'
		db 'rst)',0Dh,0Ah
		db '            E  By extension (alphabetic)  D  By date & time (earl'
		db 'iest first)',0Dh,0Ah
MSG_1486	db 143
		db '            G  Group directories first    -  Prefix to reverse or'
		db 'der',0Dh,0Ah
		db '  /S      Displays files in specified directory and all subdirect'
		db 'ories.',0Dh,0Ah
MSG_1487	db 94
		db '  /B      Uses bare format (no heading information or summary).',0Dh
		db 0Ah
		db '  /L      Uses lowercase.',0Dh,0Ah
		db 0Dh,0Ah
MSG_1488	db 146
		db 'Switches may be preset in the DIRCMD environment variable.  Overr'
		db 'ide',0Dh,0Ah
		db 'preset switches by prefixing any switch with - (hyphen)--for exam'
		db 'ple, /-W.',0Dh,0Ah
MSG_1489	db 80
		db 'To remove the commas from the DIR output, use the NO_SEP environm'
		db 'ent variable.',0Dh,0Ah
MSG_1500	db 62
		db 'Quits the COMMAND.COM program (command interpreter).',0Dh,0Ah
		db 0Dh,0Ah
		db 'EXIT',0Dh,0Ah
MSG_1520	db 61
		db 'Creates a directory.',0Dh,0Ah
		db 0Dh,0Ah
		db 'MKDIR [drive:]path',0Dh,0Ah
		db 'MD [drive:]path',0Dh,0Ah
MSG_1540	db 93
		db 'Displays or sets a search path for executable files.',0Dh,0Ah
		db 0Dh,0Ah
		db 'PATH [[drive:]path[;...]]',0Dh,0Ah
		db 'PATH ;',0Dh,0Ah
		db 0Dh,0Ah
		db 107
		db 'Type PATH ; to clear all search-path settings and direct PC DOS t'
		db 'o search',0Dh,0Ah
		db 'only in the current directory.',0Dh,0Ah
		db 59
		db 'Type PATH without parameters to display the current path.',0Dh,0Ah
MSG_1560	db 55
		db 'Changes the PC DOS command prompt.',0Dh,0Ah
		db 0Dh,0Ah
		db 'PROMPT [text]',0Dh,0Ah
		db 0Dh,0Ah
MSG_1561	db 124
		db '  text    Specifies a new command prompt.',0Dh,0Ah
		db 0Dh,0Ah
		db 'Prompt can be made up of normal characters and the following spec'
		db 'ial codes:',0Dh,0Ah
		db 0Dh,0Ah
MSG_1562	db 47
		db '  $Q   = (equal sign)',0Dh,0Ah
		db '  $$   $ (dollar sign)',0Dh,0Ah
MSG_1563	db 42
		db '  $T   Current time',0Dh,0Ah
		db '  $D   Current date',0Dh,0Ah
MSG_1564	db 61
		db '  $P   Current drive and path',0Dh,0Ah
		db '  $V   PC DOS version number',0Dh,0Ah
MSG_1565	db 52
		db '  $N   Current drive',0Dh,0Ah
		db '  $G   > (greater-than sign)',0Dh,0Ah
MSG_1566	db 44
		db '  $L   < (less-than sign)',0Dh,0Ah
		db '  $B   | (pipe)',0Dh,0Ah
MSG_1567	db 121
		db '  $H   Backspace (erases previous character)',0Dh,0Ah
		db '  $E   Escape code (ASCII code 27)',0Dh,0Ah
		db '  $_   Carriage return and linefeed',0Dh,0Ah
		db 0Dh,0Ah
		db 76
		db 'Type PROMPT without parameters to reset the prompt to the default'
		db ' setting.',0Dh,0Ah
MSG_1580	db 71
		db 'Removes (deletes) a directory.',0Dh,0Ah
		db 0Dh,0Ah
		db 'RMDIR [drive:]path',0Dh,0Ah
		db 'RD [drive:]path',0Dh,0Ah
MSG_1600	db 28
		db 'Renames a file or files.',0Dh,0Ah
		db 0Dh,0Ah
		db 83
		db 'RENAME [drive:][path]filename1 filename2',0Dh,0Ah
		db 'REN [drive:][path]filename1 filename2',0Dh,0Ah
		db 0Dh,0Ah
MSG_1602	db 160
		db 'Note that you cannot specify a new drive or path for your destina'
		db 'tion file.',0Dh,0Ah
		db 0Dh,0Ah
		db 'Use MOVE to move files from one directory to another, or to renam'
		db 'e a directory.',0Dh,0Ah
MSG_1620	db 87
		db 'Displays, sets, or removes PC DOS environment variables.',0Dh,0Ah
		db 0Dh,0Ah
		db 'SET [variable=[string]]',0Dh,0Ah
		db 0Dh,0Ah
		db 129
		db '  variable  Specifies the environment-variable name.',0Dh,0Ah
		db '  string    Specifies a series of characters to assign to the var'
		db 'iable.',0Dh,0Ah
		db 0Dh,0Ah
MSG_1622	db 75
		db 'Type SET without parameters to display the current environment va'
		db 'riables.',0Dh,0Ah
MSG_1640	db 52
		db 'Displays or sets the system time.',0Dh,0Ah
		db 0Dh,0Ah
		db 'TIME [time]',0Dh,0Ah
		db 0Dh,0Ah
		db 131
		db 'Type TIME with no parameters to display the current time setting '
		db 'and a prompt',0Dh,0Ah
		db 'for a new one.  Press ENTER to keep the same time.',0Dh,0Ah
MSG_1660	db 70
		db 'Displays the contents of a text file.',0Dh,0Ah
		db 0Dh,0Ah
		db 'TYPE [drive:][path]filename',0Dh,0Ah
MSG_1680	db 37
		db 'Displays the PC DOS Version.',0Dh,0Ah
		db 0Dh,0Ah
		db 'VER',0Dh,0Ah
MSG_1700	db 177
		db 'Tells PC DOS whether to verify that your files are written correc'
		db 'tly to a',0Dh,0Ah
		db 'disk.',0Dh,0Ah
		db 0Dh,0Ah
		db 'VERIFY [ON | OFF]',0Dh,0Ah
		db 0Dh,0Ah
		db 'Type VERIFY without a parameter to display the current VERIFY set'
		db 'ting.',0Dh,0Ah
MSG_1720	db 82
		db 'Displays the disk volume label and serial number, if they exist.',0Dh
		db 0Ah
		db 0Dh,0Ah
		db 'VOL [drive:]',0Dh,0Ah
MSG_1740	db 91
		db 'Calls one batch program from another.',0Dh,0Ah
		db 0Dh,0Ah
		db 'CALL [drive:][path]filename [batch-parameters]',0Dh,0Ah
		db 0Dh,0Ah
MSG_1741	db 114
		db '  batch-parameters   Specifies any command-line information requi'
		db 'red by the',0Dh,0Ah
		db '                     batch program.',0Dh,0Ah
MSG_1760	db 76
		db 'Records comments (remarks) in a batch file or CONFIG.SYS.',0Dh,0Ah
		db 0Dh,0Ah
		db 'REM [comment]',0Dh,0Ah
MSG_1780	db 107
		db 'Suspends processing of a batch program and displays the message "'
		db 'Press any',0Dh,0Ah
		db 'key to continue...."',0Dh,0Ah
		db 0Dh,0Ah
		db 'PAUSE',0Dh,0Ah
MSG_1800	db 77
		db 'Displays messages, or turns command-echoing on or off.',0Dh,0Ah
		db 0Dh,0Ah
		db '  ECHO [ON | OFF]',0Dh,0Ah
MSG_1801	db 87
		db '  ECHO [message]',0Dh,0Ah
		db 0Dh,0Ah
		db 'Type ECHO without parameters to display the current echo setting.'
		db 0Dh,0Ah
MSG_1820	db 71
		db 'Directs PC DOS to a labelled line in a batch program.',0Dh,0Ah
		db 0Dh,0Ah
		db 'GOTO label',0Dh,0Ah
		db 0Dh,0Ah
		db 138
		db '  label   Specifies a text string used in the batch program as a '
		db 'label.',0Dh,0Ah
		db 0Dh,0Ah
		db 'You type a label on a line by itself, beginning with a colon.',0Dh,0Ah
MSG_1840	db 74
		db 'Changes the position of replaceable parameters in a batch file.',0Dh
		db 0Ah
		db 0Dh,0Ah
		db 'SHIFT',0Dh,0Ah
MSG_1860	db 90
		db 'Performs conditional processing in batch programs.',0Dh,0Ah
		db 0Dh,0Ah
		db 'IF [NOT] ERRORLEVEL number command',0Dh,0Ah
		db 70
		db 'IF [NOT] string1==string2 command',0Dh,0Ah
		db 'IF [NOT] EXIST filename command',0Dh,0Ah
		db 0Dh,0Ah
		db 125
		db '  NOT               Specifies that PC DOS should carry out the co'
		db 'mmand only',0Dh,0Ah
		db '                    if the condition is false.',0Dh,0Ah
MSG_1863	db 162
		db '  ERRORLEVEL number Specifies a true condition if the last progra'
		db 'm run returned',0Dh,0Ah
		db '                    an exit code equal to or greater than the num'
		db 'ber specified.',0Dh,0Ah
		db 102
		db '  command           Specifies the command to carry out if the con'
		db 'dition is',0Dh,0Ah
		db '                    met.',0Dh,0Ah
		db 106
		db '  string1==string2  Specifies a true condition if the specified t'
		db 'ext strings',0Dh,0Ah
		db '                    match.',0Dh,0Ah
		db 103
		db '  EXIST filename    Specifies a true condition if the specified f'
		db 'ilename',0Dh,0Ah
		db '                    exists.',0Dh,0Ah
MSG_1880	db 119
		db 'Runs a specified command for each file in a set of files.',0Dh,0Ah
		db 0Dh,0Ah
		db 'FOR %variable IN (set) DO command [command-parameters]',0Dh,0Ah
		db 0Dh,0Ah
		db 125
		db '  %variable  Specifies a replaceable parameter.',0Dh,0Ah
		db '  (set)      Specifies a set of one or more files.  Wildcards may'
		db ' be used.',0Dh,0Ah
		db 86
		db '  command    Specifies the command to carry out for each file.',0Dh,0Ah
		db '  command-parameters',0Dh,0Ah
MSG_1883	db 162
		db '             Specifies parameters or switches for the specified c'
		db 'ommand.',0Dh,0Ah
		db 0Dh,0Ah
		db 'To use the FOR command in a batch program, specify %%variable ins'
		db 'tead of',0Dh,0Ah
		db '%variable.',0Dh,0Ah
MSG_1900	db 72
		db 'Returns a fully qualified filename.',0Dh,0Ah
		db 0Dh,0Ah
		db 'TRUENAME [drive:][path]filename',0Dh,0Ah
MSG_1920	db 47
		db 'Loads a program into the upper memory area.',0Dh,0Ah
		db 0Dh,0Ah
MSG_1921	db 152
		db 'LOADHIGH [drive:][path]filename [parameters]',0Dh,0Ah
		db 'LOADHIGH [/L:region1[,minsize1][;region2[,minsize2]...]]',0Dh,0Ah
		db '         [drive:][path]filename [parameters]',0Dh,0Ah
		db 0Dh,0Ah
MSG_1922	db 182
		db '/L:region1[,minsize1][;region2[,minsize2]]...',0Dh,0Ah
		db '            Specifies the region(s) of memory into which to load',0Dh
		db 0Ah
		db '            the program.  Region1 specifies the number of the fir'
		db 'st',0Dh,0Ah
MSG_1923	db 133
		db '            memory region; minsize1 specifies the minimum size, i'
		db 'f',0Dh,0Ah
		db '            any, for region1.  Region2 and minsize2 specify the',0Dh
		db 0Ah
MSG_1924	db 123
		db '            number and minimum size of the second region, if any.'
		db 0Dh,0Ah
		db '            You can specify as many regions as you want.'
MSG_1925	db 2
		db 0Dh,0Ah
MSG_1926	db 87
		db '[drive:][path]filename',0Dh,0Ah
		db '            Specifies the location and name of the program.',0Dh,0Ah
		db 0Dh,0Ah
MSG_1927	db 90
		db 'parameters  Specifies any command-line information required by',0Dh,0Ah
		db '            the program.',0Dh,0Ah
MSG_1107	db 12
		db '%1 K bytes',0Dh,0Ah

; =============== S U B	R O U T	I N E =======================================


proc		$M_CLS_3 near		; ...
		push	cs
		pop	es
		assume es:TRANGROUP
		lea	di, [$M_CLASS_3_STRUC]
		add	cx, 11353	; ADD CX,$-$M_CLASS_3_STRUC
		retn
endp		$M_CLS_3

; ---------------------------------------------------------------------------
$M_CLASS_1_STRUC db 1			; ...
					; $M_CLASS_ID
		dw 0A07h		; EXPECTED_VERSION (COMMAND.COM	version)
		db 4			; Class_1_MessageCount
$M_ID_1_1	dw 2			; Message Number = 2
		dw 10h			; Message offset from message number
$M_ID_1_2	dw 3			; Message Number = 3
		dw 1Bh			; Message offset from message number
$M_ID_1_3	dw 8			; Message Number = 8
		dw 26h			; Message offset from message number
$M_ID_1_4	dw 0FFFFh		; Message Number = -1
		dw 36h			; Message offset from message number
EXTEND2		db 14
		db 'File not found'
EXTEND3		db 14
		db 'Path not found'
EXTEND8		db 19
		db 'Insufficient memory'
EXTEND999	db 17
		db 'Extended Error %1'

; =============== S U B	R O U T	I N E =======================================


proc		$M_MSGSERV_1 near	; ...
		push	cs
		pop	es
		lea	di, [$M_CLASS_1_STRUC]
		add	cx, 94		; $-$M_CLASS_1_STRUC
		retn
endp		$M_MSGSERV_1

; ---------------------------------------------------------------------------
$M_CLASS_2_STRUC db 2			; ...
					; $M_CLASS_ID
		dw 0A07h		; EXPECTED_VERSION (COMMAND.COM	version)
		db 1			; Class_2_MessageCount
$M_ID_2_1	dw 0FFFFh		; Message Number = -1
		dw 4			; Message offset from message number
PARSE999	db 14
		db 'Parse Error %1'

; =============== S U B	R O U T	I N E =======================================


proc		$M_MSGSERV_2 near	; ...
		push	cs
		pop	es
		lea	di, [$M_CLASS_2_STRUC]
		add	cx, 29
		retn
endp		$M_MSGSERV_2

; ---------------------------------------------------------------------------
msg_disp_class	db 0FFh			; ...
msg_cont_flag	db 0			; ...
extend_buf_ptr	dw 0			; ...
extend_buf_sub	db 0			; ...
		db 11
		db 0
extend_buf_off	dw offset string_ptr_2
extend_buf_seg	dw 0
		db 0
		db 10h			; Char_field_ASCIIZ
		db 128
		db 0
		db 20h			; blank
RENERR_PTR	dw 1002			; ...
		db 0
BADCPMES_PTR	dw 1003			; ...
		db 0
NOSPACE_PTR	dw 1004			; ...
		db 0
ENVERR_PTR	dw 1007			; ...
		db 0
FULLDIR_PTR	dw 1008			; ...
		db 0
BADBAT_PTR	dw 1009			; ...
		db 0
NEEDBAT_PTR	dw 1010			; ...
		db 0
BADNAM_PTR	dw 1011			; ...
		db 0
REXXNOTF_PTR	dw 1012			; ...
		db 0
ACCDEN_PTR	dw 1014			; ...
		db 0
OVERWR_PTR	dw 1015			; ...
		db 0
LOSTERR_PTR	dw 1016			; ...
		db 0
INORNOT_PTR	dw 1017			; ...
		db 0
copied_ptr	dw 1018			; ...
		db 1
		db 11			; parm_block_size
		db 0
		dw offset Copy_num
		dw 0
		db 1
		db 0A1h			; Right_Align+Unsgn_Bin_Word
		db 9			; maximum width
		db 9			; minimum width
		db 20h			; pad character
dirmes_ptr	dw 1019			; ...
		db 1
		db 11
		db 0
		dw offset Dir_Num
		dw 0
		db 1
		db 0E1h			; Right_Align+Unsgn_Bin_Word
		db 9
		db 9
		db 20h
dirmes_w_ptr	dw 1019			; ...
		db 1
		db 11
		db 0
		dw offset Dir_Num
		dw 0
		db 1
		db 0F1h			; long binary to decimal
		db 10
		db 10
		db 20h
dirmes2_ptr	dw 1019			; ...
		db 1
		db 11
		db 0
		dw offset Dir_Num
		dw 0
		db 1
		db 0B1h			; Right_Align+Unsgn_Bin_DWord
		db 9
		db 9
		db 20h
bytmes1_ptr	dw 1020			; ...
		db 1
		db 11
		db 0
		dw offset Bytes_Free
		dw 0
		db 1
		db 0F1h			; long binary to decimal
		db 30			; maximum width
		db 30			; minimum width
		db 20h			; blank
bytmes2_ptr	dw 1020			; ...
		db 1
		db 11
		db 0
		dw offset Bytes_Free
		dw 0
		db 1
		db 0F1h			; long binary to decimal
		db 33			; maximum width
		db 33			; minimum width
		db 20h			; pad
bytmes_n_ptr	dw 1020			; ...
		db 1
		db 11			; parm_block_size
		db 0
		dw offset Bytes_Free
		dw 0
		db 1
		db 0B1h			; Right_Align+Unsgn_Bin_DWord
		db 28
		db 28
		db 20h
baddrv_ptr	dw 1021			; ...
		db 0
cp_not_set_ptr	dw 1022			; ...
		db 1
		db 11
		db 0
		dw offset system_cpage
		dw 0
		db 1
		db 0A1h
		db 5
		db 1
		db 20h
cp_not_all_ptr	dw 1023			; ...
		db 1
		db 11
		db 0
		dw offset system_cpage
		dw 0
		db 1
		db 0A1h			; Right_Align+Unsgn_Bin_Word
		db 5
		db 1
		db 20h
cp_active_ptr	dw 1024			; ...
		db 1
		db 11
		db 0
		dw offset system_cpage
		dw 0
		db 1
		db 0A1h
		db 5
		db 1
		db 20h
NLSFUNC_PTR	dw 1025			; ...
		db 0
INV_CODE_PAGE	dw 1026			; ...
		db 0
BADCURDRV	dw 1027			; ...
		db 0
PAUSEMES_PTR	dw 1028			; ...
		db 0
BADLAB_PTR	dw 1029			; ...
		db 0
SYNTMES_PTR	dw 1030			; ...
		db 0
BADDAT_PTR	dw 1031			; ...
		db 0
CurDat_Ptr	dw 1032			; ...
		db 2
		db 11
		db 0
		dw offset TPBUF		; Arg_Buf
		dw 0
		db 1
		db 10h			; Char_field_ASCIIZ
		db 3
		db 3
		db 20h
		db 11
		db 0
CurDat_yr	dw 0			; ...
CurDat_mo_day	dw 0			; ...
		db 2
		db 34h			; DATE_MDY_4
		db 10
		db 10
		db 20h
WeekTab		dw 1033			; ...
		db 0
NewDat_Ptr	dw 1034			; ...
		db 1
		db 11
		db 0
NewDat_Format	dw 0			; ...
		dw 0
		db 1
		db 10h			; Char_field_ASCIIZ
		db 8
		db 8
		db 20h
BadTim_Ptr	dw 1035			; ...
		db 0
CurTim_Ptr	dw 1036			; ...
		db 1
		db 11
		db 0
CurTim_hr_min	dw 0			; ...
CurTim_Sec_hn	dw 0			; ...
		db 1
		db 0A5h			; Right_Align+TIME_HHMMSSHH_Cty
		db 12
		db 12
		db 20h
NewTim_Ptr	dw 1037			; ...
		db 0
Del_Y_N_Ptr	dw 1038			; ...
		db 0
SureMes_Ptr	dw 1039			; ...
		db 0
VerMes_Ptr	dw 1040			; ...
		db 0			; number of subst
		db 11
		db 0
		dw offset Major_Ver_Num
		dw 0
		db 1
		db 0A1h			; Right_Align+Unsgn_Bin_Word
		db 1
		db 1
		db 20h
		db 11
		db 0
		dw offset Minor_Ver_Num
		dw 0
		db 2
		db 0A1h			; Right_Align+Unsgn_Bin_Word
		db 2
		db 2
		db '0'                  ; 30h ; pad character
VolMes_Ptr_2	dw 1041			; ...
		db 1
		db 11
		db 0
		dw offset vol_drv
		dw 0
		db 1
		db 0			; Char_field_Char
		db 128
		db 1
		db 20h
VolMes_Ptr	dw 1042			; ...
		db 2
		db 11
		db 0
		dw offset vol_drv
		dw 0
		db 1
		db 0			; character
		db 128
		db 1
		db 20h			; blank	(space)
		db 11
		db 0
		dw offset CHARBUF
		dw 0
		db 2
		db 10h			; Char_field_ASCIIZ
		db 128
		db 1
		db 20h
VolSerMes_Ptr	dw 1043			; ...
		db 2
		db 11
		db 0
		dw offset vol_serial+2
		dw 0
		db 1			; first	subst
		db 0A3h			; Right_Align+Bin_Hex_Word
		db 4
		db 4
		db 30h			; '0'
		db 11
		db 0
		dw offset vol_serial
		dw 0
		db 2			; second subst
		db 0A3h			; Right_Align+Bin_Hex_Word
		db 4
		db 4
		db 30h
badcd_ptr	dw 1044			; ...
		db 0
badmkd_ptr	dw 1045			; ...
		db 0
badrmd_ptr	dw 1046			; ...
		db 0
bad_on_off_ptr	dw 1047			; ...
		db 0
dirhead_ptr	dw 1048			; ...
		db 1
		db 11
		db 0
		dw offset BWDBUF
		dw 0
		db 1
		db 10h			; Char_field_ASCIIZ
		db 128
		db 0
		db 20h
NULLPATH_PTR	dw 1049			; ...
		db 0
BADPMES_PTR	dw 1050			; ...
		db 0
BADDEV_PTR	dw 1051			; ...
		db 0
FORNESTMES_PTR	dw 1052			; ...
		db 0
PIPEEMES_PTR	dw 1053			; ...
		db 0
INBDEV_PTR	dw 1054			; ...
		db 0
CtrlcMes_Ptr	dw 1055			; ...
		db 1
		db 11
		db 0
		dw 0
		dw 0
		db 1
		db 10h
		db 128
		db 1
		db 20h
VeriMes_Ptr	dw 1056			; ...
		db 1
		db 11
		db 0
		dw 0
		dw 0
		db 1
		db 10h
		db 128
		db 1
		db 20h
EchoMes_Ptr	dw 1057			; ...
		db 1
		db 11
		db 0
		dw 0
		dw 0
		db 1
		db 10h
		db 128
		db 1
		db 20h
OFFMES_PTR	dw 1059			; ...
		db 0
ONMES_PTR	dw 1060			; ...
		db 0
DEVWMES_PTR	dw 1061			; ...
		db 0
INVAL_PATH_PTR	dw 1062
		db 0
arg_buf_ptr	dw 1063			; ...
		db 1
		db 11
		db 0
		dw offset TPBUF		; Arg_Buf
		dw 0
		db 1
		db 10h			; Char_field_ASCIIZ
		db 128
		db 0
		db 20h
file_name_ptr	dw 1064			; ...
		db 1
		db 11
		db 0
		dw offset SrcBuf
		dw 0
		db 1
		db 10h			; Char_field_ASCIIZ
		db 128
		db 0
		db 20h
disp_file_size_ptr dw 1065		; ...
		db 1
		db 11
		db 0
		dw offset File_Size_Low
		dw 0
		db 1
		db 0F1h
		db 12
		db 12
		db 20h
disp_file_size_w_ptr dw	1065		; ...
		db 1
		db 11
		db 0
		dw offset File_Size_Low
		dw 0
		db 1
		db 0F1h			; long binary to decimal
		db 14
		db 14
		db 20h
disp_file_size_n_ptr dw	1065		; ...
		db 1
		db 11
		db 0
		dw offset File_Size_Low
		dw 0
		db 1
		db 0B1h			; Right_Align+Unsgn_Bin_DWord
		db 10
		db 10
		db 20h
string_buf_ptr	dw 1066			; ...
		db 1
		db 11
		db 0
		dw offset string_ptr_2
		dw 0
		db 1
		db 10h			; Char_field_ASCIIZ
		db 128
		db 0
		db 20h
		db 0
tab_ptr		dw 1067			; ...
		db 0
dmes_ptr	dw 1068			; ...
		db 0
space_4_ptr	dw 1105			; ...
		db 0
dback_ptr	dw 1069			; ...
		db 0
acrlf_ptr	dw 1070			; ...
		db 0
usadat_ptr	dw 1072			; ...
		db 0
eurdat_ptr	dw 1073			; ...
		db 0
japdat_ptr	dw 1074			; ...
		db 0
promptdat_ptr	dw 1075			; ...
		db 2
		db 11
		db 0
		dw offset TPBUF		; Arg_Buf
		dw 0
		db 1
		db 10h			; Char_field_ASCIIZ
		db 3
		db 3
		db 20h
		db 11
		db 0
promptDat_yr	dw 0			; ...
promptDat_moday	dw 0			; ...
		db 2
		db 34h			; DATE_MDY_4
		db 10
		db 8
		db 20h
promtim_ptr	dw 1076			; ...
		db 1
		db 11
		db 0
PromTim_hr_min	dw 0			; ...
PromTim_Sec_hn	dw 0			; ...
		db 1
		db 0A6h			; Right_Align+TIME_HHMMSSHH_24
		db 11
		db 11
		db 20h
dirdattim_ptr	dw 1077			; ...
		db 2
		db 11
		db 0
DirDat_Yr	dw 0			; ...
DirDat_Mo_Day	dw 0			; ...
		db 1
DirDat_form	db 0A4h			; ...
					; Right_Align+DATE_MDY_2
DirDat_width	db 10			; ...
		db 8			; minimum width
		db 20h
		db 11
		db 0
DirTim_Hr_Min	dw 0			; ...
DirTim_Sec_hn	dw 0
		db 2
		db 85h			; Right_align+TIME_HHMM_Cty
		db 6
		db 6
		db 20h
MD_EXISTS_PTR	dw 1078			; ...
		db 0
bytes_ptr	dw 1079			; ...
		db 1
		db 11
		db 0
		dw offset FileSiz
		dw 0
		db 1
		db 0F1h
		db 12
		db 12
		db 20h
bytes_w_tr	dw 1079			; ...
		db 1
		db 11
		db 0
		dw offset FileSiz
		dw 0
		db 1
		db 0F1h
		db 14
		db 14
		db 20h
bytes_n_ptr	dw 1079			; ...
		db 1
		db 11
		db 0
		db 0B1h
		db 160
		db 0
		db 0
		db 1
		db 0B1h
		db 10
		db 10
		db 20h
kbytes_ptr	dw 1107			; ...
		db 1
		db 11
		db 0
		db 0B1h
		db 160
		db 0
		db 0
		db 1
		db 0F1h
		db 14
		db 14
		db 20h
kybytes_n_ptr	dw 1107			; ...
		db 1
		db 11
		db 0
		dw offset FileSiz
		dw 0
		db 1
		db 0B1h
		db 10
		db 10
		db 20h
total_ptr	dw 1080			; ...
		db 0
errparsenv_ptr	dw 1081			; ...
		db 0
cox_Y_quest_ptr	dw 1082			; ...
		db 0			; no_subst
cox_Y_answ_ptr	dw 1083
		db 0
dircont_ptr	dw 1084			; ...
		db 1			; number of subst
		db 11			; parm_block_size ; size of sublist
		db 0			; reserved
		dw offset BWDBUF	; offset of arg
		dw 0			; segment of arg
		db 1			; first	subst
		db 10h			; Char_field_ASCIIZ
		db 128			; maximum width
		db 0			; minimum width
		db 20h			; blank	; pad character
dosrev_ptr	dw 1090			; ...
		db 1
		db 11
		db 0
		dw offset One_Char_Val
		dw 0
		db 1
		db 0			; CHAR_FIELD_CHAR
		db 1
		db 1
		db 20h
DosRom_Ptr	dw 1091			; ...
		db 0
DosHma_Ptr	dw 1092			; ...
		db 0
DosLow_Ptr	dw 1093			; ...
		db 0
NoExecBat_Ptr	dw 1094			; ...
		db 0
LhInvFil_Ptr	dw 1095			; ...
		db 0
NoCntry_Ptr	dw 1096			; ...
		db 0
LhInvArg_Ptr	dw 1097			; ...
		db 0
ReqParmMiss	dw 1098			; ...
		db 0
LhInvSwt_Ptr	dw 1099			; ...
		db 0
LhBadUMB_Ptr	dw 1100			; ...
		db 0
kbytesf_ptr	dw 1106			; ...
		db 1
		db 11
		db 0
		dw offset Bytes_Free
		dw 0
		db 1
		db 0F1h			; long binary to decimal
		db 30
		db 30
		db 20h
kbytesf_n_ptr	dw 1106			; ...
		db 1
		db 11
		db 0
		dw offset Bytes_Free
		dw 0
		db 1
		db 0B1h			; Right_Align+Unsgn_Bin_DWord
		db 28
		db 28
		db 20h
PATH_TEXT	db 'PATH='              ; ...
PROMPT_TEXT	db 'PROMPT='            ; ...
COMSPECSTR	db 'COMSPEC='           ; ...
DirEnvVar	db 'DIRCMD='            ; ...
no_sep_text	db 'NO_SEP='            ; ...
BreakHelpMsgs	dw 1300			; ...
		dw 0
ChcpHelpMsgs	dw 1320			; ...
		dw 1321
		dw 0
CdHelpMsgs	dw 1340			; ...
		dw 1341
		dw 1342
		dw 0
ClsHelpMsgs	dw 1360			; ...
		dw 0
CopyHelpMsgs	dw 1400			; ...
		dw 1401
		dw 1402
		dw 1403
		dw 1404
		dw 1405
		dw 1406
		dw 1407
		dw 0
CttyHelpMsgs	dw 1420			; ...
		dw 0
DateHelpMsgs	dw 1440			; ...
		dw 1441
		dw 0
DelHelpMsgs	dw 1460			; ...
		dw 1461
		dw 1462
		dw 0
DirHelpMsgs	dw 1480			; ...
		dw 1481
		dw 1482
		dw 1483
		dw 1484
		dw 1485
		dw 1486
		dw 1487
		dw 1488
		dw 1489
		dw 0
ExitHelpMsgs	dw 1500			; ...
		dw 0
MdHelpMsgs	dw 1520			; ...
		dw 0
PathHelpMsgs	dw 1540			; ...
		dw 1541
		dw 1542
		dw 0
PromptHelpMsgs	dw 1560			; ...
		dw 1561
		dw 1562
		dw 1563
		dw 1564
		dw 1565
		dw 1566
		dw 1567
		dw 1568
		dw 0
RdHelpMsgs	dw 1580			; ...
		dw 0
RenHelpMsgs	dw 1600			; ...
		dw 1601
		dw 1602
		dw 0
SetHelpMsgs	dw 1620			; ...
		dw 1621
		dw 1622
		dw 0
TimeHelpMsgs	dw 1640			; ...
		dw 1641
		dw 0
TypeHelpMsgs	dw 1660			; ...
		dw 0
VerHelpMsgs	dw 1680			; ...
		dw 0
VerifyHelpMsgs	dw 1700			; ...
		dw 0
VolHelpMsgs	dw 1720			; ...
		dw 0
CallHelpMsgs	dw 1740			; ...
		dw 1741
		dw 0
RemHelpMsgs	dw 1760			; ...
		dw 0
PauseHelpMsgs	dw 1780			; ...
		dw 0
EchoHelpMsgs	dw 1800			; ...
		dw 1801
		dw 0
GotoHelpMsgs	dw 1820			; ...
		dw 1821
		dw 0
ShiftHelpMsgs	dw 1840			; ...
		dw 0
IfHelpMsg	dw 1860			; ...
		dw 1861
		dw 1862
		dw 1863
		dw 1864
		dw 1865
		dw 1866
		dw 0
ForHelpMsgs	dw 1880			; ...
		dw 1881
		dw 1882
		dw 1883
		dw 0
TruenameHelpMsgs dw 1900		; ...
		dw 0
LoadhighHelpMsgs dw 1920		; ...
		dw 1921
		dw 1922
		dw 1923
		dw 1924
		dw 1925
		dw 1926
		dw 1927
		dw 0
twospacechars	db '  ',0               ; ...
CLSSTRING	db 4			; ...
		db 1Bh
PROMPT_TABLE_3	db '[2J'                ; ...
PROMPT_TABLE	db 'B'
		dw offset Print_B
		db 'D'
		dw offset PRINT_DATE
		db 'E'
		dw offset PRINT_ESC
		db 'G'
		dw offset PRINT_G
		db 'H'
		dw offset PRINT_BACK
		db 'L'
		dw offset PRINT_L
		db 'N'
		dw offset PRINT_DRIVE
		db 'P'
		dw offset build_dir_for_prompt
		db 'Q'
		dw offset PRINT_EQ
		db 'R'
		dw offset PRINT_R	; PRINT	Return code, [Retcode]
		db 'T'
		dw offset PRINT_TIME
		db 'V'
		dw offset PRINT_VERSION
		db '_'
		dw offset CRLF2
		db '$'
		dw offset PRINT_CHAR
		db 0
IFTAB		db 3,'NOT'              ; ...
		dw offset IFNOT
		db 10
		db 'ERRORLEVEL'
		dw offset IFERLEV
		db 5
		db 'EXIST'
		dw offset IFEXISTS
		db 0
COMTAB		db 3,'DIR'              ; ...
		db 3
		dw offset CATALOG
		dw offset DirHelpMsgs
		db 4
		db 'CALL'
		db 2
		dw offset _$CALL
		dw offset CallHelpMsgs
		db 4
		db 'CHCP'
		db 2
		dw offset CHCP
		dw offset ChcpHelpMsgs
		db 6
		db 'RENAME'
		db 3
		dw offset CRENAME
		dw offset RenHelpMsgs
		db 3
		db 'REN'
		db 3
		dw offset CRENAME
		dw offset RenHelpMsgs
		db 5
		db 'ERASE'
		db 3
		dw offset ERASE
		dw offset DelHelpMsgs
		db 3
		db 'DEL'
		db 3
		dw offset ERASE
		dw offset DelHelpMsgs
		db 4
		db 'TYPE'
		db 3
		dw offset TYPEFIL
		dw offset TypeHelpMsgs
		db 3
		db 'REM'
		db 6
		dw offset TCOMMAND
		dw offset RemHelpMsgs
		db 4
		db 'COPY'
		db 3
		dw offset COPY
		dw offset CopyHelpMsgs
		db 5
		db 'PAUSE'
		db 6
		dw offset PAUSE
		dw offset PauseHelpMsgs
		db 4
		db 'DATE'
		db 2
		dw offset DATE
		dw offset DateHelpMsgs
		db 4
		db 'TIME'
		db 2
		dw offset CTIME
		dw offset TimeHelpMsgs
		db 3
		db 'VER'
		db 2
		dw offset VERSION
		dw offset VerHelpMsgs
		db 3
		db 'VOL'
		db 3
		dw offset VOLUME
		dw offset VolHelpMsgs
		db 2,'CD'
		db 3
		dw offset _$CHDIR
		dw offset CdHelpMsgs
		db 5
		db 'CHDIR'
		db 3
		dw offset _$CHDIR
		dw offset CdHelpMsgs
		db 2,'MD'
		db 3
		dw offset _$MKDIR
		dw offset MdHelpMsgs
		db 5
		db 'MKDIR'
		db 3
		dw offset _$MKDIR
		dw offset MdHelpMsgs
		db 2,'RD'
		db 3
		dw offset _$RMDIR
		dw offset RdHelpMsgs
		db 5
		db 'RMDIR'
		db 3
		dw offset _$RMDIR
		dw offset RdHelpMsgs
		db 5
		db 'BREAK'
		db 2
		dw offset CNTRLC
		dw offset BreakHelpMsgs
		db 6
		db 'VERIFY'
		db 2
		dw offset VERIFY
		dw offset VerifyHelpMsgs
		db 3
		db 'SET'
		db 6
		dw offset ADD_NAME_TO_ENVIRONMENT
		dw offset SetHelpMsgs
		db 6
		db 'PROMPT'
		db 6
		dw offset ADD_PROMPT
		dw offset PromptHelpMsgs
		db 4
		db 'PATH'
		db 2
		dw offset PATH
		dw offset PathHelpMsgs
		db 4
		db 'EXIT'
		db 0
		dw offset _$EXIT
		dw offset ExitHelpMsgs
		db 4
		db 'CTTY'
		db 3
		dw offset CTTY
		dw offset CttyHelpMsgs
		db 4
		db 'ECHO'
		db 6
		dw offset _ECHO
		dw offset EchoHelpMsgs
		db 4
		db 'GOTO'
		db 6
		dw offset _GOTO
		dw offset GotoHelpMsgs
		db 5
		db 'SHIFT'
		db 2
		dw offset _SHIFT
		dw offset ShiftHelpMsgs
		db 2
		db 'IF'
		db 6
		dw offset _$IF
		dw offset IfHelpMsg
		db 3
		db 'FOR'
		db 6
		dw offset _$FOR
		dw offset ForHelpMsgs
		db 3
		db 'CLS'
		db 0
		dw offset CLS
		dw offset ClsHelpMsgs
		db 8
		db 'TRUENAME'
		db 3
		dw offset TRUENAME
		dw offset TruenameHelpMsgs
		db 8
		db 'LOADHIGH'
		db 2
		dw offset LoadHigh
		dw offset LoadhighHelpMsgs
		db 2
		db 'LH'
		db 2
		dw offset LoadHigh
		dw offset LoadhighHelpMsgs
		db 0
comext		db '.COM'               ; ...
exeext		db '.EXE'               ; ...
batext		db '.BAT'               ; ...
switch_list	db '-Y?VBAPW'           ; ...
AttrLtrs	db 'RHSvDA'             ; ...
OrderLtrs	db 'NEDSG'              ; ...
comspec_flag	db 0			; ...
BATBUFLEN	dw 20h			; ...
NO_VALUES	dw 0			; ...
NULL_VALUE_LIST	db 0			; ...
FILE_REQUIRED	dw 200h			; ...
		dw 1
		dw offset PARSE1_OUTPUT
		dw offset NO_VALUES
		db 0
FILE_OPTIONAL	dw 301h			; ...
		dw 1
		dw offset PARSE1_OUTPUT
		dw offset NO_VALUES
		db 0
FILE_OPTIONAL2	dw 201h			; ...
		dw 1
		dw offset PARSE1_OUTPUT
		dw offset NO_VALUES
		db 0
SLASH_P_SWITCH	dw 0			; ...
		dw 2
		dw offset PARSE1_OUTPUT
		dw offset NO_VALUES
		db 1
SLASH_P_SYN	db '/P',0               ; ...
PARSE_BREAK	dw offset BREAK_PARMS	; ...
		db 0
BREAK_PARMS	db 0, 1			; 0 ; ...
		dw offset BREAK_CONTROL1
		db 0
		db 0
BREAK_CONTROL1	dw 2001h		; ...
		dw 2
		dw offset PARSE1_OUTPUT
		dw offset BREAK_VALUES
		db 0
BREAK_VALUES	db 3			; ...
		db 0
		db 0
		db 2
		db 0
		dw offset BREAK_ON	; "ON"
		db 'f'
		dw offset BREAK_OFF	; "OFF"
BREAK_ON	db 'ON',0               ; ...
BREAK_OFF	db 'OFF',0              ; ...
PARSE_CHCP	dw offset CHCP_PARMS	; ...
					; "\x01"
		db 0
CHCP_PARMS	db 0,1			; ...
		dw offset CHCP_CONTROL1
		db 0
		db 0
CHCP_CONTROL1	dw 8001h		; ...
		dw 0
		dw offset PARSE1_OUTPUT
		dw offset CHCP_VALUES
		db 0
CHCP_VALUES	db 1			; ...
		db 1
		db 1
		dd 100			; CHCP_MINVAL
		dd 999			; CHCP_MAXVAL
		db 0
		db 0
PARSE_DATE	dw offset DATE_PARMS	; ...
					; "\x01"
		db 0
DATE_PARMS	db 0,1			; ...
		dw offset DATE_CONTROL1
		db 0
		db 0
DATE_CONTROL1	dw 1001h		; ...
		dw 0
		dw offset DATE_OUTPUT
		dw offset NO_VALUES
		db 0
PARSE_TIME	dw offset TIME_PARMS	; ...
		db 0
TIME_PARMS	db 0, 1			; 0 ; ...
		dw offset TIME_CONTROL1
		db 0
		db 0
TIME_CONTROL1	dw 801h			; ...
		dw 0
		dw offset TIME_OUTPUT
		dw offset NO_VALUES
		db 0
PARSE_VOL	dw offset VOL_PARMS	; ...
					; "\x01"
		db 0
VOL_PARMS	db 0,1			; ...
		dw offset DRIVE_CONTROL1
		db 0
		db 0
DRIVE_CONTROL1	dw 101h			; ...
		dw 1
		dw offset DRIVE_OUTPUT
		dw offset NO_VALUES
		db 0
PARSE_MRDIR	dw offset MRDIR_PARMS	; ...
					; "\x01\x01"
		db 0
MRDIR_PARMS	db 1,1			; ...
		dw offset FILE_REQUIRED
		db 0
		db 0
PARSE_CHDIR	dw offset CHDIR_PARMS	; ...
					; "\x01"
		db 0
CHDIR_PARMS	db 0,1			; ...
		dw offset FILE_OPTIONAL
		db 0
		db 0
PARSE_ERASE	dw offset ERASE_PARMS	; ...
					; "\x01\x01"
		db 0
ERASE_PARMS	db 1,1			; ...
		dw offset FILE_REQUIRED
		db 1
		dw offset SLASH_P_SWITCH
		db 0
PARSE_DIR	dw offset DIR_PARMS	; ...
		db 0
DIR_PARMS	db 0, 1			; 0 ; ...
		dw offset FILE_OPTIONAL2
		db 2
		dw offset DIR_SW_VALUED
		dw offset DIR_SW_UNVALUED
		db 0
DIR_SW_VALUED	dw 2001h		; ...
		dw 21h
		dw offset PARSE1_OUTPUT
		dw offset NULL_VALUE_LIST
		db 2
DIR_SW_A	db '/A',0               ; ...
DIR_SW_O	db '/O',0               ; ...
DIR_SW_UNVALUED	dw 0			; ...
		dw 0
		dw offset PARSE1_OUTPUT
		dw offset NO_VALUES
		db 16
DIR_SW_NEG_A	db '/-A',0              ; ...
DIR_SW_NEG_O	db '/-O',0              ; ...
DIR_SW_S	db '/S',0               ; ...
DIR_SW_NEG_S	db '/-S',0              ; ...
DIR_SW_B	db '/B',0               ; ...
DIR_SW_NEG_B	db '/-B',0              ; ...
DIR_SW_W	db '/W',0               ; ...
DIR_SW_NEG_W	db '/-W',0              ; ...
DIR_SW_P	db '/P',0               ; ...
DIR_SW_NEG_P	db '/-P',0              ; ...
DIR_SW_L	db '/L',0               ; ...
DIR_SW_NEG_L	db '/-L',0              ; ...
DIR_SW_Z	db '/Z',0               ; ...
DIR_SW_NEG_Z	db '/-Z',0              ; ...
DIR_SW_4	db '/4',0               ; ...
DIR_SW_NEG_4	db '/-4',0              ; ...
Dir_Sw_Ptrs	dw offset DIR_SW_NEG_W	; ...
					; "/-W"
Dir_Sw_Ptrs_2	dw offset DIR_SW_W	; ...
					; "/W"
		dw offset DIR_SW_NEG_P	; "/-P"
		dw offset DIR_SW_P	; "/P"
		dw offset DIR_SW_NEG_S	; "/-S"
		dw offset DIR_SW_S	; "/S"
		dw offset DIR_SW_NEG_B	; "/-B"
		dw offset DIR_SW_B	; "/B"
		dw offset DIR_SW_NEG_L	; "/-L"
		dw offset DIR_SW_L	; "/L"
		dw offset DIR_SW_NEG_Z	; "/-Z"
		dw offset DIR_SW_Z	; "/Z"
		dw offset DIR_SW_NEG_4	; "/-4"
		dw offset DIR_SW_4	; "/4"
		dw offset DIR_SW_NEG_O	; "/-O"
		dw offset DIR_SW_O	; "/O"
		dw offset DIR_SW_NEG_A	; "/-A"
		dw offset DIR_SW_A	; "/A"
PARSE_RENAME	dw offset RENAME_PARMS	; ...
		db 0
RENAME_PARMS	db 2, 2			; 0 ; ...
		dw offset FILE_REQUIRED
		dw offset FILE_REQUIRED
		db 0
		db 0
PARSE_CTTY	dw offset CTTY_PARMS	; ...
		db 0
CTTY_PARMS	db 1, 1			; 0 ; ...
		dw offset CTTY_CONTROL1
		db 0
		db 0
CTTY_CONTROL1	dw 2000h		; ...
		dw 11h
		dw offset PARSE1_OUTPUT
		dw offset NO_VALUES
		db 0
PARSE_VER	dw offset VER_PARMS	; ...
		db 0
VER_PARMS	db 0, 0			; 0 ; ...
		db 1
		dw offset SLASH_R
		db 0
SLASH_R		dw 0			; ...
		dw 2
		dw offset PARSE1_OUTPUT
		dw offset NO_VALUES
		db 1
		db '/R',0
Parse_LoadHi	dw offset LoadHi_Parms
		db 0
LoadHi_Parms	db 1			; ...
		db 1
		dw offset FILE_REQUIRED
		db 0
		db 0
TempVarName	db 'TEMP=',0            ; ...
copycmd		db 'COPYCMD='           ; ...
REXX_EXE	db 'REXX.EXE',0         ; ...
$P_ORDINAL	dw 0			; ...
$P_RC		dw 0			; ...
$P_SI_Save	dw 0			; ...
$P_DX		dw 0			; ...
$P_Terminator	db 0			; ...
$P_DBCSEV_OFF	dw 0			; ...
$P_DBCSEV_SEG	dw 0			; ...
$P_Flags	db 0			; ...
$P_Flags2	db 0			; ...
$P_SaveSI_Cmpx	dw 0			; ...
$P_KEYorSW_Ptr	dw 0			; ...
$P_Save_EOB	dw 0			; ...
$P_Found_SYNONYM dw 0			; ...
$P_STRING_BUF	db 128 dup(0)		; 0 ; ...
$P_ORIG_ORD	dw 0			; ...
$P_ORIG_STACK	dw 0			; ...
$P_ORIG_SI	dw 0			; ...
$P_Got_Time	db 0			; ...
$P_Country_Info	dw 0FFFFh		; ...
		db 32 dup(0)		; 0
$P_1st_Val	dw 0			; ...
$P_2nd_Val	dw 0			; ...
$P_3rd_Val	dw 0			; ...
$P_4th_Val	dw 0			; ...
$P_Char_CAP_Ptr	db 0FFh			; ...
		dw 0
		dw 0
$P_File_CAP_Ptr	db 0FFh			; ...
		dw 0
		dw 0
$P_FileSp_Char	db '[]|<>+=;"'          ; ...
$P_err_flag	db 0			; ...
$M_RT_$M_EXT_ERR_ADDRS dw 2 dup(0)	       ; 0 ; ...
$M_RT_$M_EXT_FILE dw 2 dup(0)		  ; 0 ;	...
$M_RT_$M_EXT_COMMAND dw	2 dup(0)	     ; 0 ; ...
		dd 0FFFFFFFFh
$M_RT_$M_PARSE_COMMAND dw 2 dup(0)	       ; 0 ; ...
$M_RT_$M_PARSE_ADDRS dw	2 dup(0)	     ; 0 ; ...
		dd 0FFFFFFFFh
$M_RT_$M_CRIT_ADDRS dw 2 dup(0)		    ; 0	; ...
$M_RT_$M_CRIT_COMMAND dw 2 dup(0)	      ;	0 ; ...
		dd 0FFFFFFFFh
$M_RT_$M_DISK_PROC_ADDR	dd 0FFFFFFFFh	; ...
$M_RT_$M_CLASS_ADDRS dd	0		; ...
		dd 0
		dd 0
		dd 0FFFFFFFFh
$M_RT_$M_DBCS_VEC dw 2 dup(0)		  ; 0 ;	...
$M_RT_$M_HANDLE	dw 0			; ...
$M_RT_$M_SIZE	db 0			; ...
$M_RT_$M_CRLF	db 0Dh,0Ah		; ...
$M_RT_$M_CLASS	db 0			; ...
$M_RT_$M_RETURN_ADDR dw	0		; ...
$M_RT_$M_MSG_NUM dw 0			; ...
$M_RT_$M_DIVISOR dw 10			; ...
$M_RT_$M_TEMP_BUF dw 2424h		; ...
		db 5 dup(24h)		; 0
$M_RT_$M_THOU_SEPARA dw	2424h		; ...
$M_RT_$M_DECI_SEPARA dw	2424h		; ...
$M_RT_$M_DATE_SEPARA dw	2424h		; ...
$M_RT_$M_TIME_SEPARA dw	2424h		; ...
		db 2 dup(24h)		; 0
$M_RT_$M_TIME_FORMAT dw	2424h		; ...
		db 2Dh dup(24h)		; 0
$M_RT_$M_BUF_TERM db 24h		; ...
PRINTF_HANDLE	dw 0			; ...
SRCXNAME	db 87 dup(0)		; 0 ; ...
TRGXNAME	db 87 dup(0)		; 0 ; ...
UCOMBUF		db 131 dup(0)		; 0 ; ...
COMBUF		db 131 dup(0)		; 0 ; ...
USERDIR1	db 70 dup(0)		; 0 ; ...
EXECPATH	db 131 dup(0)		; 0 ; ...
RE_INSTR	db 83 dup(0)		; 0 ; ...
HEADCALL	dw 0			; ...
RESSEG		dw 0			; ...
TPA		dw 0			; ...
SWITCHAR	db 0			; ...
DIRCHAR		db 0			; ...
EXEC_ADDR	dd 0			; ...
RCH_ADDR	dd 0			; ...
TRAN_TPA	dw 0			; ...
CHKDRV		db 0			; ...
IFNOTFLAG	db 0			; ...
CURDRV		db 0			; ...
PARM1		db 0			; ...
notzerofile	db 0			; ...
PARM2		db 0			; ...
COMSW		dw 0			; ...
ARG1S		dw 0			; ...
DestSwitch	dw 0			; ...
ARGTS		dw 0			; ...
CFLAG		db 0			; ...
SPECDRV		db 0			; ...
BYTCNT		dw 0			; ...
		dw 0
NXTADD		dw 0			; ...
FRSTSRCH	db 0			; ...
LeftOnLine	db 0			; ...
PerLine		db 0			; ...
LeftOnPage	dw 0			; ...
FileCnt		dw 0			; ...
FileSiz		dw 4 dup(0)		; 0 ; ...
narrow		db 0			; ...
nocommas	db 0			; ...
yeardigit4	db 0			; ...
bfree_not_kilo	db 0			; ...
efs_buffer	db 44 dup(0)		; 0 ; ...
efs_drive	db 'C:\',0              ; ...
FileCntTotal	dw 2 dup(0)		; 0 ; ...
FileSizTotal	dw 4 dup(0)		; 0 ; ...
CHARBUF		db 80 dup(0)		; 0 ; ...
IDLEN		db 0			; ...
ID		db 8 dup(0)		; 0 ; ...
COM		db 3 dup(0)		; 0
DEST		db 37 dup(0)		; 0 ; ...
DESTNAME	db 11 dup(0)		; 0
DESTDIR		db 67 dup(0)		; 0 ; ...
BWDBUF		db 70 dup(0)		; 0 ; ...
SDIRBUF		db 12 dup(0)		; 0 ; ...
_Bits		dw 0			; ...
PathCnt		dw 0			; ...
PathPos		dw 0			; ...
PathSw		dw 0			; ...
AttrSpecified	db 0			; ...
AttrSelect	db 0			; ...
comma		db 0			; ...
plus_comma	db 0			; ...
DirFlag		db 0			; ...
parse_last	dw 0			; ...
system_cpage	dw 0			; ...
File_Size_Low	dw 0			; ...
File_Size_High	dw 0			; ...
string_ptr_2	dw 0			; ...
Copy_num	dw 0			; ...
cpyflag		db 0			; ...
Dir_Num		dw 2 dup(0)		; 0 ; ...
Bytes_Free	dd 0			; ...
Major_Ver_Num	dw 0			; ...
Minor_Ver_Num	dw 0			; ...
One_Char_Val	db 0			; ...
		db 0
vol_drv		db 0			; ...
ROM_CALL	db 0			; ...
ROM_IP		dw 0			; ...
ROM_CS		dw 0			; ...
DestIsDir	db 0			; ...
DestSiz		db 0			; ...
DestTail	dw 0			; ...
DestInfo	db 0			; ...
DestBuf		db 87 dup(0)		; 0 ; ...
EndDestBuf	dw 0			; ...
DESTISDEV	db 0			; ...
FIRSTDEST	db 0			; ...
MELCOPY		db 0			; ...
MELSTART	dw 0			; ...
SrcIsDir	db 0			; ...
SrcSiz		db 0			; ...
SrcTail		dw 0			; ...
SrcInfo		db 0			; ...
SrcBuf		db 87 dup(0)		; 0 ; ...
SRCHAND		dw 0			; ...
SRCISDEV	db 0			; ...
ScanBuf		db 87 dup(0)		; 0 ; ...
SRCPT		dw 0			; ...
INEXACT		db 0			; ...
NOWRITE		db 0			; ...
BINARY		db 0			; ...
WRITTEN		dw 0			; ...
TERMREAD	db 0			; ...
ASCII		db 0			; ...
PLUS		db 0			; ...
objcnt		db 0			; ...
CPDATE		dw 0			; ...
CPTIME		dw 0			; ...
OFilePtr_Lo	dw 0			; ...
OFilePtr_Hi	dw 0			; ...
zflag		db 0			; ...
cox_sublist_buff db 11 dup(0)		 ; 0 ; ...
cox_y_override	db 0			; ...
cox_dest_file	db 0			; ...
cox_src_file	db 0			; ...
BATHAND		dw 0			; ...
STARTEL		dw 0			; ...
ELCNT		db 0			; ...
ELPOS		db 0			; ...
SKPDEL		db 0			; ...
SOURCE		db 11 dup(0)		; 0
ext_entered	db 0			; ...
Display_Ioctl	db 0			; ...
		db 0
		dw 14			; crt_ioctl_ln
		dw 0
display_mode	db 0
		db 0
		dw 0
		dw 0
		dw 0
display_width	dw 0			; ...
LinPerPag	dw 25			; ...
vol_ioctl_buf	dw 0			; ...
vol_serial	dd 0			; ...
vol_label	db 0Bh dup(20h)		; 0
		db 8 dup(20h)		; 0
expand_star	db 0			; ...
msg_flag	db 0			; ...
Msg_Numb	dw 0			; ...
append_exec	db 0			; ...
print_err_flag	dw 0			; ...
subst_buffer	db 22 dup(0)		; 0 ; ...
KPARSE		db 0			; ...
ARG_ARGV	dw 0			; ...
ARGV0_ARG_FLAGS	db 0			; ...
ARGV0_ARGSTARTEL dw 0			; ...
ARGV0_ARGLEN	dw 0			; ...
ARGV0_ARGSW_WORD dw 0			; ...
ARGV0_OCOMPTR	dw 0			; ...
ARGV1_ARGPOINTER dw 0			; ...
		dw 0
		dw 0
		db 0
ARGV1_ARGSW_WORD dw 0			; ...
		dw 0
ARGV2_ARGPOINTER dw 0			; ...
		dw 0
		dw 0
		db 0
ARGV2_ARGSW_WORD dw 0			; ...
		dw 0
		db 671 dup(0)		; 0 ; ARGV[3] to ARGV[63]
ARG_ARGVCNT	dw 0			; ...
ARG_ARGSWINFO	dw 0			; ...
ARG_ARGBUF	dw 128 dup(0)		; 0 ; ...
					; times	ARGBLEN	dw 0
ARG_ARGFORCOMBUF db 128	dup(0)		 ; 0 ; ...
ARGBUF_PTR	dw 0			; ...
TPBUF		db 128 dup(0)		; 0 ; ...
LASTARG		dw 0			; ...
COMPTR		dw 0			; ...
FBUF		db 43 dup(0)		; 0 ; ...
					; times	FINDBUFLEN db 0
pathinfo	dw 0, 0, 0		; 0 ; ...
psep_char	db 0			; ...
search_best	db 0			; ...
search_best_buf	db 13 dup(0)		; 0 ; ...
					; times	FNAME_MAX_LEN db 0
search_curdir_buf db 64	dup(0)		  ; 0 ;	...
search_error	dw 0			; ...
IF_NOT_COUNT	dw 0			; ...
		db 256 dup(0)		; 0
STACK		dw 0			; ...
CURRENCY_SYM	db 5 dup(0)		; 0
THOUS_SEP	db 2 dup(0)		; 0
DECIMAL_SEP	db 2 dup(0)		; 0
DATE_SEP	db 2 dup(0)		; 0
TIME_SEP	db 2 dup(0)		; 0
BIT_FIELD	db 0
CURRENCY_CENTS	db 0
TIME_24		db 0
MAP_CALL	dd 0
DATA_SEP	db 2 dup(0)		; 0
		db 8 dup(0)		; 0
CountryPtrId	db 0			; ...
CountryPtr	dd 0			; ...
OldCtrlCHandler	dd 0			; ...
BATBUFPOS	dw 0			; ...
BATBUF		db 32 dup(0)		; 0 ; ...
BATBUFEND	dw 0			; ...
PARSE1_OUTPUT	db 0			; ...
PARSE1_CODE	db 0			; ...
PARSE1_SYN	dw 0			; ...
PARSE1_ADDR	dd 0			; ...
DATE_OUTPUT	db 0			; ...
		db 0
		dw 0
DATE_YEAR	dw 0			; ...
DATE_MONTH	db 0			; ...
DATE_DAY	db 0			; ...
TIME_OUTPUT	db 0			; ...
		db 0
		dw 0
TIME_HOUR	db 0			; ...
TIME_MINUTES	db 0			; ...
TIME_SECONDS	db 0			; ...
TIME_FRACTION	db 0			; ...
DRIVE_OUTPUT	db 0			; ...
DRIVE_VALUE	db 0
		dw 0
DRIVE_NUMBER	db 0
		db 3 dup(0)		; 0
ends		TRANGROUP


		end start
